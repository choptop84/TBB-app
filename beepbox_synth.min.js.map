{"version":3,"names":["Config","centerWave","wave","sum","i","length","average","performIntegral","push","Float32Array","cumulative","temp","getPulseWidthRatio","pulseWidth","Math","pow","pulseWidthRange","pulseWidthStepPower","getDrumWave","index","inverseRealFourierTransform","scaleElementsByFactor","chipNoises","samples","chipNoiseLength","drumBuffer","newBuffer","random","Error","drawNoiseSpectrum","sqrt","waveLength","lowOctave","highOctave","lowPower","highPower","overallSlope","lowIndex","highIndex","min","retroWave","combinedAmplitude","lerped","log2","amplitude","radians","PI","cos","sin","getArpeggioPitchIndex","pitchCount","rhythm","arpeggio","arpeggioPattern","rhythms","arpeggioPatterns","toNameMap","array","dictionary","value","name","result","effectsIncludeTransition","effects","effectsIncludeChord","effectsIncludePitchShift","effectsIncludeDetune","effectsIncludeVibrato","effectsIncludeNoteFilter","effectsIncludeDistortion","effectsIncludeBitcrusher","effectsIncludePanning","effectsIncludeChorus","effectsIncludeEcho","effectsIncludeReverb","factor","countBits","n","isPowerOf2","round","log","fullArrayLength","totalPasses","pass","subStride","midSubStride","stride","radiansIncrement","cosIncrement","sinIncrement","oscillatorMultiplier","startIndex","startIndexA","midIndexA","startIndexB","midIndexB","stopIndex","realStartA","imagStartB","c","s","cPrev","sPrev","indexA0","indexA1","indexB0","indexB1","real0","real1","imag0","imag1","tempA","tempB","cTemp","sTemp","index1","index2","index3","imag2","imag3","bitCount","finalShift","j","reverseIndexBits","scales","realName","flags","keys","isWhiteKey","basePitch","blackKeyNameParents","tempoMin","tempoMax","echoDelayRange","echoDelayStepTicks","echoSustainRange","echoShelfHz","echoShelfGain","reverbShelfHz","reverbShelfGain","reverbRange","reverbDelayBufferSize","reverbDelayBufferMask","beatsPerBarMin","beatsPerBarMax","barCountMin","barCountMax","instrumentCountMin","layeredInstrumentCountMax","patternInstrumentCountMax","partsPerBeat","ticksPerPart","stepsPerBeat","ticksPerArpeggio","roundUpThresholds","instrumentTypeNames","instrumentTypeHasSpecialInterval","chipBaseExpression","fmBaseExpression","noiseBaseExpression","spectrumBaseExpression","drumsetBaseExpression","harmonicsBaseExpression","pwmBaseExpression","supersawBaseExpression","pickedStringBaseExpression","distortionBaseVolume","bitcrusherBaseVolume","chipWaves","expression","pitchFilterMult","isSoft","filterFreqStep","filterFreqRange","filterFreqReferenceSetting","filterFreqReferenceHz","filterFreqMaxHz","filterFreqMinHz","filterGainRange","filterGainCenter","filterGainStep","filterMaxPoints","filterTypeNames","fadeInRange","fadeOutTicks","fadeOutNeutral","drumsetFadeOutTicks","transitions","isSeamless","continues","slides","slideTicks","includeAdjacentPatterns","vibratos","periodsSeconds","delayTicks","unisons","voices","spread","offset","sign","effectNames","effectOrder","noteSizeMax","volumeRange","volumeLogScale","panCenter","panMax","panDelaySecondsMax","chorusRange","chorusPeriodSeconds","chorusDelayRange","chorusDelayOffsets","chorusPhaseOffsets","chorusMaxDelay","concat","reduce","x","y","max","chords","customInterval","arpeggiates","strumParts","singleTone","maxChordSize","operatorCount","maxPitchOrOperatorCount","algorithms","carrierCount","associatedCarrier","modulatedBy","operatorCarrierInterval","operatorAmplitudeMax","operatorFrequencies","mult","hzOffset","amplitudeSign","envelopes","type","speed","feedbacks","indices","spectrumNoiseLength","spectrumBasePitch","spectrumControlPoints","spectrumControlPointsPerOctave","spectrumControlPointBits","spectrumMax","harmonicsControlPoints","harmonicsRendered","harmonicsRenderedForPickedString","harmonicsControlPointBits","harmonicsMax","harmonicsWavelength","supersawVoiceCount","supersawDynamismMax","supersawSpreadMax","supersawShapeMax","pitchChannelCountMin","pitchChannelCountMax","noiseChannelCountMin","noiseChannelCountMax","noiseInterval","pitchesPerOctave","drumCount","pitchOctaves","maxPitch","maximumTonesPerChannel","justIntonationSemitones","map","pitchShiftRange","pitchShiftCenter","detuneCenter","detuneMax","sineWaveLength","sineWaveMask","sineWave","generateSineWave","pickedStringDispersionCenterFreq","pickedStringDispersionFreqScale","pickedStringDispersionFreqMult","pickedStringShelfHz","stringSustainRange","stringDecayRate","enableAcousticSustain","sustainTypeNames","distortionRange","bitcrusherFreqRange","bitcrusherOctaveStep","bitcrusherQuantizationRange","maxEnvelopeCount","defaultAutomationRange","instrumentAutomationTargets","computeIndex","displayName","interleave","isFilter","maxCount","effect","compatibleInstruments","Deque","constructor","this","_capacity","_buffer","undefined","_mask","_offset","_count","pushFront","element","_expandCapacity","pushBack","popFront","popBack","peakFront","peakBack","count","set","get","remove","oldBuffer","Array","size","FilterCoefficients","a","b","order","linearGain0thOrder","linearGain","lowPass1stOrderButterworth","cornerRadiansPerSample","g","tan","a0","lowPass1stOrderSimplified","highPass1stOrderButterworth","highShelf1stOrder","shelfLinearGain","sqrtGain","allPass1stOrderInvertPhaseAbove","allPass1stOrderFractionalDelay","delay","lowPass2ndOrderButterworth","peakLinearGain","alpha","lowPass2ndOrderSimplified","filterResonance","feedback","highPass2ndOrderButterworth","highShelf2ndOrder","slope","A","Aplus","Aminus","sqrtA2Alpha","peak2ndOrder","bandWidthScale","bandWidth","FrequencyResponse","real","imag","denom","analyze","filter","radiansPerSample","analyzeComplex","realZ1","imagZ1","realNum","imagNum","realDenom","imagDenom","realZ","imagZ","imagTemp","magnitude","angle","atan2","DynamicBiquadFilter","a1","a2","b0","b1","b2","a1Delta","a2Delta","b0Delta","b1Delta","b2Delta","output1","output2","useMultiplicativeInputCoefficients","resetOutput","loadCoefficientsWithGradient","start","end","deltaRate","warpInfinityToNyquist","atan","epsilon","clamp","val","validateRange","base64IntToCharCode","base64CharCodeToInt","BitFieldReader","source","_bits","_readIndex","charCodeAt","read","readLongTail","minValue","minBits","numBits","readPartDuration","readLegacyPartDuration","readPinCount","readPitchInterval","BitFieldWriter","_index","clear","write","writeLongTail","writePartDuration","writePinCount","writePitchInterval","other","encodeBase64","buffer","lengthBase64","ceil","makeNotePin","interval","time","Note","pitch","fadeout","pitches","pins","continuesLastPattern","pickMainInterval","longestFlatIntervalDuration","mainInterval","pinIndex","pinA","pinB","duration","loudestSize","pin","clone","newNote","getEndPinIndex","part","endPinIndex","Pattern","notes","instruments","cloneNotes","note","reset","toJsonObject","song","noteArray","pointArray","tick","pitchBend","volume","noteObject","points","patternObject","patternInstruments","fromJsonObject","channel","importedPartsPerBeat","isNoiseChannel","isArray","instrumentCount","getMaxInstrumentsPerPatternForChannel","maxNoteCount","beatsPerBar","tickClock","k","indexOf","noteClock","startInterval","pointObject","lowestPitch","highestPitch","splice","Operator","frequency","SpectrumWave","spectrum","hash","isHarmonic","markCustomWaveDirty","hashMult","Synth","fittingPowerOfTwo","point","SpectrumWaveState","_hash","getCustomWave","settings","lowestOctave","pitchTweak","controlPointToOctave","floor","value1","value2","octave1","octave2","HarmonicsWave","harmonics","HarmonicsWaveState","instrumentType","_generatedForType","combinedControlPointAmplitude","harmonicIndex","harmonicFreq","controlValue","normalizedValue","FilterControlPoint","freq","gain","freqSetting","gainSetting","getHz","getHzFromSettingValue","getSettingValueFromHz","hz","getRoundedSettingValueFromHz","getLinearGain","peakMult","power","neutral","interpolatedPower","getRoundedSettingValueFromLinearGain","toCoefficients","sampleRate","freqMult","getVolumeCompensationMult","octave","gainPow","freqRelativeTo8khz","warpedFreq","warpedOctave","distanceFromCenter","freqLoudness","FilterSettings","controlPoints","controlPointCount","addPoint","controlPoint","filterArray","cutoffHz","filterObject","convertLegacySettings","legacyCutoffSetting","legacyResonanceSetting","legacyEnv","legacyFilterMaxRadians","asin","legacyFilterMax","resonant","firstOrder","cutoffAtMax","legacyFilterCutoffRange","envDecays","standardSampleRate","legacyHz","legacyRadians","extraOctaves","targetRadians","curvedHz","finalHz","finalRadians","legacyFilter","response","legacyFilterGainAtNewRadians","logGain","convertedGain","intendedGain","invertedGain","curvedRadians","legacyFilterGain","EnvelopeSettings","target","envelope","envelopeObject","Instrument","preset","chipWave","chipNoise","eqFilter","noteFilter","envelopeCount","fadeIn","fadeOut","transition","pitchShift","detune","vibrato","unison","chord","pan","supersawDynamism","supersawSpread","supersawShape","stringSustain","stringSustainType","distortion","bitcrusherFreq","bitcrusherQuantization","chorus","reverb","echoSustain","echoDelay","algorithm","feedbackType","feedbackAmplitude","operators","harmonicsWave","drumsetEnvelopes","drumsetSpectrumWaves","spectrumWave","setTypeAndReset","legacySettings","filterCutoff","legacyFilterEnv","filterEnvelope","legacyPulseEnv","pulseEnvelope","legacyOperatorEnvelopes","operatorEnvelopes","legacyFeedbackEnv","feedbackEnvelope","noCarriersControlledByNoteSize","allCarriersControlledByNoteSize","noteSizeControlsSomethingElse","addEnvelope","instrumentObject","getChord","detuneToCents","fadeInSettingToSeconds","fadeOutSettingToTicks","getDrumsetEnvelope","operatorArray","operator","legacyGlobalReverb","legacyEffectsNames","transitionProperty","binary","fadeInSeconds","seamless","sudden","hard","smooth","soft","slide","secondsToFadeInSetting","ticksToFadeOutSetting","chordProperty","legacyChordNames","harmony","unisonProperty","legacyChorusNames","union","fifths","octaves","centsToDetune","vibratoProperty","legacyVibratoNames","isNaN","findIndex","legacyEnvelopeNames","custom","steady","getEnvelope","drum","legacyWaveNames","triangle","square","sawtooth","spiky","plateau","operatorObject","filterCutoffMaxHz","filterCutoffRange","filterResonanceRange","LN2","legacyToCutoff","legacyToEnvelope","filterNames","oldFilterNames","envelopeArray","tempEnvelope","frequencyFromPitch","supportsEnvelopeTarget","envelopeSettings","automationTarget","clearInvalidEnvelopeTargets","envelopeIndex","getTransition","getFadeInSeconds","getFadeOutTicks","Channel","patterns","bars","muted","Song","string","channels","fromBase64String","initToDefault","getChannelCount","pitchChannelCount","noiseChannelCount","getMaxInstrumentsPerChannel","layeredInstruments","getMaxInstrumentsPerPattern","channelIndex","getChannelIsNoise","andResetChannels","scale","key","loopStart","loopLength","tempo","barCount","patternsPerChannel","pattern","instrument","bar","toBase64String","bits","_latestVersion","harmonicsBits","o","spectrumBits","neededBits","shapeBits","bitsPerNoteSize","getNeededBits","maxInstrumentsPerPattern","neededInstrumentCountBits","neededInstrumentIndexBits","octaveOffset","lastPitch","recentPitches","recentShapes","curPart","shapePart","startPitch","currentPitch","pitchBends","nextPitch","shapeString","String","fromCharCode","apply","shapeIndex","unshift","pop","allPitches","pitchIndex","pitchIter","stringLength","digits","prototype","maxApplyArgs","slice","_envelopeFromLegacyIndex","legacyIndex","compressed","charIndex","JSON","parse","substring","version","_oldestVersion","beforeThree","beforeFour","beforeFive","beforeSix","beforeSeven","beforeEight","beforeNine","legacySettingsCache","command","instrumentChannelIterator","instrumentIndexIterator","channelCount","instrumentsPerChannel","instrumentIndex","instrumentsFlagBits","presetValue","legacyWaves","originalControlPointCount","sustainValue","legacyEffects","legacyEnvelopes","originalValue","byteCount","subStringLength","bitStringLength","bitStringLengthLength","newPattern","newNotes","noteCount","useOldShape","shape","pinCount","initialSize","bendCount","pinObj","intervalIter","shift","enableIntro","loopCount","enableOutro","channelArray","instrumentArray","patternArray","sequenceArray","l","channelObject","sequence","format","_format","introBars","loopBars","ticksPerBeat","beatsPerMinute","jsonObject","oldScaleNames","enigma","scaleName","letter","charAt","toUpperCase","symbol","toLowerCase","C","D","E","F","G","B","maxInstruments","maxPatterns","maxBars","newPitchChannels","newNoiseChannels","instrumentObjects","getPattern","patternIndex","getBeatsPerMinute","maxValue","clz32","PickedString","delayLine","allPassG","allPassGDelta","sustainFilterA1","sustainFilterA1Delta","sustainFilterA2","sustainFilterA2Delta","sustainFilterB0","sustainFilterB0Delta","sustainFilterB1","sustainFilterB1Delta","sustainFilterB2","sustainFilterB2Delta","delayIndex","allPassSample","allPassPrevInput","sustainFilterSample","sustainFilterPrevOutput2","sustainFilterPrevInput1","sustainFilterPrevInput2","fractionalDelaySample","prevDelayLength","delayResetOffset","update","synth","instrumentState","tone","stringIndex","roundedSamplesPerTick","stringDecayStart","stringDecayEnd","sustainType","allPassCenter","samplesPerSecond","phaseDeltaStart","phaseDeltas","phaseDeltaScale","phaseDeltaScales","phaseDeltaEnd","radiansPerSampleStart","radiansPerSampleEnd","centerHarmonicStart","centerHarmonicEnd","allPassRadiansStart","allPassRadiansEnd","shelfRadians","decayCurveStart","decayCurveEnd","register","registerShelfCenter","registerLowpassCenter","decayRateStart","decayRateEnd","expressionDecayStart","expressionDecayEnd","tempFilterStartCoefficients","tempFrequencyResponse","allPassGStart","allPassPhaseDelayStart","tempFilterEndCoefficients","allPassGEnd","allPassPhaseDelayEnd","brightnessType","shelfGainStart","shelfGainEnd","cornerHardness","lowpass1stOrderCutoffRadiansStart","lowpass1stOrderCutoffRadiansEnd","lowpass2ndOrderCutoffRadiansStart","lowpass2ndOrderCutoffRadiansEnd","lowpass2ndOrderGainStart","lowpass2ndOrderGainEnd","sustainFilterA1Start","sustainFilterA2Start","sustainFilterB0Start","sustainFilterB1Start","sustainFilterB2Start","sustainFilterPhaseDelayStart","sustainFilterA1End","sustainFilterA2End","sustainFilterB0End","sustainFilterB1End","sustainFilterB2End","sustainFilterPhaseDelayEnd","periodLengthStart","periodLengthEnd","minBufferLength","delayLength","delayLengthEnd","delayLengthDelta","pitchChanged","abs","reinitializeImpulse","likelyMaximumLength","newDelayLine","oldDelayBufferMask","startCopyingFromIndex","delayBufferMask","startImpulseFrom","startZerosFrom","stopZerosAt","impulseWave","impulseWaveLength","impulsePhaseDelta","fadeDuration","startImpulseFromSample","stopImpulseAt","stopImpulseAtSample","impulsePhase","prevWaveIntegral","impulsePhaseInt","nextWaveIntegral","phaseRatio","sample","combinedFade","curvedFade","EnvelopeComputer","noteSecondsStart","noteSecondsEnd","noteTicksStart","noteTicksEnd","noteSizeStart","noteSizeEnd","prevNoteSize","nextNoteSize","_noteSizeFinal","prevNoteSecondsStart","prevNoteSecondsEnd","prevNoteTicksStart","prevNoteTicksEnd","_prevNoteSizeFinal","prevSlideStart","prevSlideEnd","nextSlideStart","nextSlideEnd","prevSlideRatioStart","prevSlideRatioEnd","nextSlideRatioStart","nextSlideRatioEnd","envelopeStarts","envelopeEnds","_modifiedEnvelopeIndices","_modifiedEnvelopeCount","lowpassCutoffDecayVolumeCompensation","computeEnvelopes","currentPart","tickTimeStart","secondsPerTick","atNoteStart","forceContinueAtStart","tickTimeEnd","beatsPerTick","beatTimeStart","beatTimeEnd","passedEndOfNote","startPin","endPin","startPinTick","endPinTick","ratioStart","ratioEnd","noteStartTick","noteStartPart","noteEndTick","noteEndPart","maximumSlideTicks","prevNote","nextNote","forceContinueAtEnd","usedNoteSize","targetIndex","envelopeStart","computeEnvelope","envelopeEnd","filterSettings","getLowpassCutoffDecayVolumeCompensation","clearEnvelopes","beats","noteSize","noteSizeToVolumeMult","attack","Tone","fill","chordSize","drumsetPitch","prevNotePitchIndex","nextNotePitchIndex","freshlyAllocated","isOnLastTick","ticksSinceReleased","liveInputSamplesHeld","lastInterval","noiseSample","phases","expressionDelta","operatorExpressions","operatorExpressionDeltas","prevPitchExpressions","prevVibrato","prevStringDecay","pulseWidthDelta","supersawDynamismDelta","supersawUnisonDetunes","supersawShapeDelta","supersawDelayLength","supersawDelayLengthDelta","supersawDelayLine","supersawDelayIndex","supersawPrevPhaseDelta","pickedStrings","noteFilters","noteFilterCount","initialNoteFilterInput1","initialNoteFilterInput2","specialIntervalExpressionMult","feedbackOutputs","feedbackMult","feedbackDelta","envelopeComputer","pickedString","InstrumentState","awake","computed","tonesAddedInThisTick","flushingDelayLines","deactivateAfterThisTick","attentuationProgress","flushedSamples","activeTones","releasedTones","liveInputTones","synthesizer","noisePitchFilterMult","eqFilterVolume","eqFilterVolumeDelta","mixVolume","mixVolumeDelta","delayInputMult","delayInputMultDelta","distortionDelta","distortionDrive","distortionDriveDelta","distortionFractionalInput1","distortionFractionalInput2","distortionFractionalInput3","distortionPrevInput","distortionNextOutput","bitcrusherPrevInput","bitcrusherCurrentOutput","bitcrusherPhase","bitcrusherPhaseDelta","bitcrusherPhaseDeltaScale","bitcrusherScale","bitcrusherScaleScale","bitcrusherFoldLevel","bitcrusherFoldLevelScale","eqFilters","eqFilterCount","initialEqFilterInput1","initialEqFilterInput2","panningDelayLine","panningDelayPos","panningVolumeL","panningVolumeR","panningVolumeDeltaL","panningVolumeDeltaR","panningOffsetL","panningOffsetR","panningOffsetDeltaL","panningOffsetDeltaR","chorusDelayLineL","chorusDelayLineR","chorusDelayLineDirty","chorusDelayPos","chorusPhase","chorusVoiceMult","chorusVoiceMultDelta","chorusCombinedMult","chorusCombinedMultDelta","echoDelayLineL","echoDelayLineR","echoDelayLineDirty","echoDelayPos","echoDelayOffsetStart","echoDelayOffsetEnd","echoDelayOffsetRatio","echoDelayOffsetRatioDelta","echoMult","echoMultDelta","echoShelfA1","echoShelfB0","echoShelfB1","echoShelfSampleL","echoShelfSampleR","echoShelfPrevInputL","echoShelfPrevInputR","reverbDelayLine","reverbDelayLineDirty","reverbDelayPos","reverbMult","reverbMultDelta","reverbShelfA1","reverbShelfB0","reverbShelfB1","reverbShelfSample0","reverbShelfSample1","reverbShelfSample2","reverbShelfSample3","reverbShelfPrevInput0","reverbShelfPrevInput1","reverbShelfPrevInput2","reverbShelfPrevInput3","allocateNecessaryBuffers","samplesPerTick","panningDelayBufferSize","chorusDelayBufferSize","safeEchoDelaySteps","safeEchoDelayBufferSize","newDelayLineL","newDelayLineR","oldMask","deactivate","resetAllEffects","compute","getInstrumentSynthFunction","updateWaves","usesDistortion","usesBitcrusher","usesPanning","usesChorus","usesEcho","usesReverb","distortionSliderStart","distortionSliderEnd","distortionStart","distortionEnd","distortionDriveStart","distortionDriveEnd","freqSettingStart","freqSettingEnd","quantizationSettingStart","quantizationSettingEnd","freqStart","freqEnd","scaleStart","scaleEnd","foldLevelStart","foldLevelEnd","eqFilterSettings","mainInstrumentVolume","instrumentVolumeToVolumeMult","mixVolumeEnd","eqFilterVolumeStart","eqFilterVolumeEnd","delayInputMultStart","delayInputMultEnd","panStart","panEnd","volumeStartL","volumeStartR","volumeEndL","volumeEndR","maxDelaySamples","delayStart","delayEnd","delayStartL","delayStartR","delayEndL","delayEndR","chorusStart","chorusEnd","chorusCombinedMultStart","chorusCombinedMultEnd","maxEchoMult","averageEchoDelaySeconds","echoMultStart","echoMultEnd","echoDelayOffset","maxReverbMult","reverbStart","reverbEnd","totalDelaySamples","attenuationThreshold","halfLifeMult","delayDuration","attenuationPerSecond","averageMult","averageReverbDelaySeconds","progressInTick","progressAtEndOfTick","_drumsetIndexToSpectrumOctave","getDrumsetWave","drumsetIndexReferenceDelta","ChannelState","singleSeamlessInstrument","syncSongState","channelState","warmUpSynthesizer","getSamplesPerTick","operatorAmplitudeCurve","playing","isPlayingSong","recording","isRecording","playhead","playheadInternal","remainder","beat","tickSampleCountdown","isAtStartOfTick","prevBar","getSamplesPerBar","getTicksIntoBar","getCurrentPart","getTotalBars","loopRepeatCount","preferLowerLatency","anticipatePoorPerformance","liveInputDuration","liveInputStarted","liveInputPitches","liveInputChannel","liveInputInstruments","enableMetronome","countInMetronome","nextBar","liveInputEndTime","browserAutomaticallyClearsAudioBuffer","tempDrumSetControlPoint","tonePool","tempMatchedPitchTones","startedMetronome","metronomeSamplesRemaining","metronomeAmplitude","metronomePrevAmplitude","metronomeFilter","limit","tempMonoInstrumentSampleBuffer","audioCtx","scriptNode","audioProcessCallback","audioProcessingEvent","outputBuffer","outputDataL","getChannelData","outputDataR","performance","now","deactivateAudio","synthesize","computeDelayBufferSizes","setSong","panningDelayBufferMask","chorusDelayBufferMask","activateAudio","bufferSize","latencyHint","window","AudioContext","webkitAudioContext","createScriptProcessor","createJavaScriptNode","onaudioprocess","channelCountMode","channelInterpretation","connect","destination","resume","disconnect","close","maintainLiveInput","play","pause","startRecording","snapToStart","snapToBar","goToBar","resetEffects","freeAllTones","jumpIntoLoop","oldBar","goToNextBar","goToPrevBar","getNextBar","outputBufferLength","playSong","ended","limitDecay","limitRise","bufferIndex","samplesLeftInBuffer","samplesLeftInTick","runLength","runEnd","determineCurrentActiveTones","determineLiveInputTones","tonesPlayedInThisInstrument","freeReleasedTone","shouldFadeOutFast","computeTone","playTone","effectsSynth","midBeat","periods","samplesPerPeriod","tempAmplitude","sampleL","sampleR","limitedVolume","Number","isFinite","freeTone","newTone","releaseTone","toneIndex","toneList","toneCount","moveTonesIntoOrderedTempMatchedList","clearTempMatchedPitchTones","adjacentPatternHasCompatibleInstrumentTransition","otherPattern","otherNote","forceContinue","otherInstrument","otherTransition","adjacentNotesHaveMatchingPitches","firstNote","secondNote","firstNoteInterval","notePitches","currentTick","newInstrumentIndex","sourceInstrumentState","destInstrumentState","prevNoteForThisInstrument","nextNoteForThisInstrument","partsPerBar","tonesInPrevNote","tonesInNextNote","prevPattern","lastNote","patternForcesContinueAtStart","chordOfCompatibleInstrument","nextPattern","nextPatternForcesContinueAtStart","oldTone","strumOffsetParts","prevNoteForThisTone","noteForThisTone","nextNoteForThisTone","computeChordExpression","released","chordExpression","intervalScale","secondsPerPart","sampleTime","beatsPerPart","ticksIntoBar","partTimeStart","partTimeEnd","specialIntervalMult","toneIsOnLastTick","intervalStart","intervalEnd","fadeExpressionStart","fadeExpressionEnd","chordExpressionStart","chordExpressionEnd","expressionReferencePitch","baseExpression","pitchDamping","startTicksSinceReleased","endTicksSinceReleased","pinStart","pinEnd","noteTicksPassedTickStart","noteTicksPassedTickEnd","pinRatioStart","pinRatioEnd","noteLengthTicks","intervalDiff","chordSizeDiff","vibratoAmplitude","vibratoStart","getLFOAmplitude","ticksUntilVibratoStart","vibratoEnd","ticksUntilVibratoEnd","noteFilterExpression","noteFilterSettings","noteAllFreqsEnvelopeStart","noteAllFreqsEnvelopeEnd","noteFreqEnvelopeStart","noteFreqEnvelopeEnd","notePeakEnvelopeStart","notePeakEnvelopeEnd","drumsetFilterEnvelope","drumsetFilterEnvelopeStart","drumsetFilterEnvelopeEnd","sineExpressionBoost","totalCarrierExpression","arpeggioInterval","associatedCarrierIndex","pitchStart","pitchEnd","baseFreqStart","baseFreqEnd","targetFreqStart","targetFreqEnd","freqEnvelopeStart","freqEnvelopeEnd","amplitudeCurve","amplitudeMult","expressionStart","expressionEnd","pitchExpressionStart","pitchExpressionEnd","feedbackStart","feedbackEnd","freqEndRatio","basePhaseDeltaScale","intervalOffset","endPitch","settingsExpressionMult","basePulseWidth","pulseWidthStart","pulseWidthEnd","startFreq","voiceCountExpression","unisonEnvelopeStart","unisonEnvelopeEnd","unisonAStart","unisonAEnd","unisonBStart","unisonBEnd","supersawExpressionStart","supersawExpressionEnd","minFirstVoiceAmplitude","baseDynamismSlider","curvedDynamismStart","curvedDynamismEnd","firstVoiceAmplitudeStart","firstVoiceAmplitudeEnd","dynamismStart","dynamismEnd","initializeSupersaw","accumulator","normalizedPhase","zeroCrossingPhase","prevDrop","nextDrop","phaseDelta","distanceToZeroCrossing","swappedIndex","baseSpreadSlider","averageSpreadSlider","curvedSpread","baseShape","shapeStart","shapeEnd","delayLengthStart","pulseExpressionRatio","sustainEnvelopeStart","sustainEnvelopeEnd","secondsIntoBar","vibratoPeriodSeconds","fingerprint","fmSynthFunctionCache","synthSource","line","fmSourceTemplate","outputs","replace","join","operatorLine","operatorSourceTemplate","modulators","modulatorNumber","feedbackIndices","wrappedFmSynth","Function","chipSynth","harmonicsSynth","pulseWidthSynth","supersawSynth","pickedStringSynth","noiseSynth","spectrumSynth","drumsetSynth","data","unisonSign","phaseDeltaA","phaseDeltaB","phaseDeltaScaleA","phaseDeltaScaleB","phaseA","phaseB","filters","filterCount","initialFilterInput1","initialFilterInput2","applyFilters","phaseAInt","phaseBInt","indexA","indexB","phaseRatioA","phaseRatioB","prevWaveIntegralA","prevWaveIntegralB","sampleIndex","nextWaveIntegralA","nextWaveIntegralB","waveA","waveB","inputSample","output","sanitizeFilters","voiceCount","pickedStringFunction","pickedStringFunctionCache","pickedStringSource","sampleList","voice","lines","usesEqFilter","signature","effectsFunction","effectsFunctionCache","effectsSource","usesDelays","phase","sawPhaseA","sawPhaseB","pulseWave","t","dynamism","dynamismDelta","unisonDetunes","shapeDelta","supersawSample","detunedPhaseDelta","delaySampleTime","lowerIndex","upperIndex","delayRatio","prevDelaySample","phaseMask","pitchRelativefilter","findRandomZeroCrossing","phaseInt","waveSample","referenceDelta","indexPrev","wavePrev","attemptsRemaining","indexNext","waveNext","innerIndexNext","innerWaveNext","instrumentVolume","volumeMultToInstrumentVolume","volumeMult","volumeMultToNoteSize","setting","seconds","ticks","lower","upper","cents","beatsPerSecond","partsPerSecond","tickPerSecond","sanitizeDelayLine","lastIndex","mask","input1","input2","split"],"sources":["../synth/SynthConfig.ts","../synth/FFT.ts","../synth/Deque.ts","../synth/filtering.ts","../synth/synth.ts"],"sourcesContent":["/*!\r\nCopyright (c) 2012-2022 John Nesky and contributing authors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of \r\nthis software and associated documentation files (the \"Software\"), to deal in \r\nthe Software without restriction, including without limitation the rights to \r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \r\nof the Software, and to permit persons to whom the Software is furnished to do \r\nso, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all \r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \r\nSOFTWARE.\r\n*/\r\n\r\nexport interface Dictionary<T> {\r\n\t[K: string]: T;\r\n}\r\n\r\nexport interface DictionaryArray<T> extends ReadonlyArray<T> {\r\n\tdictionary: Dictionary<T>;\r\n}\r\n\r\nexport const enum FilterType {\r\n\tlowPass,\r\n\thighPass,\r\n\tpeak,\r\n\tlength,\r\n}\r\n\r\nexport const enum SustainType {\r\n\tbright,\r\n\tacoustic,\r\n\tlength,\r\n}\r\n\r\nexport const enum EnvelopeType {\r\n\tnoteSize,\r\n\tnone,\r\n\tpunch,\r\n\tflare,\r\n\ttwang,\r\n\tswell,\r\n\ttremolo,\r\n\ttremolo2,\r\n\tdecay,\r\n}\r\n\r\nexport const enum InstrumentType {\r\n\tchip,\r\n\tfm,\r\n\tnoise,\r\n\tspectrum,\r\n\tdrumset,\r\n\tharmonics,\r\n\tpwm,\r\n\tpickedString,\r\n\tsupersaw,\r\n\tlength,\r\n}\r\n\r\nexport const enum EffectType {\r\n\treverb,\r\n\tchorus,\r\n\tpanning,\r\n\tdistortion,\r\n\tbitcrusher,\r\n\tnoteFilter,\r\n\techo,\r\n\tpitchShift,\r\n\tdetune,\r\n\tvibrato,\r\n\ttransition,\r\n\tchord,\r\n\t// If you add more, you'll also have to extend the bitfield used in Base64 which currently uses two six-bit characters.\r\n\tlength,\r\n}\r\n\r\nexport const enum EnvelopeComputeIndex {\r\n\tnoteVolume,\r\n\tnoteFilterAllFreqs,\r\n\tpulseWidth,\r\n\tstringSustain,\r\n\tunison,\r\n\toperatorFrequency0, operatorFrequency1, operatorFrequency2, operatorFrequency3,\r\n\toperatorAmplitude0, operatorAmplitude1, operatorAmplitude2, operatorAmplitude3,\r\n\tfeedbackAmplitude,\r\n\tpitchShift,\r\n\tdetune,\r\n\tvibratoDepth,\r\n\tnoteFilterFreq0, noteFilterFreq1, noteFilterFreq2, noteFilterFreq3, noteFilterFreq4, noteFilterFreq5, noteFilterFreq6, noteFilterFreq7,\r\n\tnoteFilterGain0, noteFilterGain1, noteFilterGain2, noteFilterGain3, noteFilterGain4, noteFilterGain5, noteFilterGain6, noteFilterGain7,\r\n\tsupersawDynamism,\r\n\tsupersawSpread,\r\n\tsupersawShape,\r\n\tlength,\r\n}\r\n\r\n/*\r\nexport const enum InstrumentAutomationIndex {\r\n\tmixVolume,\r\n\teqFilterAllFreqs,\r\n\teqFilterFreq0, eqFilterFreq1, eqFilterFreq2, eqFilterFreq3, eqFilterFreq4, eqFilterFreq5, eqFilterFreq6, eqFilterFreq7,\r\n\teqFilterGain0, eqFilterGain1, eqFilterGain2, eqFilterGain3, eqFilterGain4, eqFilterGain5, eqFilterGain6, eqFilterGain7,\r\n\tdistortion,\r\n\tbitcrusherQuantization,\r\n\tbitcrusherFrequency,\r\n\tpanning,\r\n\tchorus,\r\n\techoSustain,\r\n\t//echoDelay, // Wait until tick settings can be computed once for multiple run lengths.\r\n\treverb,\r\n\tlength,\r\n}\r\n*/\r\n\r\nexport interface BeepBoxOption {\r\n\treadonly index: number;\r\n\treadonly name: string;\r\n}\r\n\r\nexport interface Scale extends BeepBoxOption {\r\n\treadonly flags: ReadonlyArray<boolean>;\r\n\treadonly realName: string;\r\n}\r\n\r\nexport interface Key extends BeepBoxOption {\r\n\treadonly isWhiteKey: boolean;\r\n\treadonly basePitch: number;\r\n}\r\n\r\nexport interface Rhythm extends BeepBoxOption {\r\n\treadonly stepsPerBeat: number;\r\n\treadonly ticksPerArpeggio: number;\r\n\treadonly arpeggioPatterns: ReadonlyArray<ReadonlyArray<number>>;\r\n\treadonly roundUpThresholds: number[] | null;\r\n}\r\n\r\nexport interface ChipWave extends BeepBoxOption {\r\n\treadonly expression: number;\r\n\treadonly samples: Float32Array;\r\n}\r\n\r\nexport interface ChipNoise extends BeepBoxOption {\r\n\treadonly expression: number;\r\n\treadonly basePitch: number;\r\n\treadonly pitchFilterMult: number;\r\n\treadonly isSoft: boolean;\r\n\tsamples: Float32Array | null;\r\n}\r\n\r\nexport interface Transition extends BeepBoxOption {\r\n\treadonly isSeamless: boolean;\r\n\treadonly continues: boolean;\r\n\treadonly slides: boolean;\r\n\treadonly slideTicks: number;\r\n\treadonly includeAdjacentPatterns: boolean;\r\n}\r\n\r\nexport interface Vibrato extends BeepBoxOption {\r\n\treadonly amplitude: number;\r\n\treadonly periodsSeconds: ReadonlyArray<number>;\r\n\treadonly delayTicks: number;\r\n}\r\n\r\nexport interface Unison extends BeepBoxOption {\r\n\treadonly voices: number;\r\n\treadonly spread: number;\r\n\treadonly offset: number;\r\n\treadonly expression: number;\r\n\treadonly sign: number;\r\n}\r\n\r\nexport interface Chord extends BeepBoxOption {\r\n\treadonly customInterval: boolean;\r\n\treadonly arpeggiates: boolean;\r\n\treadonly strumParts: number;\r\n\treadonly singleTone: boolean;\r\n}\r\n\r\nexport interface Algorithm extends BeepBoxOption {\r\n\treadonly carrierCount: number;\r\n\treadonly associatedCarrier: ReadonlyArray<number>;\r\n\treadonly modulatedBy: ReadonlyArray<ReadonlyArray<number>>;\r\n}\r\n\r\nexport interface OperatorFrequency extends BeepBoxOption {\r\n\treadonly mult: number;\r\n\treadonly hzOffset: number;\r\n\treadonly amplitudeSign: number;\r\n}\r\n\r\nexport interface Feedback extends BeepBoxOption {\r\n\treadonly indices: ReadonlyArray<ReadonlyArray<number>>;\r\n}\r\n\r\nexport interface Envelope extends BeepBoxOption {\r\n\treadonly type: EnvelopeType;\r\n\treadonly speed: number;\r\n}\r\n\r\nexport interface AutomationTarget extends BeepBoxOption {\r\n\treadonly computeIndex: EnvelopeComputeIndex /*| InstrumentAutomationIndex*/ | null;\r\n\treadonly displayName: string;\r\n\t//readonly perNote: boolean; // Whether to compute envelopes on a per-note basis.\r\n\treadonly interleave: boolean; // Whether to interleave this target with the next one in the menu (e.g. filter frequency and gain).\r\n\treadonly isFilter: boolean; // Filters are special because the maxCount depends on other instrument settings.\r\n\t//readonly range: number | null; // set if automation is allowed.\r\n\treadonly maxCount: number;\r\n\treadonly effect: EffectType | null;\r\n\treadonly compatibleInstruments: InstrumentType[] | null;\r\n}\r\n\r\nexport class Config {\r\n\tpublic static readonly scales: DictionaryArray<Scale> = toNameMap([\r\n\t\t{name: \"easy :)\",            realName: \"pentatonic major\",      flags: [true, false,  true, false,  true, false, false,  true, false,  true, false, false]},\r\n\t\t{name: \"easy :(\",            realName: \"pentatonic minor\",      flags: [true, false, false,  true, false,  true, false,  true, false, false,  true, false]},\r\n\t\t{name: \"island :)\",          realName: \"ryukyu\",                flags: [true, false, false, false,  true,  true, false,  true, false, false, false,  true]},\r\n\t\t{name: \"island :(\",          realName: \"pelog selisir\",         flags: [true,  true, false,  true, false, false, false,  true,  true, false, false, false]},\r\n\t\t{name: \"blues :)\",           realName: \"blues major\",           flags: [true, false,  true,  true,  true, false, false,  true, false,  true, false, false]},\r\n\t\t{name: \"blues :(\",           realName: \"blues\",                 flags: [true, false, false,  true, false,  true,  true,  true, false, false,  true, false]},\r\n\t\t{name: \"normal :)\",          realName: \"ionian\",                flags: [true, false,  true, false,  true,  true, false,  true, false,  true, false,  true]},\r\n\t\t{name: \"normal :(\",          realName: \"aeolian\",               flags: [true, false,  true,  true, false,  true, false,  true,  true, false,  true, false]},\r\n\t\t{name: \"double harmonic :)\", realName: \"double harmonic major\", flags: [true,  true, false, false,  true,  true, false,  true,  true, false, false,  true]},\r\n\t\t{name: \"double harmonic :(\", realName: \"double harmonic minor\", flags: [true, false,  true,  true, false, false,  true,  true,  true, false, false,  true]},\r\n\t\t{name: \"strange\",            realName: \"whole tone\",            flags: [true, false,  true, false,  true, false,  true, false,  true, false,  true, false]},\r\n\t\t{name: \"expert\",             realName: \"chromatic\",             flags: [true,  true,  true,  true,  true,  true,  true,  true,  true,  true,  true,  true]},\r\n\t]);\r\n\tpublic static readonly keys: DictionaryArray<Key> = toNameMap([\r\n\t\t{name: \"C\",  isWhiteKey:  true, basePitch: 12}, // C0 has index 12 on the MIDI scale. C7 is 96, and C9 is 120. C10 is barely in the audible range.\r\n\t\t{name: \"C♯\", isWhiteKey: false, basePitch: 13},\r\n\t\t{name: \"D\",  isWhiteKey:  true, basePitch: 14},\r\n\t\t{name: \"D♯\", isWhiteKey: false, basePitch: 15},\r\n\t\t{name: \"E\",  isWhiteKey:  true, basePitch: 16},\r\n\t\t{name: \"F\",  isWhiteKey:  true, basePitch: 17},\r\n\t\t{name: \"F♯\", isWhiteKey: false, basePitch: 18},\r\n\t\t{name: \"G\",  isWhiteKey:  true, basePitch: 19},\r\n\t\t{name: \"G♯\", isWhiteKey: false, basePitch: 20},\r\n\t\t{name: \"A\",  isWhiteKey:  true, basePitch: 21},\r\n\t\t{name: \"A♯\", isWhiteKey: false, basePitch: 22},\r\n\t\t{name: \"B\",  isWhiteKey:  true, basePitch: 23},\r\n\t]);\r\n\tpublic static readonly blackKeyNameParents: ReadonlyArray<number> = [-1, 1, -1, 1, -1, 1, -1, -1, 1, -1, 1, -1];\r\n\tpublic static readonly tempoMin: number = 30;\r\n\tpublic static readonly tempoMax: number = 300;\r\n\tpublic static readonly echoDelayRange: number = 24;\r\n\tpublic static readonly echoDelayStepTicks: number = 4;\r\n\tpublic static readonly echoSustainRange: number = 8;\r\n\tpublic static readonly echoShelfHz: number = 4000.0; // The cutoff freq of the shelf filter that is used to decay echoes.\r\n\tpublic static readonly echoShelfGain: number = Math.pow(2.0, -0.5);\r\n\tpublic static readonly reverbShelfHz: number = 8000.0; // The cutoff freq of the shelf filter that is used to decay reverb.\r\n\tpublic static readonly reverbShelfGain: number = Math.pow(2.0, -1.5);\r\n\tpublic static readonly reverbRange: number = 4;\r\n\tpublic static readonly reverbDelayBufferSize: number = 16384; // TODO: Compute a buffer size based on sample rate.\r\n\tpublic static readonly reverbDelayBufferMask: number = Config.reverbDelayBufferSize - 1; // TODO: Compute a buffer size based on sample rate.\r\n\tpublic static readonly beatsPerBarMin: number = 3;\r\n\tpublic static readonly beatsPerBarMax: number = 16;\r\n\tpublic static readonly barCountMin: number = 1;\r\n\tpublic static readonly barCountMax: number = 128;\r\n\tpublic static readonly instrumentCountMin: number = 1;\r\n\tpublic static readonly layeredInstrumentCountMax: number = 4;\r\n\tpublic static readonly patternInstrumentCountMax: number = 10;\r\n\tpublic static readonly partsPerBeat: number = 24;\r\n\tpublic static readonly ticksPerPart: number = 2;\r\n\tpublic static readonly rhythms: DictionaryArray<Rhythm> = toNameMap([\r\n\t\t{name: \"÷3 (triplets)\", stepsPerBeat: 3, ticksPerArpeggio: 4, arpeggioPatterns: [[0], [0, 0, 1, 1], [0, 1, 2, 1]], roundUpThresholds: [/*0*/ 5, /*8*/ 12, /*16*/ 18 /*24*/]},\r\n\t\t{name: \"÷4 (standard)\", stepsPerBeat: 4, ticksPerArpeggio: 3, arpeggioPatterns: [[0], [0, 0, 1, 1], [0, 1, 2, 1]], roundUpThresholds: [/*0*/ 3, /*6*/ 9, /*12*/ 17, /*18*/ 21 /*24*/]},\r\n\t\t{name: \"÷6\",            stepsPerBeat: 6, ticksPerArpeggio: 4, arpeggioPatterns: [[0], [0, 1],       [0, 1, 2, 1]], roundUpThresholds: null},\r\n\t\t{name: \"÷8\",            stepsPerBeat: 8, ticksPerArpeggio: 3, arpeggioPatterns: [[0], [0, 1],       [0, 1, 2, 1]], roundUpThresholds: null},\r\n\t\t{name: \"freehand\",      stepsPerBeat:24, ticksPerArpeggio: 3, arpeggioPatterns: [[0], [0, 1],       [0, 1, 2, 1]], roundUpThresholds: null},\r\n\t]);\r\n\t\r\n\tpublic static readonly instrumentTypeNames: ReadonlyArray<string> = [\"chip\", \"FM\", \"noise\", \"spectrum\", \"drumset\", \"harmonics\", \"PWM\", \"Picked String\", \"supersaw\"]; // See InstrumentType enum above.\r\n\tpublic static readonly instrumentTypeHasSpecialInterval: ReadonlyArray<boolean> = [true, true, false, false, false, true, false, false, false];\r\n\tpublic static readonly chipBaseExpression:      number = 0.03375; // Doubled by unison feature, but affected by expression adjustments per unison setting and wave shape.\r\n\tpublic static readonly fmBaseExpression:        number = 0.03;\r\n\tpublic static readonly noiseBaseExpression:     number = 0.19;\r\n\tpublic static readonly spectrumBaseExpression:  number = 0.3; // Spectrum can be in pitch or noise channels, the expression is doubled for noise.\r\n\tpublic static readonly drumsetBaseExpression:   number = 0.45; // Drums tend to be loud but brief!\r\n\tpublic static readonly harmonicsBaseExpression: number = 0.025;\r\n\tpublic static readonly pwmBaseExpression:       number = 0.04725; // It's actually closer to half of this, the synthesized pulse amplitude range is only .5 to -.5, but also note that the fundamental sine partial amplitude of a square wave is 4/π times the measured square wave amplitude.\r\n\tpublic static readonly supersawBaseExpression:  number = 0.061425; // It's actually closer to half of this, the synthesized sawtooth amplitude range is only .5 to -.5.\r\n\tpublic static readonly pickedStringBaseExpression: number = 0.025; // Same as harmonics.\r\n\tpublic static readonly distortionBaseVolume:    number = 0.011; // Distortion is not affected by pitchDamping, which otherwise approximately halves expression for notes around the middle of the range.\r\n\tpublic static readonly bitcrusherBaseVolume:    number = 0.010; // Also not affected by pitchDamping, used when bit crushing is maxed out (aka \"1-bit\" output).\r\n\t\r\n\tpublic static readonly chipWaves: DictionaryArray<ChipWave> = toNameMap([\r\n\t\t{name: \"rounded\",      expression: 0.94, samples: centerWave([0.0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.95, 0.9, 0.85, 0.8, 0.7, 0.6, 0.5, 0.4, 0.2, 0.0, -0.2, -0.4, -0.5, -0.6, -0.7, -0.8, -0.85, -0.9, -0.95, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.7, -0.6, -0.5, -0.4, -0.2])},\r\n\t\t{name: \"triangle\",     expression: 1.0,  samples: centerWave([1.0/15.0, 3.0/15.0, 5.0/15.0, 7.0/15.0, 9.0/15.0, 11.0/15.0, 13.0/15.0, 15.0/15.0, 15.0/15.0, 13.0/15.0, 11.0/15.0, 9.0/15.0, 7.0/15.0, 5.0/15.0, 3.0/15.0, 1.0/15.0, -1.0/15.0, -3.0/15.0, -5.0/15.0, -7.0/15.0, -9.0/15.0, -11.0/15.0, -13.0/15.0, -15.0/15.0, -15.0/15.0, -13.0/15.0, -11.0/15.0, -9.0/15.0, -7.0/15.0, -5.0/15.0, -3.0/15.0, -1.0/15.0])},\r\n\t\t{name: \"square\",       expression: 0.5,  samples: centerWave([1.0, -1.0])},\r\n\t\t{name: \"1/4 pulse\",    expression: 0.5,  samples: centerWave([1.0, -1.0, -1.0, -1.0])},\r\n\t\t{name: \"1/8 pulse\",    expression: 0.5,  samples: centerWave([1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0])},\r\n\t\t{name: \"sawtooth\",     expression: 0.65, samples: centerWave([1.0/31.0, 3.0/31.0, 5.0/31.0, 7.0/31.0, 9.0/31.0, 11.0/31.0, 13.0/31.0, 15.0/31.0, 17.0/31.0, 19.0/31.0, 21.0/31.0, 23.0/31.0, 25.0/31.0, 27.0/31.0, 29.0/31.0, 31.0/31.0, -31.0/31.0, -29.0/31.0, -27.0/31.0, -25.0/31.0, -23.0/31.0, -21.0/31.0, -19.0/31.0, -17.0/31.0, -15.0/31.0, -13.0/31.0, -11.0/31.0, -9.0/31.0, -7.0/31.0, -5.0/31.0, -3.0/31.0, -1.0/31.0])},\r\n\t\t{name: \"double saw\",   expression: 0.5,  samples: centerWave([0.0, -0.2, -0.4, -0.6, -0.8, -1.0, 1.0, -0.8, -0.6, -0.4, -0.2, 1.0, 0.8, 0.6, 0.4, 0.2])},\r\n\t\t{name: \"double pulse\", expression: 0.4,  samples: centerWave([1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0])},\r\n\t\t{name: \"spiky\",        expression: 0.4,  samples: centerWave([1.0, -1.0, 1.0, -1.0, 1.0, 0.0])},\r\n\t]);\r\n\t// Noise waves have too many samples to write by hand, they're generated on-demand by getDrumWave instead.\r\n\tpublic static readonly chipNoises: DictionaryArray<ChipNoise> = toNameMap([\r\n\t\t{name: \"retro\",   expression: 0.25, basePitch: 69,  pitchFilterMult: 1024.0, isSoft: false, samples: null},\r\n\t\t{name: \"white\",   expression: 1.0,  basePitch: 69,  pitchFilterMult:    8.0, isSoft: true,  samples: null},\r\n\t\t// The \"clang\" and \"buzz\" noises are based on similar noises in the modded beepbox! :D\r\n\t\t{name: \"clang\",   expression: 0.4,  basePitch: 69,  pitchFilterMult: 1024.0, isSoft: false, samples: null},\r\n\t\t{name: \"buzz\",    expression: 0.3,  basePitch: 69,  pitchFilterMult: 1024.0, isSoft: false, samples: null},\r\n\t\t{name: \"hollow\",  expression: 1.5,  basePitch: 96,  pitchFilterMult:    1.0, isSoft: true,  samples: null},\r\n\t]);\r\n\t\r\n\tpublic static readonly filterFreqStep: number = 1.0/4.0;\r\n\tpublic static readonly filterFreqRange: number = 34;\r\n\tpublic static readonly filterFreqReferenceSetting: number = 28;\r\n\tpublic static readonly filterFreqReferenceHz: number = 8000.0;\r\n\tpublic static readonly filterFreqMaxHz: number = Config.filterFreqReferenceHz * Math.pow(2.0, Config.filterFreqStep * (Config.filterFreqRange - 1 - Config.filterFreqReferenceSetting)); // ~19khz\r\n\tpublic static readonly filterFreqMinHz: number = 8.0;\r\n\tpublic static readonly filterGainRange: number = 15;\r\n\tpublic static readonly filterGainCenter: number = 7;\r\n\tpublic static readonly filterGainStep: number = 1.0/2.0;\r\n\tpublic static readonly filterMaxPoints: number = 8;\r\n\tpublic static readonly filterTypeNames: ReadonlyArray<string> = [\"low-pass\", \"high-pass\", \"peak\"]; // See FilterType enum above.\r\n\t\r\n\tpublic static readonly fadeInRange: number = 10;\r\n\tpublic static readonly fadeOutTicks: ReadonlyArray<number> = [-24, -12, -6, -3, -1, 6, 12, 24, 48, 72, 96];\r\n\tpublic static readonly fadeOutNeutral: number = 4;\r\n\tpublic static readonly drumsetFadeOutTicks: number = 48;\r\n\tpublic static readonly transitions: DictionaryArray<Transition> = toNameMap([\r\n\t\t{name: \"normal\",        isSeamless: false, continues: false, slides: false, slideTicks: 3, includeAdjacentPatterns: false},\r\n\t\t{name: \"interrupt\",     isSeamless: true,  continues: false, slides: false, slideTicks: 3, includeAdjacentPatterns: true},\r\n\t\t{name: \"continue\",      isSeamless: true,  continues: true,  slides: false, slideTicks: 3, includeAdjacentPatterns: true},\r\n\t\t{name: \"slide\",         isSeamless: true,  continues: false, slides: true,  slideTicks: 3, includeAdjacentPatterns: true},\r\n\t\t{name: \"slide in pattern\", isSeamless: true,  continues: false, slides: true,  slideTicks: 3, includeAdjacentPatterns: false},\r\n\t]);\r\n\tpublic static readonly vibratos: DictionaryArray<Vibrato> = toNameMap([\r\n\t\t{name: \"none\",    amplitude: 0.0,  periodsSeconds: [0.14], delayTicks: 0},\r\n\t\t{name: \"light\",   amplitude: 0.15, periodsSeconds: [0.14], delayTicks: 0},\r\n\t\t{name: \"delayed\", amplitude: 0.3,  periodsSeconds: [0.14], delayTicks: 37}, // It will fade in over the previous two ticks.\r\n\t\t{name: \"heavy\",   amplitude: 0.45, periodsSeconds: [0.14], delayTicks: 0},\r\n\t\t{name: \"shaky\",   amplitude: 0.1,  periodsSeconds: [0.11, 1.618*0.11, 3*0.11], delayTicks: 0},\r\n\t]);\r\n\tpublic static readonly unisons: DictionaryArray<Unison> = toNameMap([\r\n\t\t{name: \"none\",       voices: 1, spread: 0.0,  offset: 0.0, expression: 1.4, sign: 1.0},\r\n\t\t{name: \"shimmer\",    voices: 2, spread: 0.018,offset: 0.0, expression: 0.8, sign: 1.0},\r\n\t\t{name: \"hum\",        voices: 2, spread: 0.045,offset: 0.0, expression: 1.0, sign: 1.0},\r\n\t\t{name: \"honky tonk\", voices: 2, spread: 0.09, offset: 0.0, expression: 1.0, sign: 1.0},\r\n\t\t{name: \"dissonant\",  voices: 2, spread: 0.25, offset: 0.0, expression: 0.9, sign: 1.0},\r\n\t\t{name: \"fifth\",      voices: 2, spread: 3.5,  offset: 3.5, expression: 0.9, sign: 1.0},\r\n\t\t{name: \"octave\",     voices: 2, spread: 6.0,  offset: 6.0, expression: 0.8, sign: 1.0},\r\n\t\t{name: \"bowed\",      voices: 2, spread: 0.02, offset: 0.0, expression: 1.0, sign:-1.0},\r\n\t\t{name: \"piano\",      voices: 2, spread: 0.01, offset: 0.0, expression: 1.0, sign: 0.7},\r\n\t]);\r\n\tpublic static readonly effectNames: ReadonlyArray<string> = [\"reverb\", \"chorus\", \"panning\", \"distortion\", \"bitcrusher\", \"note filter\", \"echo\", \"pitch shift\", \"detune\", \"vibrato\", \"transition type\", \"chord type\"];\r\n\tpublic static readonly effectOrder: ReadonlyArray<EffectType> = [EffectType.transition, EffectType.chord, EffectType.pitchShift, EffectType.detune, EffectType.vibrato, EffectType.noteFilter, EffectType.distortion, EffectType.bitcrusher, EffectType.panning, EffectType.chorus, EffectType.echo, EffectType.reverb];\r\n\tpublic static readonly noteSizeMax: number = 3;\r\n\tpublic static readonly volumeRange: number = 8;\r\n\tpublic static readonly volumeLogScale: number = -0.5;\r\n\tpublic static readonly panCenter: number = 4;\r\n\tpublic static readonly panMax: number = Config.panCenter * 2;\r\n\tpublic static readonly panDelaySecondsMax: number = 0.0005;\r\n\tpublic static readonly chorusRange: number = 4;\r\n\tpublic static readonly chorusPeriodSeconds: number = 2.0;\r\n\tpublic static readonly chorusDelayRange: number = 0.0034;\r\n\tpublic static readonly chorusDelayOffsets: ReadonlyArray<ReadonlyArray<number>> = [[1.51, 2.10, 3.35], [1.47, 2.15, 3.25]];\r\n\tpublic static readonly chorusPhaseOffsets: ReadonlyArray<ReadonlyArray<number>> = [[0.0, 2.1, 4.2], [3.2, 5.3, 1.0]];\r\n\tpublic static readonly chorusMaxDelay: number = Config.chorusDelayRange * (1.0 + Config.chorusDelayOffsets[0].concat(Config.chorusDelayOffsets[1]).reduce((x,y)=>Math.max(x,y)));\r\n\tpublic static readonly chords: DictionaryArray<Chord> = toNameMap([\r\n\t\t{name: \"simultaneous\",    customInterval: false, arpeggiates: false, strumParts: 0, singleTone: false},\r\n\t\t{name: \"strum\",           customInterval: false, arpeggiates: false, strumParts: 1, singleTone: false},\r\n\t\t{name: \"arpeggio\",        customInterval: false, arpeggiates:  true, strumParts: 0, singleTone:  true},\r\n\t\t{name: \"custom interval\", customInterval:  true, arpeggiates: false, strumParts: 0, singleTone:  true},\r\n\t]);\r\n\tpublic static readonly maxChordSize: number = 4;\r\n\tpublic static readonly operatorCount: number = 4;\r\n\tpublic static readonly maxPitchOrOperatorCount: number = Math.max(Config.maxChordSize, Config.operatorCount);\r\n\tpublic static readonly algorithms: DictionaryArray<Algorithm> = toNameMap([\r\n\t\t{name: \"1←(2 3 4)\",   carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2, 3, 4], [],     [],  []]},\r\n\t\t{name: \"1←(2 3←4)\",   carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2, 3],    [],     [4], []]},\r\n\t\t{name: \"1←2←(3 4)\",   carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2],       [3, 4], [],  []]},\r\n\t\t{name: \"1←(2 3)←4\",   carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2, 3],    [4],    [4], []]},\r\n\t\t{name: \"1←2←3←4\",     carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2],       [3],    [4], []]},\r\n\t\t{name: \"1←3 2←4\",     carrierCount: 2, associatedCarrier: [1, 2, 1, 2], modulatedBy: [[3],       [4],    [],  []]},\r\n\t\t{name: \"1 2←(3 4)\",   carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[],        [3, 4], [],  []]},\r\n\t\t{name: \"1 2←3←4\",     carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[],        [3],    [4], []]},\r\n\t\t{name: \"(1 2)←3←4\",   carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[3],       [3],    [4], []]},\r\n\t\t{name: \"(1 2)←(3 4)\", carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[3, 4],    [3, 4], [],  []]},\r\n\t\t{name: \"1 2 3←4\",     carrierCount: 3, associatedCarrier: [1, 2, 3, 3], modulatedBy: [[],        [],     [4], []]},\r\n\t\t{name: \"(1 2 3)←4\",   carrierCount: 3, associatedCarrier: [1, 2, 3, 3], modulatedBy: [[4],       [4],    [4], []]},\r\n\t\t{name: \"1 2 3 4\",     carrierCount: 4, associatedCarrier: [1, 2, 3, 4], modulatedBy: [[],        [],     [],  []]},\r\n\t]);\r\n\tpublic static readonly operatorCarrierInterval: ReadonlyArray<number> = [0.0, 0.04, -0.073, 0.091];\r\n\tpublic static readonly operatorAmplitudeMax: number = 15;\r\n\tpublic static readonly operatorFrequencies: DictionaryArray<OperatorFrequency> = toNameMap([\r\n\t\t{name:  \"1×\", mult:  1.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name: \"~1×\", mult:  1.0, hzOffset: 1.5, amplitudeSign:-1.0},\r\n\t\t{name:  \"2×\", mult:  2.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name: \"~2×\", mult:  2.0, hzOffset:-1.3, amplitudeSign:-1.0},\r\n\t\t{name:  \"3×\", mult:  3.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name:  \"4×\", mult:  4.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name:  \"5×\", mult:  5.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name:  \"6×\", mult:  6.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name:  \"7×\", mult:  7.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name:  \"8×\", mult:  8.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name:  \"9×\", mult:  9.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name: \"11×\", mult: 11.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name: \"13×\", mult: 13.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name: \"16×\", mult: 16.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t\t{name: \"20×\", mult: 20.0, hzOffset: 0.0, amplitudeSign: 1.0},\r\n\t]);\r\n\tpublic static readonly envelopes: DictionaryArray<Envelope> = toNameMap([\r\n\t\t{name: \"none\",     type: EnvelopeType.none,     speed:  0.0},\r\n\t\t{name: \"note size\",type: EnvelopeType.noteSize, speed:  0.0},\r\n\t\t{name: \"punch\",    type: EnvelopeType.punch,    speed:  0.0},\r\n\t\t{name: \"flare 1\",  type: EnvelopeType.flare,    speed: 32.0},\r\n\t\t{name: \"flare 2\",  type: EnvelopeType.flare,    speed:  8.0},\r\n\t\t{name: \"flare 3\",  type: EnvelopeType.flare,    speed:  2.0},\r\n\t\t{name: \"twang 1\",  type: EnvelopeType.twang,    speed: 32.0},\r\n\t\t{name: \"twang 2\",  type: EnvelopeType.twang,    speed:  8.0},\r\n\t\t{name: \"twang 3\",  type: EnvelopeType.twang,    speed:  2.0},\r\n\t\t{name: \"swell 1\",  type: EnvelopeType.swell,    speed: 32.0},\r\n\t\t{name: \"swell 2\",  type: EnvelopeType.swell,    speed:  8.0},\r\n\t\t{name: \"swell 3\",  type: EnvelopeType.swell,    speed:  2.0},\r\n\t\t{name: \"tremolo1\", type: EnvelopeType.tremolo,  speed:  4.0},\r\n\t\t{name: \"tremolo2\", type: EnvelopeType.tremolo,  speed:  2.0},\r\n\t\t{name: \"tremolo3\", type: EnvelopeType.tremolo,  speed:  1.0},\r\n\t\t{name: \"tremolo4\", type: EnvelopeType.tremolo2, speed:  4.0},\r\n\t\t{name: \"tremolo5\", type: EnvelopeType.tremolo2, speed:  2.0},\r\n\t\t{name: \"tremolo6\", type: EnvelopeType.tremolo2, speed:  1.0},\r\n\t\t{name: \"decay 1\",  type: EnvelopeType.decay,    speed: 10.0},\r\n\t\t{name: \"decay 2\",  type: EnvelopeType.decay,    speed:  7.0},\r\n\t\t{name: \"decay 3\",  type: EnvelopeType.decay,    speed:  4.0},\r\n\t]);\r\n\tpublic static readonly feedbacks: DictionaryArray<Feedback> = toNameMap([\r\n\t\t{name: \"1⟲\",          indices: [[1],  [],  [],  []]},\r\n\t\t{name: \"2⟲\",          indices: [ [], [2],  [],  []]},\r\n\t\t{name: \"3⟲\",          indices: [ [],  [], [3],  []]},\r\n\t\t{name: \"4⟲\",          indices: [ [],  [],  [], [4]]},\r\n\t\t{name: \"1⟲ 2⟲\",       indices: [[1], [2],  [],  []]},\r\n\t\t{name: \"3⟲ 4⟲\",       indices: [ [],  [], [3], [4]]},\r\n\t\t{name: \"1⟲ 2⟲ 3⟲\",    indices: [[1], [2], [3],  []]},\r\n\t\t{name: \"2⟲ 3⟲ 4⟲\",    indices: [ [], [2], [3], [4]]},\r\n\t\t{name: \"1⟲ 2⟲ 3⟲ 4⟲\", indices: [[1], [2], [3], [4]]},\r\n\t\t{name: \"1→2\",         indices: [ [], [1],  [],  []]},\r\n\t\t{name: \"1→3\",         indices: [ [],  [], [1],  []]},\r\n\t\t{name: \"1→4\",         indices: [ [],  [],  [], [1]]},\r\n\t\t{name: \"2→3\",         indices: [ [],  [], [2],  []]},\r\n\t\t{name: \"2→4\",         indices: [ [],  [],  [], [2]]},\r\n\t\t{name: \"3→4\",         indices: [ [],  [],  [], [3]]},\r\n\t\t{name: \"1→3 2→4\",     indices: [ [],  [], [1], [2]]},\r\n\t\t{name: \"1→4 2→3\",     indices: [ [],  [], [2], [1]]},\r\n\t\t{name: \"1→2→3→4\",     indices: [ [], [1], [2], [3]]},\r\n\t]);\r\n\tpublic static readonly chipNoiseLength: number = 1 << 15; // 32768\r\n\tpublic static readonly spectrumNoiseLength: number = 1 << 15; // 32768\r\n\tpublic static readonly spectrumBasePitch: number = 24;\r\n\tpublic static readonly spectrumControlPoints: number = 30;\r\n\tpublic static readonly spectrumControlPointsPerOctave: number = 7;\r\n\tpublic static readonly spectrumControlPointBits: number = 3;\r\n\tpublic static readonly spectrumMax: number = (1 << Config.spectrumControlPointBits) - 1;\r\n\tpublic static readonly harmonicsControlPoints: number = 28;\r\n\tpublic static readonly harmonicsRendered: number = 64;\r\n\tpublic static readonly harmonicsRenderedForPickedString: number = 1 << 8; // 256\r\n\tpublic static readonly harmonicsControlPointBits: number = 3;\r\n\tpublic static readonly harmonicsMax: number = (1 << Config.harmonicsControlPointBits) - 1;\r\n\tpublic static readonly harmonicsWavelength: number = 1 << 11; // 2048\r\n\tpublic static readonly pulseWidthRange: number = 8;\r\n\tpublic static readonly pulseWidthStepPower: number = 0.5;\r\n\tpublic static readonly supersawVoiceCount: number = 7;\r\n\tpublic static readonly supersawDynamismMax: number = 6;\r\n\tpublic static readonly supersawSpreadMax: number = 12;\r\n\tpublic static readonly supersawShapeMax: number = 6;\r\n\tpublic static readonly pitchChannelCountMin: number = 1;\r\n\tpublic static readonly pitchChannelCountMax: number = 10;\r\n\tpublic static readonly noiseChannelCountMin: number = 0;\r\n\tpublic static readonly noiseChannelCountMax: number = 5;\r\n\tpublic static readonly noiseInterval: number = 6;\r\n\tpublic static readonly pitchesPerOctave: number = 12; // TODO: Use this for converting pitch to frequency.\r\n\tpublic static readonly drumCount: number = 12;\r\n\tpublic static readonly pitchOctaves: number = 7;\r\n\tpublic static readonly maxPitch: number = Config.pitchOctaves * Config.pitchesPerOctave;\r\n\tpublic static readonly maximumTonesPerChannel: number = Config.maxChordSize * 2;\r\n\tpublic static readonly justIntonationSemitones: number[] = [1.0/2.0, 8.0/15.0, 9.0/16.0, 3.0/5.0, 5.0/8.0, 2.0/3.0, 32.0/45.0, 3.0/4.0, 4.0/5.0, 5.0/6.0, 8.0/9.0, 15.0/16.0, 1.0, 16.0/15.0, 9.0/8.0, 6.0/5.0, 5.0/4.0, 4.0/3.0, 45.0/32.0, 3.0/2.0, 8.0/5.0, 5.0/3.0, 16.0/9.0, 15.0/8.0, 2.0].map(x=>Math.log2(x) * Config.pitchesPerOctave);\r\n\tpublic static readonly pitchShiftRange: number = Config.justIntonationSemitones.length;\r\n\tpublic static readonly pitchShiftCenter: number = Config.pitchShiftRange >> 1;\r\n\tpublic static readonly detuneCenter: number = 9;\r\n\tpublic static readonly detuneMax: number = Config.detuneCenter * 2;\r\n\tpublic static readonly sineWaveLength: number = 1 << 8; // 256\r\n\tpublic static readonly sineWaveMask: number = Config.sineWaveLength - 1;\r\n\tpublic static readonly sineWave: Float32Array = generateSineWave();\r\n\t\r\n\t// Picked strings have an all-pass filter with a corner frequency based on the tone fundamental frequency, in order to add a slight inharmonicity. (Which is important for distortion.)\r\n\tpublic static readonly pickedStringDispersionCenterFreq: number = 6000.0; // The tone fundamental freq is pulled toward this freq for computing the all-pass corner freq.\r\n\tpublic static readonly pickedStringDispersionFreqScale: number = 0.3; // The tone fundamental freq freq moves this much toward the center freq for computing the all-pass corner freq.\r\n\tpublic static readonly pickedStringDispersionFreqMult: number = 4.0; // The all-pass corner freq is based on this times the adjusted tone fundamental freq.\r\n\tpublic static readonly pickedStringShelfHz: number = 4000.0; // The cutoff freq of the shelf filter that is used to decay the high frequency energy in the picked string.\r\n\tpublic static readonly stringSustainRange: number = 15;\r\n\tpublic static readonly stringDecayRate: number = 0.12;\r\n\tpublic static readonly enableAcousticSustain: boolean = false;\r\n\tpublic static readonly sustainTypeNames: ReadonlyArray<string> = [\"bright\", \"acoustic\"]; // See SustainType enum above.\r\n\t\r\n\tpublic static readonly distortionRange: number = 8;\r\n\tpublic static readonly bitcrusherFreqRange: number = 14;\r\n\tpublic static readonly bitcrusherOctaveStep: number = 0.5;\r\n\tpublic static readonly bitcrusherQuantizationRange: number = 8;\r\n\t\r\n\tpublic static readonly maxEnvelopeCount: number = 12;\r\n\tpublic static readonly defaultAutomationRange: number = 13;\r\n\tpublic static readonly instrumentAutomationTargets: DictionaryArray<AutomationTarget> = toNameMap([\r\n\t\t{name: \"none\",                   computeIndex:                           null,                   displayName: \"none\",             /*perNote: false,*/ interleave: false, isFilter: false, /*range: 0,                              */    maxCount: 1,    effect: null,                    compatibleInstruments: null},\r\n\t\t{name: \"noteVolume\",             computeIndex:       EnvelopeComputeIndex.noteVolume,             displayName: \"note volume\",      /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.volumeRange,             */    maxCount: 1,    effect: null,                    compatibleInstruments: null},\r\n\t\t{name: \"pulseWidth\",             computeIndex:       EnvelopeComputeIndex.pulseWidth,             displayName: \"pulse width\",      /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.pulseWidthRange,         */    maxCount: 1,    effect: null,                    compatibleInstruments: [InstrumentType.pwm, InstrumentType.supersaw]},\r\n\t\t{name: \"stringSustain\",          computeIndex:       EnvelopeComputeIndex.stringSustain,          displayName: \"sustain\",          /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.stringSustainRange,      */    maxCount: 1,    effect: null,                    compatibleInstruments: [InstrumentType.pickedString]},\r\n\t\t{name: \"unison\",                 computeIndex:       EnvelopeComputeIndex.unison,                 displayName: \"unison\",           /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.defaultAutomationRange,  */    maxCount: 1,    effect: null,                    compatibleInstruments: [InstrumentType.chip, InstrumentType.harmonics, InstrumentType.pickedString]},\r\n\t\t{name: \"operatorFrequency\",      computeIndex:       EnvelopeComputeIndex.operatorFrequency0,     displayName: \"fm# freq\",         /*perNote:  true,*/ interleave:  true, isFilter: false, /*range: Config.defaultAutomationRange,  */    maxCount: Config.operatorCount, effect: null,    compatibleInstruments: [InstrumentType.fm]},\r\n\t\t{name: \"operatorAmplitude\",      computeIndex:       EnvelopeComputeIndex.operatorAmplitude0,     displayName: \"fm# volume\",       /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.operatorAmplitudeMax + 1,*/    maxCount: Config.operatorCount, effect: null,    compatibleInstruments: [InstrumentType.fm]},\r\n\t\t{name: \"feedbackAmplitude\",      computeIndex:       EnvelopeComputeIndex.feedbackAmplitude,      displayName: \"fm feedback\",      /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.operatorAmplitudeMax + 1,*/    maxCount: 1,    effect: null,                    compatibleInstruments: [InstrumentType.fm]},\r\n\t\t{name: \"pitchShift\",             computeIndex:       EnvelopeComputeIndex.pitchShift,             displayName: \"pitch shift\",      /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.pitchShiftRange,         */    maxCount: 1,    effect: EffectType.pitchShift,   compatibleInstruments: null},\r\n\t\t{name: \"detune\",                 computeIndex:       EnvelopeComputeIndex.detune,                 displayName: \"detune\",           /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.detuneMax + 1,           */    maxCount: 1,    effect: EffectType.detune,       compatibleInstruments: null},\r\n\t\t{name: \"vibratoDepth\",           computeIndex:       EnvelopeComputeIndex.vibratoDepth,           displayName: \"vibrato range\",    /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.defaultAutomationRange,  */    maxCount: 1,    effect: EffectType.vibrato,      compatibleInstruments: null},\r\n\t\t{name: \"noteFilterAllFreqs\",     computeIndex:       EnvelopeComputeIndex.noteFilterAllFreqs,     displayName: \"n. filter freqs\",  /*perNote:  true,*/ interleave: false, isFilter:  true, /*range: null,                           */    maxCount: 1,    effect: EffectType.noteFilter,   compatibleInstruments: null},\r\n\t\t{name: \"noteFilterFreq\",         computeIndex:       EnvelopeComputeIndex.noteFilterFreq0,        displayName: \"n. filter # freq\", /*perNote:  true,*/ interleave: false/*true*/, isFilter:  true, /*range: Config.filterFreqRange, */    maxCount: Config.filterMaxPoints, effect: EffectType.noteFilter, compatibleInstruments: null},\r\n\t\t// Controlling filter gain is less obvious and intuitive than controlling filter freq, so to avoid confusion I've disabled it for envelopes.\r\n\t\t{name: \"noteFilterGain\",         computeIndex:                           null,                    displayName: \"n. filter # vol\",  /*perNote:  true,*/ interleave: false, isFilter:  true, /*range: Config.filterGainRange,         */    maxCount: Config.filterMaxPoints, effect: EffectType.noteFilter, compatibleInstruments: null},\r\n\t\t{name: \"supersawDynamism\",       computeIndex:       EnvelopeComputeIndex.supersawDynamism,       displayName: \"dynamism\",         /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.supersawDynamismMax + 1, */    maxCount: 1,    effect: null,                    compatibleInstruments: [InstrumentType.supersaw]},\r\n\t\t{name: \"supersawSpread\",         computeIndex:       EnvelopeComputeIndex.supersawSpread,         displayName: \"spread\",           /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.supersawSpreadMax + 1,   */    maxCount: 1,    effect: null,                    compatibleInstruments: [InstrumentType.supersaw]},\r\n\t\t{name: \"supersawShape\",          computeIndex:       EnvelopeComputeIndex.supersawShape,          displayName: \"saw↔pulse\",        /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.supersawShapeMax + 1,    */    maxCount: 1,    effect: null,                    compatibleInstruments: [InstrumentType.supersaw]},\r\n\t\t/*\r\n\t\t{name: \"distortion\",             computeIndex: InstrumentAutomationIndex.distortion,             displayName: \"distortion\",       perNote: false, interleave: false, isFilter: false, range: Config.distortionRange,             maxCount: 1,    effect: EffectType.distortion,   compatibleInstruments: null},\r\n\t\t{name: \"bitcrusherQuantization\", computeIndex: InstrumentAutomationIndex.bitcrusherQuantization, displayName: \"bit crush\",        perNote: false, interleave: false, isFilter: false, range: Config.bitcrusherQuantizationRange, maxCount: 1,    effect: EffectType.bitcrusher,   compatibleInstruments: null},\r\n\t\t{name: \"bitcrusherFrequency\",    computeIndex: InstrumentAutomationIndex.bitcrusherFrequency,    displayName: \"freq crush\",       perNote: false, interleave: false, isFilter: false, range: Config.bitcrusherFreqRange,         maxCount: 1,    effect: EffectType.bitcrusher,   compatibleInstruments: null},\r\n\t\t{name: \"eqFilterAllFreqs\",       computeIndex: InstrumentAutomationIndex.eqFilterAllFreqs,       displayName: \"eq filter freqs\",  perNote: false, interleave: false, isFilter:  true, range: null,                               maxCount: 1,    effect: null,                    compatibleInstruments: null},\r\n\t\t{name: \"eqFilterFreq\",           computeIndex: InstrumentAutomationIndex.eqFilterFreq0,          displayName: \"eq filter # freq\", perNote: false, interleave:  true, isFilter:  true, range: Config.filterFreqRange,             maxCount: Config.filterMaxPoints, effect: null,  compatibleInstruments: null},\r\n\t\t{name: \"eqFilterGain\",           computeIndex: InstrumentAutomationIndex.eqFilterGain0,          displayName: \"eq filter # vol\",  perNote: false, interleave: false, isFilter:  true, range: Config.filterGainRange,             maxCount: Config.filterMaxPoints, effect: null,  compatibleInstruments: null},\r\n\t\t{name: \"panning\",                computeIndex: InstrumentAutomationIndex.panning,                displayName: \"panning\",          perNote: false, interleave: false, isFilter: false, range: Config.panMax + 1,                  maxCount: 1,    effect: EffectType.panning,      compatibleInstruments: null},\r\n\t\t{name: \"chorus\",                 computeIndex: InstrumentAutomationIndex.chorus,                 displayName: \"chorus\",           perNote: false, interleave: false, isFilter: false, range: Config.chorusRange,                 maxCount: 1,    effect: EffectType.chorus,       compatibleInstruments: null},\r\n\t\t{name: \"echoSustain\",            computeIndex: InstrumentAutomationIndex.echoSustain,            displayName: \"echo\",             perNote: false, interleave: false, isFilter: false, range: Config.echoSustainRange,            maxCount: 1,    effect: EffectType.echo,         compatibleInstruments: null},\r\n\t\t{name: \"echoDelay\",              computeIndex: InstrumentAutomationIndex.echoDelay,              displayName: \"echo delay\",       perNote: false, interleave: false, isFilter: false, range: Config.echoDelayRange,              maxCount: 1,    effect: EffectType.echo,         compatibleInstruments: null}, // wait until after we're computing a tick's settings for multiple run lengths.\r\n\t\t{name: \"reverb\",                 computeIndex: InstrumentAutomationIndex.reverb,                 displayName: \"reverb\",           perNote: false, interleave: false, isFilter: false, range: Config.reverbRange,                 maxCount: 1,    effect: EffectType.reverb,       compatibleInstruments: null},\r\n\t\t{name: \"mixVolume\",              computeIndex: InstrumentAutomationIndex.mixVolume,              displayName: \"mix volume\",       perNote: false, interleave: false, isFilter: false, range: Config.volumeRange,                 maxCount: 1,    effect: null,                    compatibleInstruments: null},\r\n\t\t{name: \"envelope#\",              computeIndex: null,                                             displayName: \"envelope\",         perNote: false, interleave: false, isFilter: false, range: Config.defaultAutomationRange,      maxCount: Config.maxEnvelopeCount, effect: null, compatibleInstruments: null}, // maxCount special case for envelopes to be allowed to target earlier ones.\r\n\t\t*/\r\n\t]);\r\n}\r\n\r\nfunction centerWave(wave: Array<number>): Float32Array {\r\n\tlet sum: number = 0.0;\r\n\tfor (let i: number = 0; i < wave.length; i++) sum += wave[i];\r\n\tconst average: number = sum / wave.length;\r\n\tfor (let i: number = 0; i < wave.length; i++) wave[i] -= average;\r\n\tperformIntegral(wave);\r\n\t// The first sample should be zero, and we'll duplicate it at the end for easier interpolation.\r\n\twave.push(0);\r\n\treturn new Float32Array(wave);\r\n}\r\n\r\nexport function performIntegral(wave: {length: number, [index: number]: number}): void {\r\n\t// Perform the integral on the wave. The synth function will perform the derivative to get the original wave back but with antialiasing.\r\n\tlet cumulative: number = 0.0;\r\n\tfor (let i: number = 0; i < wave.length; i++) {\r\n\t\tconst temp = wave[i];\r\n\t\twave[i] = cumulative;\r\n\t\tcumulative += temp;\r\n\t}\r\n}\r\n\r\nexport function getPulseWidthRatio(pulseWidth: number): number {\r\n\treturn Math.pow(0.5, (Config.pulseWidthRange - 1 - pulseWidth) * Config.pulseWidthStepPower) * 0.5;\r\n}\r\n\r\n// The function arguments will be defined in FFT.ts, but I want\r\n// SynthConfig.ts to be at the top of the compiled JS so I won't directly\r\n// depend on FFT here. synth.ts will take care of importing FFT.ts.\r\n//function inverseRealFourierTransform(array: {length: number, [index: number]: number}, fullArrayLength: number): void;\r\n//function scaleElementsByFactor(array: {length: number, [index: number]: number}, factor: number): void;\r\nexport function getDrumWave(index: number, inverseRealFourierTransform: Function | null, scaleElementsByFactor: Function | null): Float32Array {\r\n\tlet wave: Float32Array | null = Config.chipNoises[index].samples;\r\n\tif (wave == null) {\r\n\t\twave = new Float32Array(Config.chipNoiseLength + 1);\r\n\t\tConfig.chipNoises[index].samples = wave;\r\n\t\t\r\n\t\tif (index == 0) {\r\n\t\t\t// The \"retro\" drum uses a \"Linear Feedback Shift Register\" similar to the NES noise channel.\r\n\t\t\tlet drumBuffer: number = 1;\r\n\t\t\tfor (let i: number = 0; i < Config.chipNoiseLength; i++) {\r\n\t\t\t\twave[i] = (drumBuffer & 1) * 2.0 - 1.0;\r\n\t\t\t\tlet newBuffer: number = drumBuffer >> 1;\r\n\t\t\t\tif (((drumBuffer + newBuffer) & 1) == 1) {\r\n\t\t\t\t\tnewBuffer += 1 << 14;\r\n\t\t\t\t}\r\n\t\t\t\tdrumBuffer = newBuffer;\r\n\t\t\t}\r\n\t\t} else if (index == 1) {\r\n\t\t\t// White noise is just random values for each sample.\r\n\t\t\tfor (let i: number = 0; i < Config.chipNoiseLength; i++) {\r\n\t\t\t\twave[i] = Math.random() * 2.0 - 1.0;\r\n\t\t\t}\r\n\t\t} else if (index == 2) {\r\n\t\t\t// The \"clang\" noise wave is based on a similar noise wave in the modded beepbox made by DAzombieRE.\r\n\t\t\tlet drumBuffer: number = 1;\r\n\t\t\tfor (let i: number = 0; i < Config.chipNoiseLength; i++) {\r\n\t\t\t\twave[i] = (drumBuffer & 1) * 2.0 - 1.0;\r\n\t\t\t\tlet newBuffer: number = drumBuffer >> 1;\r\n\t\t\t\tif (((drumBuffer + newBuffer) & 1) == 1) {\r\n\t\t\t\t\tnewBuffer += 2 << 14;\r\n\t\t\t\t}\r\n\t\t\t\tdrumBuffer = newBuffer;\r\n\t\t\t}\r\n\t\t} else if (index == 3) {\r\n\t\t\t// The \"buzz\" noise wave is based on a similar noise wave in the modded beepbox made by DAzombieRE.\r\n\t\t\tlet drumBuffer: number = 1;\r\n\t\t\tfor (let i: number = 0; i < Config.chipNoiseLength; i++) {\r\n\t\t\t\twave[i] = (drumBuffer & 1) * 2.0 - 1.0;\r\n\t\t\t\tlet newBuffer: number = drumBuffer >> 1;\r\n\t\t\t\tif (((drumBuffer + newBuffer) & 1) == 1) {\r\n\t\t\t\t\tnewBuffer += 10 << 2;\r\n\t\t\t\t}\r\n\t\t\t\tdrumBuffer = newBuffer;\r\n\t\t\t}\r\n\t\t} else if (index == 4) {\r\n\t\t\t// \"hollow\" drums, designed in frequency space and then converted via FFT:\r\n\t\t\tdrawNoiseSpectrum(wave, Config.chipNoiseLength, 10, 11, 1, 1, 0);\r\n\t\t\tdrawNoiseSpectrum(wave, Config.chipNoiseLength, 11, 14, .6578, .6578, 0);\r\n\t\t\tinverseRealFourierTransform!(wave, Config.chipNoiseLength);\r\n\t\t\tscaleElementsByFactor!(wave, 1.0 / Math.sqrt(Config.chipNoiseLength));\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Unrecognized drum index: \" + index);\r\n\t\t}\r\n\t\t\r\n\t\twave[Config.chipNoiseLength] = wave[0];\r\n\t}\r\n\t\r\n\treturn wave;\r\n}\r\n\r\nexport function drawNoiseSpectrum(wave: Float32Array, waveLength: number, lowOctave: number, highOctave: number, lowPower: number, highPower: number, overallSlope: number): number {\r\n\tconst referenceOctave: number = 11;\r\n\tconst referenceIndex: number = 1 << referenceOctave;\r\n\tconst lowIndex: number = Math.pow(2, lowOctave) | 0;\r\n\tconst highIndex: number = Math.min(waveLength >> 1, Math.pow(2, highOctave) | 0);\r\n\tconst retroWave: Float32Array = getDrumWave(0, null, null);\r\n\tlet combinedAmplitude: number = 0.0;\r\n\tfor (let i: number = lowIndex; i < highIndex; i++) {\r\n\t\t\r\n\t\tlet lerped: number = lowPower + (highPower - lowPower) * (Math.log2(i) - lowOctave) / (highOctave - lowOctave);\r\n\t\tlet amplitude: number = Math.pow(2, (lerped - 1) * 7 + 1) * lerped;\r\n\t\t\r\n\t\tamplitude *= Math.pow(i / referenceIndex, overallSlope);\r\n\t\t\r\n\t\tcombinedAmplitude += amplitude;\r\n\t\t\r\n\t\t// Add two different sources of psuedo-randomness to the noise\r\n\t\t// (individually they aren't random enough) but in a deterministic\r\n\t\t// way so that live spectrum editing doesn't result in audible pops.\r\n\t\t// Multiply all the sine wave amplitudes by 1 or -1 based on the\r\n\t\t// LFSR retro wave (effectively random), and also rotate the phase\r\n\t\t// of each sine wave based on the golden angle to disrupt the symmetry.\r\n\t\tamplitude *= retroWave[i];\r\n\t\tconst radians: number = 0.61803398875 * i * i * Math.PI * 2.0;\r\n\t\t\r\n\t\twave[i] = Math.cos(radians) * amplitude;\r\n\t\twave[waveLength - i] = Math.sin(radians) * amplitude;\r\n\t}\r\n\t\r\n\treturn combinedAmplitude;\r\n}\r\n\r\nfunction generateSineWave(): Float32Array {\r\n\tconst wave: Float32Array = new Float32Array(Config.sineWaveLength + 1);\r\n\tfor (let i: number = 0; i < Config.sineWaveLength + 1; i++) {\r\n\t\twave[i] = Math.sin(i * Math.PI * 2.0 / Config.sineWaveLength);\r\n\t}\r\n\treturn wave;\r\n}\r\n\r\nexport function getArpeggioPitchIndex(pitchCount: number, rhythm: number, arpeggio: number): number {\r\n\tconst arpeggioPattern: ReadonlyArray<number> = Config.rhythms[rhythm].arpeggioPatterns[pitchCount - 1];\r\n\tif (arpeggioPattern != null) {\r\n\t\treturn arpeggioPattern[arpeggio % arpeggioPattern.length];\r\n\t} else {\r\n\t\treturn arpeggio % pitchCount;\r\n\t}\r\n}\r\n\r\n// Pardon the messy type casting. This allows accessing array members by numerical index or string name.\r\nexport function toNameMap<T extends BeepBoxOption>(array: Array<Pick<T, Exclude<keyof T, \"index\">>>): DictionaryArray<T> {\r\n\tconst dictionary: Dictionary<T> = {};\r\n\tfor (let i: number = 0; i < array.length; i++) {\r\n\t\tconst value: any = array[i];\r\n\t\tvalue.index = i;\r\n\t\tdictionary[value.name] = <T> value;\r\n\t}\r\n\tconst result: DictionaryArray<T> = <DictionaryArray<T>> <any> array;\r\n\tresult.dictionary = dictionary;\r\n\treturn result;\r\n}\r\n\r\nexport function effectsIncludeTransition(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.transition)) != 0;\r\n}\r\nexport function effectsIncludeChord(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.chord)) != 0;\r\n}\r\nexport function effectsIncludePitchShift(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.pitchShift)) != 0;\r\n}\r\nexport function effectsIncludeDetune(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.detune)) != 0;\r\n}\r\nexport function effectsIncludeVibrato(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.vibrato)) != 0;\r\n}\r\nexport function effectsIncludeNoteFilter(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.noteFilter)) != 0;\r\n}\r\nexport function effectsIncludeDistortion(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.distortion)) != 0;\r\n}\r\nexport function effectsIncludeBitcrusher(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.bitcrusher)) != 0;\r\n}\r\nexport function effectsIncludePanning(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.panning)) != 0;\r\n}\r\nexport function effectsIncludeChorus(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.chorus)) != 0;\r\n}\r\nexport function effectsIncludeEcho(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.echo)) != 0;\r\n}\r\nexport function effectsIncludeReverb(effects: number): boolean {\r\n\treturn (effects & (1 << EffectType.reverb)) != 0;\r\n}\r\n","// Copyright (c) 2012-2022 John Nesky and contributing authors, distributed under the MIT license, see accompanying the LICENSE.md file.\r\n\r\n// interface shared by number[], Float32Array, and other typed arrays in JavaScript.\r\ninterface NumberArray {\r\n\tlength: number;\r\n\t[index: number]: number;\r\n}\r\n\r\n// A basic FFT operation scales the overall magnitude of elements by the\r\n// square root of the length of the array, √N. Performing a forward FFT and\r\n// then an inverse FFT results in the original array, but multiplied by N.\r\n// This helper function can be used to compensate for that. \r\nexport function scaleElementsByFactor(array: NumberArray, factor: number): void {\r\n\tfor (let i: number = 0; i < array.length; i++) {\r\n\t\tarray[i] *= factor;\r\n\t}\r\n}\r\n\r\nfunction isPowerOf2(n: number): boolean {\r\n\treturn !!n && !(n & (n - 1));\r\n}\r\n\r\nfunction countBits(n: number): number {\r\n\tif (!isPowerOf2(n)) throw new Error(\"FFT array length must be a power of 2.\");\r\n\treturn Math.round(Math.log(n) / Math.log(2));\r\n}\r\n\r\n// Rearranges the elements of the array, swapping the element at an index\r\n// with an element at an index that is the bitwise reverse of the first\r\n// index in base 2. Useful for computing the FFT.\r\nfunction reverseIndexBits(array: NumberArray, fullArrayLength: number): void {\r\n\tconst bitCount: number = countBits(fullArrayLength);\r\n\tif (bitCount > 16) throw new Error(\"FFT array length must not be greater than 2^16.\");\r\n\tconst finalShift: number = 16 - bitCount;\r\n\tfor (let i: number = 0; i < fullArrayLength; i++) {\r\n\t\t// Dear Javascript: Please support bit order reversal intrinsics. Thanks! :D\r\n\t\tlet j: number;\r\n\t\tj = ((i & 0xaaaa) >> 1) | ((i & 0x5555) << 1);\r\n\t\tj = ((j & 0xcccc) >> 2) | ((j & 0x3333) << 2);\r\n\t\tj = ((j & 0xf0f0) >> 4) | ((j & 0x0f0f) << 4);\r\n\t\tj = ((j           >> 8) | ((j &   0xff) << 8)) >> finalShift;\r\n\t\tif (j > i) {\r\n\t\t\tlet temp: number = array[i];\r\n\t\t\tarray[i] = array[j];\r\n\t\t\tarray[j] = temp;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Provided for educational purposes. Easier to read than\r\n// fastFourierTransform(), but computes the same result.\r\n// Takes two parallel arrays representing the real and imaginary elements,\r\n// respectively, and returns an array containing two new arrays, which\r\n// contain the complex result of the transform.\r\nexport function discreteFourierTransform(realArray: NumberArray, imagArray: NumberArray): number[][] {\r\n\tconst fullArrayLength: number = realArray.length;\r\n\tif (fullArrayLength != imagArray.length) throw new Error(\"FFT arrays must be the same length.\");\r\n\tconst realOut: number[] = [];\r\n\tconst imagOut: number[] = [];\r\n\tfor (let i: number = 0; i < fullArrayLength; i++) {\r\n\t\trealOut[i] = 0.0;\r\n\t\timagOut[i] = 0.0;\r\n\t\tfor (let j: number = 0; j < fullArrayLength; j++) {\r\n\t\t\tconst radians: number = -6.2831853 * j * i / fullArrayLength;\r\n\t\t\tconst c: number = Math.cos(radians);\r\n\t\t\tconst s: number = Math.sin(radians);\r\n\t\t\trealOut[i] += realArray[j] * c - imagArray[j] * s;\r\n\t\t\timagOut[i] += realArray[j] * s + imagArray[j] * c;\r\n\t\t}\r\n\t}\r\n\treturn [realOut, imagOut];\r\n}\r\n\r\n// Performs a Fourier transform in O(N log(N)) operations. Overwrites the\r\n// input real and imaginary arrays. Can be used for both forward and inverse\r\n// transforms: swap the order of the arguments for the inverse.\r\nexport function fastFourierTransform(realArray: NumberArray, imagArray: NumberArray): void {\r\n\tconst fullArrayLength: number = realArray.length;\r\n\tif (!isPowerOf2(fullArrayLength)) throw new Error(\"FFT array length must be a power of 2.\");\r\n\tif (fullArrayLength < 4) throw new Error(\"FFT array length must be at least 4.\");\r\n\tif (fullArrayLength != imagArray.length) throw new Error(\"FFT arrays must be the same length.\");\r\n\t\r\n\treverseIndexBits(realArray, fullArrayLength);\r\n\treverseIndexBits(imagArray, fullArrayLength);\r\n\t\r\n\t// First two passes, with strides of 2 and 4, can be combined and optimized.\r\n\tfor (let startIndex: number = 0; startIndex < fullArrayLength; startIndex += 4) {\r\n\t\tconst startIndex1: number = startIndex + 1;\r\n\t\tconst startIndex2: number = startIndex + 2;\r\n\t\tconst startIndex3: number = startIndex + 3;\r\n\t\tconst real0: number = realArray[startIndex ];\r\n\t\tconst real1: number = realArray[startIndex1];\r\n\t\tconst real2: number = realArray[startIndex2];\r\n\t\tconst real3: number = realArray[startIndex3];\r\n\t\tconst imag0: number = imagArray[startIndex ];\r\n\t\tconst imag1: number = imagArray[startIndex1];\r\n\t\tconst imag2: number = imagArray[startIndex2];\r\n\t\tconst imag3: number = imagArray[startIndex3];\r\n\t\tconst realTemp0: number = real0 + real1;\r\n\t\tconst realTemp1: number = real0 - real1;\r\n\t\tconst realTemp2: number = real2 + real3;\r\n\t\tconst realTemp3: number = real2 - real3;\r\n\t\tconst imagTemp0: number = imag0 + imag1;\r\n\t\tconst imagTemp1: number = imag0 - imag1;\r\n\t\tconst imagTemp2: number = imag2 + imag3;\r\n\t\tconst imagTemp3: number = imag2 - imag3;\r\n\t\trealArray[startIndex ] = realTemp0 + realTemp2;\r\n\t\trealArray[startIndex1] = realTemp1 + imagTemp3;\r\n\t\trealArray[startIndex2] = realTemp0 - realTemp2;\r\n\t\trealArray[startIndex3] = realTemp1 - imagTemp3;\r\n\t\timagArray[startIndex ] = imagTemp0 + imagTemp2;\r\n\t\timagArray[startIndex1] = imagTemp1 - realTemp3;\r\n\t\timagArray[startIndex2] = imagTemp0 - imagTemp2;\r\n\t\timagArray[startIndex3] = imagTemp1 + realTemp3;\r\n\t}\r\n\t\r\n\tfor (let stride: number = 8; stride <= fullArrayLength; stride += stride) {\r\n\t\tconst halfLength: number = stride >>> 1;\r\n\t\tconst radiansIncrement: number = Math.PI * 2.0 / stride;\r\n\t\tconst cosIncrement: number = Math.cos(radiansIncrement);\r\n\t\tconst sinIncrement: number = Math.sin(radiansIncrement);\r\n\t\tconst oscillatorMultiplier: number = 2.0 * cosIncrement;\r\n\t\tfor (let startIndex: number = 0; startIndex < fullArrayLength; startIndex += stride) {\r\n\t\t\tlet c: number = 1.0;\r\n\t\t\tlet s: number = 0.0;\r\n\t\t\tlet cPrev: number = cosIncrement;\r\n\t\t\tlet sPrev: number = sinIncrement;\r\n\t\t\tconst secondHalf: number = startIndex + halfLength;\r\n\t\t\tfor (let i: number = startIndex; i < secondHalf; i++) {\r\n\t\t\t\tconst j: number = i + halfLength;\r\n\t\t\t\tconst real0: number = realArray[i];\r\n\t\t\t\tconst imag0: number = imagArray[i];\r\n\t\t\t\tconst real1: number = realArray[j] * c - imagArray[j] * s;\r\n\t\t\t\tconst imag1: number = realArray[j] * s + imagArray[j] * c;\r\n\t\t\t\trealArray[i] = real0 + real1;\r\n\t\t\t\timagArray[i] = imag0 + imag1;\r\n\t\t\t\trealArray[j] = real0 - real1;\r\n\t\t\t\timagArray[j] = imag0 - imag1;\r\n\t\t\t\tconst cTemp: number = oscillatorMultiplier * c - cPrev;\r\n\t\t\t\tconst sTemp: number = oscillatorMultiplier * s - sPrev;\r\n\t\t\t\tcPrev = c;\r\n\t\t\t\tsPrev = s;\r\n\t\t\t\tc = cTemp;\r\n\t\t\t\ts = sTemp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Computes the Fourier transform from an array of real-valued time-domain\r\n// samples. The output is specially formatted for space efficieny: elements\r\n// 0 through N/2 represent cosine wave amplitudes in ascending frequency,\r\n// and elements N/2+1 through N-1 represent sine wave amplitudes in\r\n// descending frequency. Overwrites the input array.\r\nexport function forwardRealFourierTransform(array: NumberArray): void {\r\n\tconst fullArrayLength: number = array.length;\r\n\tconst totalPasses: number = countBits(fullArrayLength);\r\n\tif (fullArrayLength < 4) throw new Error(\"FFT array length must be at least 4.\");\r\n\t\r\n\treverseIndexBits(array, fullArrayLength);\r\n\t\r\n\t// First and second pass.\r\n\tfor (let index: number = 0; index < fullArrayLength; index += 4) {\r\n\t\tconst index1: number = index + 1;\r\n\t\tconst index2: number = index + 2;\r\n\t\tconst index3: number = index + 3;\r\n\t\tconst real0: number = array[index ];\r\n\t\tconst real1: number = array[index1];\r\n\t\tconst real2: number = array[index2];\r\n\t\tconst real3: number = array[index3];\r\n\t\t// no imaginary elements yet since the input is fully real.\r\n\t\tconst tempA: number = real0 + real1;\r\n\t\tconst tempB: number = real2 + real3;\r\n\t\tarray[index ] = tempA + tempB;\r\n\t\tarray[index1] = real0 - real1;\r\n\t\tarray[index2] = tempA - tempB;\r\n\t\tarray[index3] = real2 - real3;\r\n\t}\r\n\t\r\n\t// Third pass.\r\n\tconst sqrt2over2: number = Math.sqrt(2.0) / 2.0;\r\n\tfor (let index: number = 0; index < fullArrayLength; index += 8) {\r\n\t\tconst index1: number = index + 1;\r\n\t\tconst index3: number = index + 3;\r\n\t\tconst index4: number = index + 4;\r\n\t\tconst index5: number = index + 5;\r\n\t\tconst index7: number = index + 7;\r\n\t\tconst real0: number = array[index ];\r\n\t\tconst real1: number = array[index1];\r\n\t\tconst imag3: number = array[index3];\r\n\t\tconst real4: number = array[index4];\r\n\t\tconst real5: number = array[index5];\r\n\t\tconst imag7: number = array[index7];\r\n\t\tconst tempA: number = (real5 - imag7) * sqrt2over2;\r\n\t\tconst tempB: number = (real5 + imag7) * sqrt2over2;\r\n\t\tarray[index ] = real0 + real4;\r\n\t\tarray[index1] = real1 + tempA;\r\n\t\tarray[index3] = real1 - tempA;\r\n\t\tarray[index4] = real0 - real4;\r\n\t\tarray[index5] = tempB - imag3;\r\n\t\tarray[index7] = tempB + imag3;\r\n\t}\r\n\t\r\n\t// Handle remaining passes.\r\n\tfor (let pass: number = 3; pass < totalPasses; pass++) {\r\n\t\tconst subStride: number = 1 << pass;\r\n\t\tconst midSubStride: number = subStride >> 1;\r\n\t\tconst stride: number = subStride << 1;\r\n\t\tconst radiansIncrement: number = Math.PI * 2.0 / stride;\r\n\t\tconst cosIncrement: number = Math.cos(radiansIncrement);\r\n\t\tconst sinIncrement: number = Math.sin(radiansIncrement);\r\n\t\tconst oscillatorMultiplier: number = 2.0 * cosIncrement;\r\n\t\tfor (let startIndex: number = 0; startIndex < fullArrayLength; startIndex += stride) {\r\n\t\t\tconst startIndexA: number = startIndex;\r\n\t\t\tconst startIndexB: number = startIndexA + subStride;\r\n\t\t\tconst stopIndex: number = startIndexB + subStride;\r\n\t\t\tconst realStartA: number = array[startIndexA];\r\n\t\t\tconst realStartB: number = array[startIndexB];\r\n\t\t\tarray[startIndexA] = realStartA + realStartB;\r\n\t\t\tarray[startIndexB] = realStartA - realStartB;\r\n\t\t\tlet c: number = cosIncrement;\r\n\t\t\tlet s: number = -sinIncrement;\r\n\t\t\tlet cPrev: number = 1.0;\r\n\t\t\tlet sPrev: number = 0.0;\r\n\t\t\tfor (let index: number = 1; index < midSubStride; index++) {\r\n\t\t\t\tconst indexA0: number = startIndexA + index;\r\n\t\t\t\tconst indexA1: number = startIndexB - index;\r\n\t\t\t\tconst indexB0: number = startIndexB + index;\r\n\t\t\t\tconst indexB1: number = stopIndex   - index;\r\n\t\t\t\tconst real0: number = array[indexA0];\r\n\t\t\t\tconst imag0: number = array[indexA1];\r\n\t\t\t\tconst real1: number = array[indexB0];\r\n\t\t\t\tconst imag1: number = array[indexB1];\r\n\t\t\t\tconst tempA: number = real1 * c + imag1 * s;\r\n\t\t\t\tconst tempB: number = real1 * s - imag1 * c;\r\n\t\t\t\tarray[indexA0] = real0 + tempA;\r\n\t\t\t\tarray[indexA1] = real0 - tempA;\r\n\t\t\t\tarray[indexB0] =-imag0 - tempB;\r\n\t\t\t\tarray[indexB1] = imag0 - tempB;\r\n\t\t\t\tconst cTemp: number = oscillatorMultiplier * c - cPrev;\r\n\t\t\t\tconst sTemp: number = oscillatorMultiplier * s - sPrev;\r\n\t\t\t\tcPrev = c;\r\n\t\t\t\tsPrev = s;\r\n\t\t\t\tc = cTemp;\r\n\t\t\t\ts = sTemp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Computes the inverse Fourier transform from a specially formatted array of\r\n// scalar values. Elements 0 through N/2 are expected to be the real values of\r\n// the corresponding complex elements, representing cosine wave amplitudes in\r\n// ascending frequency, and elements N/2+1 through N-1 correspond to the\r\n// imaginary values, representing sine wave amplitudes in descending frequency.\r\n// Generates real-valued time-domain samples. Overwrites the input array.\r\nexport function inverseRealFourierTransform(array: NumberArray, fullArrayLength: number): void {\r\n\tconst totalPasses: number = countBits(fullArrayLength);\r\n\tif (fullArrayLength < 4) throw new Error(\"FFT array length must be at least 4.\");\r\n\r\n\t// Perform all but the last few passes in reverse.\r\n\tfor (let pass: number = totalPasses - 1; pass >= 2; pass--) {\r\n\t\tconst subStride: number = 1 << pass;\r\n\t\tconst midSubStride: number = subStride >> 1;\r\n\t\tconst stride: number = subStride << 1;\r\n\t\tconst radiansIncrement: number = Math.PI * 2.0 / stride;\r\n\t\tconst cosIncrement: number = Math.cos(radiansIncrement);\r\n\t\tconst sinIncrement: number = Math.sin(radiansIncrement);\r\n\t\tconst oscillatorMultiplier: number = 2.0 * cosIncrement;\r\n\t\t\r\n\t\tfor (let startIndex: number = 0; startIndex < fullArrayLength; startIndex += stride) {\r\n\t\t\tconst startIndexA: number = startIndex;\r\n\t\t\tconst midIndexA: number = startIndexA + midSubStride;\r\n\t\t\tconst startIndexB: number = startIndexA + subStride;\r\n\t\t\tconst midIndexB: number = startIndexB + midSubStride;\r\n\t\t\tconst stopIndex: number = startIndexB + subStride;\r\n\t\t\tconst realStartA: number = array[startIndexA];\r\n\t\t\tconst imagStartB: number = array[startIndexB];\r\n\t\t\tarray[startIndexA] = realStartA + imagStartB;\r\n\t\t\tarray[midIndexA] *= 2;\r\n\t\t\tarray[startIndexB] = realStartA - imagStartB;\r\n\t\t\tarray[midIndexB] *= 2;\r\n\t\t\tlet c: number = cosIncrement;\r\n\t\t\tlet s: number = -sinIncrement;\r\n\t\t\tlet cPrev: number = 1.0;\r\n\t\t\tlet sPrev: number = 0.0;\r\n\t\t\tfor (let index: number = 1; index < midSubStride; index++) {\r\n\t\t\t\tconst indexA0: number = startIndexA + index;\r\n\t\t\t\tconst indexA1: number = startIndexB - index;\r\n\t\t\t\tconst indexB0: number = startIndexB + index;\r\n\t\t\t\tconst indexB1: number = stopIndex   - index;\r\n\t\t\t\tconst real0: number = array[indexA0];\r\n\t\t\t\tconst real1: number = array[indexA1];\r\n\t\t\t\tconst imag0: number = array[indexB0];\r\n\t\t\t\tconst imag1: number = array[indexB1];\r\n\t\t\t\tconst tempA: number = real0 - real1;\r\n\t\t\t\tconst tempB: number = imag0 + imag1;\r\n\t\t\t\tarray[indexA0] = real0 + real1;\r\n\t\t\t\tarray[indexA1] = imag1 - imag0;\r\n\t\t\t\tarray[indexB0] = tempA * c - tempB * s;\r\n\t\t\t\tarray[indexB1] = tempB * c + tempA * s;\r\n\t\t\t\tconst cTemp: number = oscillatorMultiplier * c - cPrev;\r\n\t\t\t\tconst sTemp: number = oscillatorMultiplier * s - sPrev;\r\n\t\t\t\tcPrev = c;\r\n\t\t\t\tsPrev = s;\r\n\t\t\t\tc = cTemp;\r\n\t\t\t\ts = sTemp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t// Commented out this block (and compensated with an extra pass above)\r\n\t// because it's slower in my testing so far.\r\n\t// Pass with stride 8.\r\n\tconst sqrt2over2: number = Math.sqrt(2.0) / 2.0;\r\n\tfor (let index: number = 0; index < fullArrayLength; index += 8) {\r\n\t\tconst index1: number = index + 1;\r\n\t\tconst index2: number = index + 2;\r\n\t\tconst index3: number = index + 3;\r\n\t\tconst index4: number = index + 4;\r\n\t\tconst index5: number = index + 5;\r\n\t\tconst index6: number = index + 6;\r\n\t\tconst index7: number = index + 7;\r\n\t\tconst real0: number = array[index ];\r\n\t\tconst real1: number = array[index1];\r\n\t\tconst real2: number = array[index2];\r\n\t\tconst real3: number = array[index3];\r\n\t\tconst imag4: number = array[index4];\r\n\t\tconst imag5: number = array[index5];\r\n\t\tconst imag6: number = array[index6];\r\n\t\tconst imag7: number = array[index7];\r\n\t\tconst tempA: number = real1 - real3;\r\n\t\tconst tempB: number = imag5 + imag7;\r\n\t\tarray[index ] = real0 + imag4;\r\n\t\tarray[index1] = real1 + real3;\r\n\t\tarray[index2] = real2 * 2;\r\n\t\tarray[index3] = imag7 - imag5;\r\n\t\tarray[index4] = real0 - imag4;\r\n\t\tarray[index5] = (tempA + tempB) * sqrt2over2;\r\n\t\tarray[index6] = imag6 * 2;\r\n\t\tarray[index7] = (tempB - tempA) * sqrt2over2;\r\n\t}\r\n\t*/\r\n\t// The final passes with strides 4 and 2, combined into one loop.\r\n\tfor (let index: number = 0; index < fullArrayLength; index += 4) {\r\n\t\tconst index1: number = index + 1;\r\n\t\tconst index2: number = index + 2;\r\n\t\tconst index3: number = index + 3;\r\n\t\tconst real0: number = array[index ];\r\n\t\tconst real1: number = array[index1] * 2;\r\n\t\tconst imag2: number = array[index2];\r\n\t\tconst imag3: number = array[index3] * 2;\r\n\t\tconst tempA: number = real0 + imag2;\r\n\t\tconst tempB: number = real0 - imag2;\r\n\t\tarray[index ] = tempA + real1;\r\n\t\tarray[index1] = tempA - real1;\r\n\t\tarray[index2] = tempB + imag3;\r\n\t\tarray[index3] = tempB - imag3;\r\n\t}\r\n\t\r\n\treverseIndexBits(array, fullArrayLength);\r\n}\r\n","// Copyright (c) 2012-2022 John Nesky and contributing authors, distributed under the MIT license, see accompanying the LICENSE.md file.\r\n\r\nexport class Deque<T> {\r\n\tprivate _capacity: number = 1;\r\n\tprivate _buffer: Array<T | undefined> = [undefined];\r\n\tprivate _mask: number = 0;\r\n\tprivate _offset: number = 0;\r\n\tprivate _count: number = 0;\r\n\r\n\tpublic pushFront(element: T): void {\r\n\t\tif (this._count >= this._capacity) this._expandCapacity();\r\n\t\tthis._offset = (this._offset - 1) & this._mask;\r\n\t\tthis._buffer[this._offset] = element;\r\n\t\tthis._count++;\r\n\t}\r\n\tpublic pushBack(element: T): void {\r\n\t\tif (this._count >= this._capacity) this._expandCapacity();\r\n\t\tthis._buffer[(this._offset + this._count) & this._mask] = element;\r\n\t\tthis._count++;\r\n\t}\r\n\tpublic popFront(): T {\r\n\t\tif (this._count <= 0) throw new Error(\"No elements left to pop.\");\r\n\t\tconst element: T = <T>this._buffer[this._offset];\r\n\t\tthis._buffer[this._offset] = undefined;\r\n\t\tthis._offset = (this._offset + 1) & this._mask;\r\n\t\tthis._count--;\r\n\t\treturn element;\r\n\t}\r\n\tpublic popBack(): T {\r\n\t\tif (this._count <= 0) throw new Error(\"No elements left to pop.\");\r\n\t\tthis._count--;\r\n\t\tconst index: number = (this._offset + this._count) & this._mask;\r\n\t\tconst element: T = <T>this._buffer[index];\r\n\t\tthis._buffer[index] = undefined;\r\n\t\treturn element;\r\n\t}\r\n\tpublic peakFront(): T {\r\n\t\tif (this._count <= 0) throw new Error(\"No elements left to pop.\");\r\n\t\treturn <T>this._buffer[this._offset];\r\n\t}\r\n\tpublic peakBack(): T {\r\n\t\tif (this._count <= 0) throw new Error(\"No elements left to pop.\");\r\n\t\treturn <T>this._buffer[(this._offset + this._count - 1) & this._mask];\r\n\t}\r\n\tpublic count(): number {\r\n\t\treturn this._count;\r\n\t}\r\n\tpublic set(index: number, element: T): void {\r\n\t\tif (index < 0 || index >= this._count) throw new Error(\"Invalid index\");\r\n\t\tthis._buffer[(this._offset + index) & this._mask] = element;\r\n\t}\r\n\tpublic get(index: number): T {\r\n\t\tif (index < 0 || index >= this._count) throw new Error(\"Invalid index\");\r\n\t\treturn <T>this._buffer[(this._offset + index) & this._mask];\r\n\t}\r\n\tpublic remove(index: number): void {\r\n\t\tif (index < 0 || index >= this._count) throw new Error(\"Invalid index\");\r\n\t\tif (index <= (this._count >> 1)) {\r\n\t\t\twhile (index > 0) {\r\n\t\t\t\tthis.set(index, this.get(index - 1));\r\n\t\t\t\tindex--;\r\n\t\t\t}\r\n\t\t\tthis.popFront();\r\n\t\t} else {\r\n\t\t\tindex++;\r\n\t\t\twhile (index < this._count) {\r\n\t\t\t\tthis.set(index - 1, this.get(index));\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\tthis.popBack();\r\n\t\t}\r\n\t}\r\n\tprivate _expandCapacity(): void {\r\n\t\tif (this._capacity >= 0x40000000) throw new Error(\"Capacity too big.\");\r\n\t\tthis._capacity = this._capacity << 1;\r\n\t\tconst oldBuffer: Array<T | undefined> = this._buffer;\r\n\t\tconst newBuffer: Array<T | undefined> = new Array(this._capacity);\r\n\t\tconst size: number = this._count | 0;\r\n\t\tconst offset: number = this._offset | 0;\r\n\t\tfor (let i = 0; i < size; i++) {\r\n\t\t\tnewBuffer[i] = oldBuffer[(offset + i) & this._mask];\r\n\t\t}\r\n\t\tfor (let i = size; i < this._capacity; i++) {\r\n\t\t\tnewBuffer[i] = undefined;\r\n\t\t}\r\n\t\tthis._offset = 0;\r\n\t\tthis._buffer = newBuffer;\r\n\t\tthis._mask = this._capacity - 1;\r\n\t}\r\n}\r\n","/*\r\nThis file contains code to compute digital audio filter coefficients based on\r\nthe desired type, cutoff frequency, and other parameters. You can use these\r\ncoefficients to apply the filter to audio samples. It also contains code to\r\nanalyze these filters, which is useful for graphically displaying their effects.\r\n\r\nAll of the filters in this file are known as \"Infinite Impulse Response\" or IIR\r\nfilters, because older output samples contribute feedback to newer output\r\nsamples and thus contribute to all future samples, although typically filters\r\nare design to reduce the contribution of older samples over time.\r\n\r\nLow-pass filters aka high-cut filters preserve audio signals below the cutoff\r\nfrequency, and attenuate audio signals above the cutoff frequency. High-pass\r\nfilters aka low-cut filters are the reverse. All-pass filters do not affect the\r\nvolume of the signal at all but induce phase changes above the cutoff frequency.\r\nPeak/Notch filters maintain the volume on either side of the cutoff frequency,\r\nbut raise or lower the volume at that frequency. \r\n\r\nThe number of old samples used in the filter determines the \"order\" of the\r\nfilter. First-order filters generally have shallower slopes, and second-order\r\nfilters generally have steeper slopes and can be configured to \"resonate\",\r\nmeaning they have a louder peak at the cutoff frequency. This file contains\r\nfirst-order filters and second-order filters, meaning one or two older samples\r\nare involved, as well as the current input sample.\r\n\r\nThe class FilterCoefficients is defined lower in this file. You can use it to\r\nset up a first order filter like this:\r\n\r\n\tconst cutoffRadiansPerSample: number = 2 * Math.PI * cutoffHz / sampleRate;\r\n\tconst filter: FilterCoefficients = new FilterCoefficients();\r\n\tfilter.lowPass1stOrderButterworth(cutoffRadiansPerSample);\r\n\t// output sample coefficients are conventionally called a0, a1, etc. Note\r\n\t// that a[0] is typically normalized to 1.0 and need not be used directly.\r\n\tconst a: number[] = filter.a;\r\n\t// input sample coefficients are conventionally called b0, b1, etc\r\n\tconst b: number[] = filter.b;\r\n\t// filter input samples, x[0] is the most recent, x[1] is the previous one, etc.\r\n\tconst x: number[] = [0, 0, 0];\r\n\t// filter output samples, y[0] will be computed by the filter based on input\r\n\t// samples and older output samples.\r\n\tconst y: number[] = [0, 0, 0];\r\n\r\nThen to apply the first-order filter to samples inside a loop, using the current\r\ninput sample (x[0]) as well as previous input and output samples, do this:\r\n\r\n\t// Compute the next output sample y[0]:\r\n\ty[0] = b[0] * x[0] + b[1] * x[1] - a[1] * y[1];\r\n\t// Remember the input and output samples for next time:\r\n\tx[1] = x[0];\r\n\ty[1] = y[0];\r\n\r\n2nd order filters are similar, but have more parameters and require more old\r\nsamples:\r\n\r\n\t// Compute the next output sample y[0]:\r\n\ty[0] = b[0] * x[0] + b[1] * x[1] + b[2] * x[2] - a[1] * y[1] - a[2] * y[2];\r\n\t// Remember the input and output samples for next time:\r\n\tx[2] = x[1];\r\n\tx[1] = x[0];\r\n\ty[2] = y[1];\r\n\ty[1] = y[0];\r\n\r\nYou can compose multiple filters into a higher order filter, although doing so\r\nreduces the numerical stability of the filter:\r\n\r\n\tfilter3.combination(filter1, filter2);\r\n\t// filter3.order will equal: filter1.order + filter2.order\r\n\t// The number of coefficients in filter3.a and filter3.b will be: order + 1\r\n\r\nThis file also contains a class called FrequencyResponse. You can use it to\r\ndetermine how much gain or attenuation a filter would apply to sounds at a\r\nspecific input frequency, as well as the phase offset:\r\n\r\n\tconst inputRadians: number = 2 * Math.PI * cutoffHz / sampleRate;\r\n\tconst response: FrequencyResponse = new FrequencyResponse();\r\n\tresponse.analyze(filter, inputRadians);\r\n\tconst gainResponse = response.magnitude();\r\n\tconst phaseResponse = response.angle();\r\n\r\nThat's basically all you need to know to use this code, but I'll also explain\r\nhow the analysis works.\r\n\r\nA first-order digital IIR filter is ordinarily implemented in a form like this:\r\n\r\n\toutput = inputCoeff * input + prevInputCoeff * prevInput - prevOutputCoeff * prevOutput;\r\n\r\nIf we adopt standard naming conventions for audio filters, this same code would\r\ninstead look like:\r\n\r\n\t// x0 = current input, x1 = prevInput, y0 = current output, y1 = prevOutput\r\n\ty0 = b0*x0 + b1*x1 - a1*y1;\r\n\r\nLeaving behind the world of code for a moment and entering the world of algebra,\r\nwe can rewrite this equation by moving all the output terms to the left side,\r\nand we can add a coefficient to the y0 term called a0 (which is typically\r\nnormalized to 1.0, which is why I didn't bother including it until now):\r\n\r\n\ta0*y0 + a1*y1 = b0*x0 + b1*x1\r\n\r\nThis is known as the symmetrical form of the filter, and it will help us analyze\r\nthe impact of the filter on an input audio signal. Here's a lesson that helped\r\nme understand the symmetrical form:\r\nhttps://web.archive.org/web/20200626183458/http://123.physics.ucdavis.edu/week_5_files/filters/digital_filter.pdf\r\n\r\nThe end of that lesson introduces a concept called the \"delay operator\" which\r\nlooks like \"z^-1\", which (magically) turns a sample into the previous sample\r\nwhen you multiply them. For example:\r\n\r\n\tx0 * z^-1 = x1\r\n\r\nThe lesson doesn't explain how it actually works. Audio signals aren't always\r\npredictable, which means that you generally can't do math on a single sample to\r\ncompute what the previous sample was. However, some audio signals ARE\r\npredictable, such as pure sine waves. Fortunately, all audio signals can be\r\nbroken down into a sum of independent sine waves. We can pick one sine wave at a\r\ntime, and use it to analyze the filter's impact on waves at that frequency. In\r\npractice, this tells us what the filter will do to unpredictable input samples\r\nthat contain a partial sine wave at that frequency.\r\n\r\nTechnically, you can't just use a single sine wave sample to determine the\r\nprevious sine wave sample, because each possible value is passed going upwards\r\nand downwards once per period and the direction is ambigous. This is where we\r\nneed to move into the complex number domain, where the real and imaginary\r\ncomponents can provide enough information to compute the previous position on\r\nthe input signal. So now instead of talking about sine waves, we're talking\r\nabout waves where the imaginary component is a sine wave and the real component\r\nis a cosine wave at the same frequency. Together, they trace around a unit\r\ncircle in the complex domain, and each sample is just a consistent rotation\r\napplied to the previous sample. The \"delay operator\" described above, z^-1, is\r\nthis same rotation applied in reverse, and it can be computed as:\r\n\r\n\tz^-1 = cos(radiansPerSample) - i * sin(radiansPerSample)\r\n\r\nMath nerds may be interested to know that \"Euler's formula\" was used here, but\r\nexplaining what that means is probably beyond the scope of this documentation\r\naside from noting that a complex number on the unit circle represents a 2D\r\nrotation that you can apply via multiplication.\r\n\r\nNow we can rewrite the symmetrical form using the delay operator and algebra:\r\n\r\n\ta0*y0 + a1*y0*z^-1 = b0*x0 + b1*x0*z^-1\r\n\ty0 * (a0 + a1*z^-1) = x0 * (b0 + b1*z^-1)\r\n\ty0 = x0 * (b0 + b1*z^-1) / (a0 + a1*z^-1)\r\n\ty0 / x0 = (b0 + b1*z^-1) / (a0 + a1*z^-1)\r\n\r\nThat last equation expresses the relationship between the input and output\r\nsignals (y0/x0) in terms of the filter coefficients and delay operator. At this\r\npoint, the specific values of the input and output samples don't even matter!\r\nThis is called the \"transfer function\", and it's conventionally named \"H(z)\":\r\n\r\n\tH(z) = (b0 + b1*z^-1) / (a0 + a1*z^-1)\r\n\r\nIf you plug in actual filter coefficients and express the delay operators as\r\ncomplex numbers with the appropriate trigonometry functions, the transfer\r\nfunction can be computed and produces a complex number that represents the\r\nrelationship between the input and output signals, whose magnitude represents\r\nthe volume gain (or attenuation) of signals at that frequency, and whose angle\r\nrepresents how much phase shift is applied by the filter to signals at that\r\nfrequency.\r\n\r\n(Note that in order to compute the transfer function, you'll need to do\r\nsomething about the complex number in the denominator. It turns out you can turn\r\nthe denominator into a real number by multiplying both the numerator and\r\ndenominator by the complex conjugate of the denominator, which is just the\r\ndenominator with the imaginary component negated.)\r\n\r\nFinally, I'll list some of the links that helped me understand filters and\r\nprovided some of the algorithms I that use here.\r\n\r\nHere's where I found accurate 2nd order low-pass, high-pass, and high-shelf\r\ndigital filters:\r\nhttps://web.archive.org/web/20120531011328/http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt\r\n\r\nThis page is how I found a link to the cookbook article above. It claims these\r\nfilters are Butterworth filters:\r\nhttp://web.archive.org/web/20191213120120/https://crypto.stanford.edu/~blynn/sound/analog.html\r\n\r\nI found the first-order digital Butterworth filter coefficients at:\r\nhttps://www.researchgate.net/publication/338022014_Digital_Implementation_of_Butterworth_First-Order_Filter_Type_IIR\r\n\r\nThis meta-paper helped me understand how to make 2nd order peak/notch filters:\r\nhttps://web.archive.org/web/20170706085655/https://www.thesounddesign.com/MIO/EQ-Coefficients.pdf\r\n\r\nBeepBox originally used simpler low-pass filters that I adapted from SFXR:\r\nhttps://www.drpetter.se/project_sfxr.html\r\nFor low cutoff frequencies, the simpler filters and the Butterworth filters are\r\nnearly identical, but when closer to the nyquist frequency the simpler filters\r\ncreate extra resonance.\r\n*/\r\n\r\nexport class FilterCoefficients {\r\n\tpublic readonly a: number[] = [1.0]; // output coefficients (negated, keep a[0]=1)\r\n\tpublic readonly b: number[] = [1.0]; // input coefficients\r\n\tpublic order: number = 0;\r\n\t\r\n\tpublic linearGain0thOrder(linearGain: number): void {\r\n\t\t//a[0] = 1.0; // a0 should always be normalized to 1.0, no need to assign it directly.\r\n\t\tthis.b[0] = linearGain;\r\n\t\tthis.order = 0;\r\n\t}\r\n\t\r\n\tpublic lowPass1stOrderButterworth(cornerRadiansPerSample: number): void {\r\n\t\t// First-order Butterworth low-pass filter according to:\r\n\t\t// https://www.researchgate.net/publication/338022014_Digital_Implementation_of_Butterworth_First-Order_Filter_Type_IIR\r\n\t\t// A butterworth filter is one where the amplitude response is equal to:\r\n\t\t// 1 / √(1 + (freq / cutoffFreq)^(2 * order))\r\n\t\tconst g: number = 1.0 / Math.tan(cornerRadiansPerSample * 0.5);\r\n\t\tconst a0: number = 1.0 + g;\r\n\t\tthis.a[1] = (1.0 - g) / a0;\r\n\t\tthis.b[1] = this.b[0] = 1 / a0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\tpublic lowPass1stOrderSimplified(cornerRadiansPerSample: number): void {\r\n\t\t// The output of this filter is nearly identical to the 1st order\r\n\t\t// Butterworth low-pass above, except if the cutoff is set to nyquist/3,\r\n\t\t// then the output is the same as the input, and if the cutoff is higher\r\n\t\t// than that, then the output actually resonates at high frequencies\r\n\t\t// instead of attenuating.\r\n\t\t// I'm guessing this filter was converted from analog to digital using\r\n\t\t// the \"matched z-transform\" method instead of the \"bilinear transform\"\r\n\t\t// method. The difference is that the bilinear transform warps\r\n\t\t// frequencies so that the lowpass response of zero at analogue ∞hz maps\r\n\t\t// to the digital nyquist frequency, whereas the matched z-transform\r\n\t\t// preserves the frequency of the filter response but also adds the\r\n\t\t// reflected response from above the nyquist frequency.\r\n\t\tconst g: number = 2.0 * Math.sin(cornerRadiansPerSample * 0.5);\r\n\t\tthis.a[1] = g - 1.0;\r\n\t\tthis.b[0] = g;\r\n\t\tthis.b[1] = 0.0;\r\n\t\t/*\r\n\t\t// Alternatively:\r\n\t\tconst g: number = 1.0 / (2.0 * Math.sin(cornerRadiansPerSample / 2));\r\n\t\tconst a0: number = g;\r\n\t\tthis.a[1] = (1.0 - g) / a0;\r\n\t\tthis.b[0] = 1.0 / a0;\r\n\t\tthis.b[1] = 0.0 / a0;\r\n\t\t*/\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\tpublic highPass1stOrderButterworth(cornerRadiansPerSample: number): void {\r\n\t\t// First-order Butterworth high-pass filter according to:\r\n\t\t// https://www.researchgate.net/publication/338022014_Digital_Implementation_of_Butterworth_First-Order_Filter_Type_IIR\r\n\t\tconst g: number = 1.0 / Math.tan(cornerRadiansPerSample * 0.5);\r\n\t\tconst a0: number = 1.0 + g;\r\n\t\tthis.a[1] = (1.0 - g) / a0;\r\n\t\tthis.b[0] = g / a0;\r\n\t\tthis.b[1] = -g / a0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t/*\r\n\tpublic highPass1stOrderSimplified(cornerRadiansPerSample: number): void {\r\n\t\t// The output of this filter is nearly identical to the 1st order\r\n\t\t// Butterworth high-pass above, except it resonates when the cutoff\r\n\t\t// appoaches the nyquist.\r\n\t\tconst g: number = 2.0 * Math.sin(cornerRadiansPerSample * 0.5);\r\n\t\tthis.a[1] = g - 1.0;\r\n\t\tthis.b[0] = 1.0;\r\n\t\tthis.b[1] = -1.0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t*/\r\n\tpublic highShelf1stOrder(cornerRadiansPerSample: number, shelfLinearGain: number): void {\r\n\t\t// I had trouble figuring this one out because I couldn't find any\r\n\t\t// online algorithms that I understood. There are 3 degrees of freedom\r\n\t\t// and I could narrow down a couple of them based on the desired gain at\r\n\t\t// DC and nyquist, but getting the cutoff frequency correct took a\r\n\t\t// little bit of trial and error in my attempts to interpret page 53 of\r\n\t\t// this chapter: http://www.music.mcgill.ca/~ich/classes/FiltersChap2.pdf\r\n\t\t// Obviously I don't fully understand the bilinear transform yet!\r\n\t\tconst tan: number = Math.tan(cornerRadiansPerSample * 0.5);\r\n\t\tconst sqrtGain: number = Math.sqrt(shelfLinearGain);\r\n\t\tconst g: number = (tan * sqrtGain - 1) / (tan * sqrtGain + 1.0);\r\n\t\tconst a0: number = 1.0;\r\n\t\tthis.a[1] = g / a0;\r\n\t\tthis.b[0] = (1.0 + g + shelfLinearGain * (1.0 - g)) / (2.0 * a0);\r\n\t\tthis.b[1] = (1.0 + g - shelfLinearGain * (1.0 - g)) / (2.0 * a0);\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\tpublic allPass1stOrderInvertPhaseAbove(cornerRadiansPerSample: number): void {\r\n\t\tconst g: number = (Math.sin(cornerRadiansPerSample) - 1.0) / Math.cos(cornerRadiansPerSample);\r\n\t\tthis.a[1] = g;\r\n\t\tthis.b[0] = g;\r\n\t\tthis.b[1] = 1.0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\t/*\r\n\t// I haven't found a practical use for this version of the all pass filter.\r\n\t// It seems to create a weird subharmonic when used in a delay feedback loop.\r\n\tpublic allPass1stOrderInvertPhaseBelow(cornerRadiansPerSample: number): void {\r\n\t\tconst g: number = (Math.sin(cornerRadiansPerSample) - 1.0) / Math.cos(cornerRadiansPerSample);\r\n\t\tthis.a[1] = g;\r\n\t\tthis.b[0] = -g;\r\n\t\tthis.b[1] = -1.0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t*/\r\n\t\r\n\tpublic allPass1stOrderFractionalDelay(delay: number) {\r\n\t\t// Very similar to allPass1stOrderInvertPhaseAbove, but configured\r\n\t\t// differently and for a different purpose! Useful for interpolating\r\n\t\t// between samples in a delay line.\r\n\t\tconst g: number = (1.0 - delay) / (1.0 + delay);\r\n\t\tthis.a[1] = g;\r\n\t\tthis.b[0] = g;\r\n\t\tthis.b[1] = 1.0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\tpublic lowPass2ndOrderButterworth(cornerRadiansPerSample: number, peakLinearGain: number): void {\r\n\t\t// This is Butterworth if peakLinearGain=1/√2 according to:\r\n\t\t// http://web.archive.org/web/20191213120120/https://crypto.stanford.edu/~blynn/sound/analog.html\r\n\t\t// An interesting property is that if peakLinearGain=1/16 then the\r\n\t\t// output resembles a first-order lowpass at a cutoff 4 octaves lower,\r\n\t\t// although it gets distorted near the nyquist.\r\n\t\tconst alpha: number = Math.sin(cornerRadiansPerSample) / (2.0 * peakLinearGain);\r\n\t\tconst cos: number = Math.cos(cornerRadiansPerSample);\r\n\t\tconst a0: number = 1.0 + alpha;\r\n\t\tthis.a[1] = -2.0*cos / a0;\r\n\t\tthis.a[2] = (1 - alpha) / a0;\r\n\t\tthis.b[2] = this.b[0] = (1 - cos) / (2.0*a0);\r\n\t\tthis.b[1] = (1 - cos) / a0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t\r\n\tpublic lowPass2ndOrderSimplified(cornerRadiansPerSample: number, peakLinearGain: number): void {\r\n\t\t// This filter is adapted from the one in the SFXR source code:\r\n\t\t// https://www.drpetter.se/project_sfxr.html\r\n\t\t// The output is nearly identical to the resonant Butterworth low-pass\r\n\t\t// above, except it resonates too much when the cutoff appoaches the\r\n\t\t// nyquist. If the resonance is set to zero and the cutoff is set to\r\n\t\t// nyquist/3, then the output is the same as the input.\r\n\t\tconst g: number = 2.0 * Math.sin(cornerRadiansPerSample / 2.0);\r\n\t\tconst filterResonance: number = 1.0 - 1.0 / (2.0 * peakLinearGain);\r\n\t\tconst feedback: number = filterResonance + filterResonance / (1.0 - g);\r\n\t\tthis.a[1] = 2.0*g + (g - 1.0) * g*feedback - 2.0;\r\n\t\tthis.a[2] = (g - 1.0) * (g - g*feedback - 1.0);\r\n\t\tthis.b[0] = g*g;\r\n\t\tthis.b[1] = 0;\r\n\t\tthis.b[2] = 0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t\r\n\tpublic highPass2ndOrderButterworth(cornerRadiansPerSample: number, peakLinearGain: number): void {\r\n\t\tconst alpha: number = Math.sin(cornerRadiansPerSample) / (2 * peakLinearGain);\r\n\t\tconst cos: number = Math.cos(cornerRadiansPerSample);\r\n\t\tconst a0: number = 1.0 + alpha;\r\n\t\tthis.a[1] = -2.0*cos / a0;\r\n\t\tthis.a[2] = (1.0 - alpha) / a0;\r\n\t\tthis.b[2] = this.b[0] = (1.0 + cos) / (2.0*a0);\r\n\t\tthis.b[1] = -(1.0 + cos) / a0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t/*\r\n\tpublic highPass2ndOrderSimplified(cornerRadiansPerSample: number, peakLinearGain: number): void {\r\n\t\tconst g: number = 2.0 * Math.sin(cornerRadiansPerSample * 0.5);\r\n\t\tconst filterResonance: number = 1.0 - 1.0 / (2.0 * peakLinearGain);\r\n\t\tconst feedback: number = filterResonance + filterResonance / (1.0 - g);\r\n\t\tthis.a[1] = 2.0*g + (g - 1.0) * g*feedback - 2.0;\r\n\t\tthis.a[2] = (g - 1.0) * (g - g*feedback - 1.0);\r\n\t\tthis.b[0] = 1.0;\r\n\t\tthis.b[1] = -2.0;\r\n\t\tthis.b[2] = 1.0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t*/\r\n\t\r\n\tpublic highShelf2ndOrder(cornerRadiansPerSample: number, shelfLinearGain: number, slope: number): void {\r\n\t\tconst A: number = Math.sqrt(shelfLinearGain);\r\n\t\tconst c: number = Math.cos(cornerRadiansPerSample);\r\n\t\tconst Aplus: number = A + 1.0;\r\n\t\tconst Aminus: number = A - 1.0;\r\n\t\tconst alpha: number = Math.sin(cornerRadiansPerSample) * 0.5 * Math.sqrt((Aplus / A) * (1.0 / slope - 1.0) + 2.0);\r\n\t\tconst sqrtA2Alpha: number = 2.0 * Math.sqrt(A) * alpha;\r\n\t\tconst a0: number =   (Aplus  - Aminus * c + sqrtA2Alpha);\r\n\t\tthis.a[1] =  2 *     (Aminus - Aplus  * c              ) / a0;\r\n\t\tthis.a[2] =          (Aplus  - Aminus * c - sqrtA2Alpha) / a0;\r\n\t\tthis.b[0] =      A * (Aplus  + Aminus * c + sqrtA2Alpha) / a0;\r\n\t\tthis.b[1] = -2 * A * (Aminus + Aplus  * c              ) / a0;\r\n\t\tthis.b[2] =      A * (Aplus  + Aminus * c - sqrtA2Alpha) / a0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t\r\n\tpublic peak2ndOrder(cornerRadiansPerSample: number, peakLinearGain: number, bandWidthScale: number): void {\r\n\t\tconst sqrtGain: number = Math.sqrt(peakLinearGain);\r\n\t\tconst bandWidth: number = bandWidthScale * cornerRadiansPerSample / (sqrtGain >= 1 ? sqrtGain : 1/sqrtGain);\r\n\t\t//const bandWidth: number = bandWidthScale * cornerRadiansPerSample / Math.max(sqrtGain, 1.0);\r\n\t\tconst alpha: number = Math.tan(bandWidth * 0.5);\r\n\t\tconst a0: number = 1.0 + alpha / sqrtGain;\r\n\t\tthis.b[0] = (1.0 + alpha * sqrtGain) / a0;\r\n\t\tthis.b[1] = this.a[1] = -2.0 * Math.cos(cornerRadiansPerSample) / a0;\r\n\t\tthis.b[2] = (1.0 - alpha * sqrtGain) / a0;\r\n\t\tthis.a[2] = (1.0 - alpha / sqrtGain) / a0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t/*\r\n\t// Create a higher order filter by combining two lower order filters.\r\n\t// However, making high order filters in this manner results in instability.\r\n\t// It is recommended to apply the 2nd order filters (biquads) in sequence instead.\r\n\tpublic combination(filter1: FilterCoefficients, filter2: FilterCoefficients): void {\r\n\t\tthis.order = filter1.order + filter2.order;\r\n\t\tfor (let i: number = 0; i <= this.order; i++) {\r\n\t\t\tthis.a[i] = 0.0;\r\n\t\t\tthis.b[i] = 0.0;\r\n\t\t}\r\n\t\tfor (let i: number = 0; i <= filter1.order; i++) {\r\n\t\t\tfor (let j: number = 0; j <= filter2.order; j++) {\r\n\t\t\t\tthis.a[i + j] += filter1.a[i] * filter2.a[j];\r\n\t\t\t\tthis.b[i + j] += filter1.b[i] * filter2.b[j];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic scaledDifference(other: FilterCoefficients, scale: number): void {\r\n\t\tif (other.order != this.order) throw new Error();\r\n\t\tfor (let i: number = 0; i <= this.order; i++) {\r\n\t\t\tthis.a[i] = (this.a[i] - other.a[i]) * scale;\r\n\t\t\tthis.b[i] = (this.b[i] - other.b[i]) * scale;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic copy(other: FilterCoefficients): void {\r\n\t\tthis.order = other.order;\r\n\t\tfor (let i: number = 0; i <= this.order; i++) {\r\n\t\t\tthis.a[i] = other.a[i];\r\n\t\t\tthis.b[i] = other.b[i];\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\nexport class FrequencyResponse {\r\n\tpublic real: number = 0.0;\r\n\tpublic imag: number = 0.0;\r\n\tpublic denom: number = 1.0;\r\n\t\r\n\tpublic analyze(filter: FilterCoefficients, radiansPerSample: number): void {\r\n\t\tthis.analyzeComplex(filter, Math.cos(radiansPerSample), Math.sin(radiansPerSample));\r\n\t}\r\n\t\r\n\tpublic analyzeComplex(filter: FilterCoefficients, real: number, imag: number): void {\r\n\t\tconst a: number[] = filter.a;\r\n\t\tconst b: number[] = filter.b;\r\n\t\tconst realZ1: number = real;\r\n\t\tconst imagZ1: number = -imag;\r\n\t\tlet realNum: number = b[0] + b[1] * realZ1;\r\n\t\tlet imagNum: number = b[1] * imagZ1;\r\n\t\tlet realDenom: number = 1.0 + a[1] * realZ1;\r\n\t\tlet imagDenom: number = a[1] * imagZ1;\r\n\t\tlet realZ: number = realZ1;\r\n\t\tlet imagZ: number = imagZ1;\r\n\t\tfor (let i: number = 2; i <= filter.order; i++) {\r\n\t\t\tconst realTemp: number = realZ * realZ1 - imagZ * imagZ1;\r\n\t\t\tconst imagTemp: number = realZ * imagZ1 + imagZ * realZ1;\r\n\t\t\trealZ = realTemp;\r\n\t\t\timagZ = imagTemp;\r\n\t\t\trealNum += b[i] * realZ;\r\n\t\t\timagNum += b[i] * imagZ;\r\n\t\t\trealDenom += a[i] * realZ;\r\n\t\t\timagDenom += a[i] * imagZ;\r\n\t\t}\r\n\t\tthis.denom = realDenom * realDenom + imagDenom * imagDenom;\r\n\t\tthis.real = realNum * realDenom + imagNum * imagDenom;\r\n\t\tthis.imag = imagNum * realDenom - realNum * imagDenom;\r\n\t}\r\n\t\r\n\tpublic magnitude(): number {\r\n\t\treturn Math.sqrt(this.real * this.real + this.imag * this.imag) / this.denom;\r\n\t}\r\n\t\r\n\tpublic angle(): number {\r\n\t\treturn Math.atan2(this.imag, this.real);\r\n\t}\r\n}\r\n\r\nexport class DynamicBiquadFilter {\r\n\tpublic a1: number = 0.0;\r\n\tpublic a2: number = 0.0;\r\n\tpublic b0: number = 1.0;\r\n\tpublic b1: number = 0.0;\r\n\tpublic b2: number = 0.0;\r\n\tpublic a1Delta: number = 0.0;\r\n\tpublic a2Delta: number = 0.0;\r\n\tpublic b0Delta: number = 0.0;\r\n\tpublic b1Delta: number = 0.0;\r\n\tpublic b2Delta: number = 0.0;\r\n\tpublic output1: number = 0.0;\r\n\tpublic output2: number = 0.0;\r\n\t\r\n\t// Some filter types are more stable when interpolating between coefficients\r\n\t// if the \"b\" coefficient interpolation is multiplicative. Don't enable this\r\n\t// for filter types where the \"b\" coefficients might change sign!\r\n\tpublic useMultiplicativeInputCoefficients: boolean = false;\r\n\t\r\n\tpublic resetOutput(): void {\r\n\t\tthis.output1 = 0.0;\r\n\t\tthis.output2 = 0.0;\r\n\t}\r\n\t\r\n\tpublic loadCoefficientsWithGradient(start: FilterCoefficients, end: FilterCoefficients, deltaRate: number, useMultiplicativeInputCoefficients: boolean): void {\r\n\t\tif (start.order != 2 || end.order != 2) throw new Error();\r\n\t\tthis.a1 = start.a[1];\r\n\t\tthis.a2 = start.a[2];\r\n\t\tthis.b0 = start.b[0];\r\n\t\tthis.b1 = start.b[1];\r\n\t\tthis.b2 = start.b[2];\r\n\t\tthis.a1Delta = (end.a[1] - start.a[1]) * deltaRate;\r\n\t\tthis.a2Delta = (end.a[2] - start.a[2]) * deltaRate;\r\n\t\tif (useMultiplicativeInputCoefficients) {\r\n\t\t\tthis.b0Delta = Math.pow(end.b[0] / start.b[0], deltaRate);\r\n\t\t\tthis.b1Delta = Math.pow(end.b[1] / start.b[1], deltaRate);\r\n\t\t\tthis.b2Delta = Math.pow(end.b[2] / start.b[2], deltaRate);\r\n\t\t} else {\r\n\t\t\tthis.b0Delta = (end.b[0] - start.b[0]) * deltaRate;\r\n\t\t\tthis.b1Delta = (end.b[1] - start.b[1]) * deltaRate;\r\n\t\t\tthis.b2Delta = (end.b[2] - start.b[2]) * deltaRate;\r\n\t\t}\r\n\t\tthis.useMultiplicativeInputCoefficients = useMultiplicativeInputCoefficients;\r\n\t}\r\n}\r\n\r\n// Filters are typically designed as analog filters first, then converted to\r\n// digital filters using one of two methods: the \"matched z-transform\" or the\r\n// \"bilinear transform\". The \"bilinear transform\" does a better job of\r\n// preserving the magnitudes of the frequency response, but warps the frequency\r\n// range such that the nyquist frequency of the digital filter (π) maps to the\r\n// infinity frequency of the analog filter. You can use the below functions to\r\n// manually perform this warping in either direction.\r\nexport function warpNyquistToInfinity(radians: number): number {\r\n\treturn 2.0 * Math.tan(radians * 0.5);\r\n}\r\nexport function warpInfinityToNyquist(radians: number): number {\r\n\treturn 2.0 * Math.atan(radians * 0.5);\r\n}\r\n","// Copyright (c) 2012-2022 John Nesky and contributing authors, distributed under the MIT license, see accompanying the LICENSE.md file.\r\n\r\nimport {Dictionary, DictionaryArray, FilterType, SustainType, EnvelopeType, InstrumentType, EffectType, EnvelopeComputeIndex, Transition, Unison, Chord, Vibrato, Envelope, AutomationTarget, Config, getDrumWave, drawNoiseSpectrum, getArpeggioPitchIndex, performIntegral, getPulseWidthRatio, effectsIncludeTransition, effectsIncludeChord, effectsIncludePitchShift, effectsIncludeDetune, effectsIncludeVibrato, effectsIncludeNoteFilter, effectsIncludeDistortion, effectsIncludeBitcrusher, effectsIncludePanning, effectsIncludeChorus, effectsIncludeEcho, effectsIncludeReverb} from \"./SynthConfig\";\r\nimport {scaleElementsByFactor, inverseRealFourierTransform} from \"./FFT\";\r\nimport {Deque} from \"./Deque\";\r\nimport {FilterCoefficients, FrequencyResponse, DynamicBiquadFilter, warpInfinityToNyquist} from \"./filtering\";\r\n\r\ndeclare global {\r\n\tinterface Window {\r\n\t\tAudioContext: any;\r\n\t\twebkitAudioContext: any;\r\n\t}\r\n}\r\n\r\nconst epsilon: number = (1.0e-24); // For detecting and avoiding float denormals, which have poor performance.\r\n\r\n// For performance debugging:\r\n//let samplesAccumulated: number = 0;\r\n//let samplePerformance: number = 0;\r\n\r\nexport function clamp(min: number, max: number, val: number): number {\r\n\tmax = max - 1;\r\n\tif (val <= max) {\r\n\t\tif (val >= min) return val;\r\n\t\telse return min;\r\n\t} else {\r\n\t\treturn max;\r\n\t}\r\n}\r\n\r\nfunction validateRange(min: number, max: number, val: number): number {\r\n\tif (min <= val && val <= max) return val;\r\n\tthrow new Error(`Value ${val} not in range [${min}, ${max}]`);\r\n}\r\n\r\nconst enum CharCode {\r\n\tSPACE = 32,\r\n\tHASH = 35,\r\n\tPERCENT = 37,\r\n\tAMPERSAND = 38,\r\n\tPLUS = 43,\r\n\tDASH = 45,\r\n\tDOT = 46,\r\n\tNUM_0 = 48,\r\n\tNUM_1 = 49,\r\n\tNUM_2 = 50,\r\n\tNUM_3 = 51,\r\n\tNUM_4 = 52,\r\n\tNUM_5 = 53,\r\n\tNUM_6 = 54,\r\n\tNUM_7 = 55,\r\n\tNUM_8 = 56,\r\n\tNUM_9 = 57,\r\n\tEQUALS = 61,\r\n\tA =  65,\r\n\tB =  66,\r\n\tC =  67,\r\n\tD =  68,\r\n\tE =  69,\r\n\tF =  70,\r\n\tG =  71,\r\n\tH =  72,\r\n\tI =  73,\r\n\tJ =  74,\r\n\tK =  75,\r\n\tL =  76,\r\n\tM =  77,\r\n\tN =  78,\r\n\tO =  79,\r\n\tP =  80,\r\n\tQ =  81,\r\n\tR =  82,\r\n\tS =  83,\r\n\tT =  84,\r\n\tU =  85,\r\n\tV =  86,\r\n\tW =  87,\r\n\tX =  88,\r\n\tY =  89,\r\n\tZ =  90,\r\n\tUNDERSCORE = 95,\r\n\ta =  97,\r\n\tb =  98,\r\n\tc =  99,\r\n\td = 100,\r\n\te = 101,\r\n\tf = 102,\r\n\tg = 103,\r\n\th = 104,\r\n\ti = 105,\r\n\tj = 106,\r\n\tk = 107,\r\n\tl = 108,\r\n\tm = 109,\r\n\tn = 110,\r\n\to = 111,\r\n\tp = 112,\r\n\tq = 113,\r\n\tr = 114,\r\n\ts = 115,\r\n\tt = 116,\r\n\tu = 117,\r\n\tv = 118,\r\n\tw = 119,\r\n\tx = 120,\r\n\ty = 121,\r\n\tz = 122,\r\n\tLEFT_CURLY_BRACE = 123,\r\n\tRIGHT_CURLY_BRACE = 125,\r\n}\r\n\r\nconst enum SongTagCode {\r\n\tbeatCount           = CharCode.a, // added in BeepBox URL version 2\r\n\tbars                = CharCode.b, // added in BeepBox URL version 2\r\n\tvibrato             = CharCode.c, // added in BeepBox URL version 2, DEPRECATED\r\n\tfadeInOut           = CharCode.d, // added in BeepBox URL version 3 for transition, switched to fadeInOut in 9\r\n\tloopEnd             = CharCode.e, // added in BeepBox URL version 2\r\n\teqFilter            = CharCode.f, // added in BeepBox URL version 3\r\n\tbarCount            = CharCode.g, // added in BeepBox URL version 3\r\n\tunison              = CharCode.h, // added in BeepBox URL version 2\r\n\tinstrumentCount     = CharCode.i, // added in BeepBox URL version 3\r\n\tpatternCount        = CharCode.j, // added in BeepBox URL version 3\r\n\tkey                 = CharCode.k, // added in BeepBox URL version 2\r\n\tloopStart           = CharCode.l, // added in BeepBox URL version 2\r\n\treverb              = CharCode.m, // added in BeepBox URL version 5, DEPRECATED\r\n\tchannelCount        = CharCode.n, // added in BeepBox URL version 6\r\n\tchannelOctave       = CharCode.o, // added in BeepBox URL version 3\r\n\tpatterns            = CharCode.p, // added in BeepBox URL version 2\r\n\teffects             = CharCode.q, // added in BeepBox URL version 7\r\n\trhythm              = CharCode.r, // added in BeepBox URL version 2\r\n\tscale               = CharCode.s, // added in BeepBox URL version 2\r\n\ttempo               = CharCode.t, // added in BeepBox URL version 2\r\n\tpreset              = CharCode.u, // added in BeepBox URL version 7\r\n\tvolume              = CharCode.v, // added in BeepBox URL version 2\r\n\twave                = CharCode.w, // added in BeepBox URL version 2\r\n\tsupersaw            = CharCode.x, // added in BeepBox URL version 9\r\n\tfilterResonance     = CharCode.y, // added in BeepBox URL version 7, DEPRECATED\r\n\tdrumsetEnvelopes    = CharCode.z, // added in BeepBox URL version 7 for filter envelopes, still used for drumset envelopes\r\n\talgorithm           = CharCode.A, // added in BeepBox URL version 6\r\n\tfeedbackAmplitude   = CharCode.B, // added in BeepBox URL version 6\r\n\tchord               = CharCode.C, // added in BeepBox URL version 7, DEPRECATED\r\n//\t                    = CharCode.D, // added in JummBox URL version 3(?) for detune, DEPRECATED\r\n\tenvelopes           = CharCode.E, // added in BeepBox URL version 6 for FM operator envelopes, repurposed in 9 for general envelopes.\r\n\tfeedbackType        = CharCode.F, // added in BeepBox URL version 6\r\n//\t                    = CharCode.G, // added in JummBox URL version 3 for arpeggioSpeed, DEPRECATED\r\n\tharmonics           = CharCode.H, // added in BeepBox URL version 7\r\n\tstringSustain       = CharCode.I, // added in BeepBox URL version 9\r\n//\t                    = CharCode.J,\r\n//\t                    = CharCode.K,\r\n\tpan                 = CharCode.L, // added between 8 and 9, DEPRECATED\r\n//\t                    = CharCode.M, // added in JummBox URL version 1(?) for customChipWave\r\n//\t                    = CharCode.N, // added in JummBox URL version 1(?) for songTitle\r\n//\t                    = CharCode.O, // added in JummBox URL version 3(?) for limiterSettings\r\n\toperatorAmplitudes  = CharCode.P, // added in BeepBox URL version 6\r\n\toperatorFrequencies = CharCode.Q, // added in BeepBox URL version 6\r\n//\t                    = CharCode.R, // added in JummBox URL version 4 for operatorWaves\r\n\tspectrum            = CharCode.S, // added in BeepBox URL version 7\r\n\tstartInstrument     = CharCode.T, // added in BeepBox URL version 6\r\n//\t                    = CharCode.U, // added in JummBox URL version 4(?) for channelNames\r\n\tfeedbackEnvelope    = CharCode.V, // added in BeepBox URL version 6, DEPRECATED\r\n\tpulseWidth          = CharCode.W, // added in BeepBox URL version 7\r\n//\t                    = CharCode.X, // added in JummBox URL version 4 for aliases, DEPRECATED\r\n//\t                    = CharCode.Y,\r\n//\t                    = CharCode.Z,\r\n//\t                    = CharCode.NUM_0,\r\n//\t                    = CharCode.NUM_1,\r\n//\t                    = CharCode.NUM_2,\r\n//\t                    = CharCode.NUM_3,\r\n//\t                    = CharCode.NUM_4,\r\n//\t                    = CharCode.NUM_5,\r\n//\t                    = CharCode.NUM_6,\r\n//\t                    = CharCode.NUM_7,\r\n//\t                    = CharCode.NUM_8,\r\n//\t                    = CharCode.NUM_9,\r\n//\t                    = CharCode.DASH,\r\n//\t                    = CharCode.UNDERSCORE,\r\n}\r\n\r\nconst base64IntToCharCode: ReadonlyArray<number> = [48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,45,95];\r\nconst base64CharCodeToInt: ReadonlyArray<number> = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,62,62,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,0,0,0,0,63,0,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,0,0,0,0,0]; // 62 could be represented by either \"-\" or \".\" for historical reasons. New songs should use \"-\".\r\n\r\nclass BitFieldReader {\r\n\tprivate _bits: number[] = [];\r\n\tprivate _readIndex: number = 0;\r\n\t\r\n\tconstructor(source: string, startIndex: number, stopIndex: number) {\r\n\t\tfor (let i: number = startIndex; i < stopIndex; i++) {\r\n\t\t\tconst value: number = base64CharCodeToInt[source.charCodeAt(i)];\r\n\t\t\tthis._bits.push((value >> 5) & 0x1);\r\n\t\t\tthis._bits.push((value >> 4) & 0x1);\r\n\t\t\tthis._bits.push((value >> 3) & 0x1);\r\n\t\t\tthis._bits.push((value >> 2) & 0x1);\r\n\t\t\tthis._bits.push((value >> 1) & 0x1);\r\n\t\t\tthis._bits.push( value       & 0x1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic read(bitCount: number): number {\r\n\t\tlet result: number = 0;\r\n\t\twhile (bitCount > 0) {\r\n\t\t\tresult = result << 1;\r\n\t\t\tresult += this._bits[this._readIndex++];\r\n\t\t\tbitCount--;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\tpublic readLongTail(minValue: number, minBits: number): number {\r\n\t\tlet result: number = minValue;\r\n\t\tlet numBits: number = minBits;\r\n\t\twhile (this._bits[this._readIndex++]) {\r\n\t\t\tresult += 1 << numBits;\r\n\t\t\tnumBits++;\r\n\t\t}\r\n\t\twhile (numBits > 0) {\r\n\t\t\tnumBits--;\r\n\t\t\tif (this._bits[this._readIndex++]) {\r\n\t\t\t\tresult += 1 << numBits;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\tpublic readPartDuration(): number {\r\n\t\treturn this.readLongTail(1, 3);\r\n\t}\r\n\t\r\n\tpublic readLegacyPartDuration(): number {\r\n\t\treturn this.readLongTail(1, 2);\r\n\t}\r\n\t\r\n\tpublic readPinCount(): number {\r\n\t\treturn this.readLongTail(1, 0);\r\n\t}\r\n\t\r\n\tpublic readPitchInterval(): number {\r\n\t\tif (this.read(1)) {\r\n\t\t\treturn -this.readLongTail(1, 3);\r\n\t\t} else {\r\n\t\t\treturn this.readLongTail(1, 3);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass BitFieldWriter {\r\n\tprivate _index: number = 0;\r\n\tprivate _bits: number[] = [];\r\n\t\r\n\tpublic clear() {\r\n\t\tthis._index = 0;\r\n\t}\r\n\t\r\n\tpublic write(bitCount: number, value: number): void {\r\n\t\tbitCount--;\r\n\t\twhile (bitCount >= 0) {\r\n\t\t\tthis._bits[this._index++] = (value >>> bitCount) & 1;\r\n\t\t\tbitCount--;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic writeLongTail(minValue: number, minBits: number, value: number): void {\r\n\t\tif (value < minValue) throw new Error(\"value out of bounds\");\r\n\t\tvalue -= minValue;\r\n\t\tlet numBits: number = minBits;\r\n\t\twhile (value >= (1 << numBits)) {\r\n\t\t\tthis._bits[this._index++] = 1;\r\n\t\t\tvalue -= 1 << numBits;\r\n\t\t\tnumBits++;\r\n\t\t}\r\n\t\tthis._bits[this._index++] = 0;\r\n\t\twhile (numBits > 0) {\r\n\t\t\tnumBits--;\r\n\t\t\tthis._bits[this._index++] = (value >>> numBits) & 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic writePartDuration(value: number): void {\r\n\t\tthis.writeLongTail(1, 3, value);\r\n\t}\r\n\t\r\n\tpublic writePinCount(value: number): void {\r\n\t\tthis.writeLongTail(1, 0, value);\r\n\t}\r\n\t\r\n\tpublic writePitchInterval(value: number): void {\r\n\t\tif (value < 0) {\r\n\t\t\tthis.write(1, 1); // sign\r\n\t\t\tthis.writeLongTail(1, 3, -value);\r\n\t\t} else {\r\n\t\t\tthis.write(1, 0); // sign\r\n\t\t\tthis.writeLongTail(1, 3, value);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic concat(other: BitFieldWriter): void {\r\n\t\tfor (let i: number = 0; i < other._index; i++) {\r\n\t\t\tthis._bits[this._index++] = other._bits[i];\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic encodeBase64(buffer: number[]): number[] {\r\n\t\tfor (let i: number = 0; i < this._index; i += 6) {\r\n\t\t\tconst value: number = (this._bits[i] << 5) | (this._bits[i+1] << 4) | (this._bits[i+2] << 3) | (this._bits[i+3] << 2) | (this._bits[i+4] << 1) | this._bits[i+5];\r\n\t\t\tbuffer.push(base64IntToCharCode[value]);\r\n\t\t}\r\n\t\treturn buffer;\r\n\t}\r\n\t\r\n\tpublic lengthBase64(): number {\r\n\t\treturn Math.ceil(this._index / 6);\r\n\t}\r\n}\r\n\r\nexport interface NotePin {\r\n\tinterval: number;\r\n\ttime: number;\r\n\tsize: number;\r\n}\r\n\r\nexport function makeNotePin(interval: number, time: number, size: number): NotePin {\r\n\treturn {interval: interval, time: time, size: size};\r\n}\r\n\r\nexport class Note {\r\n\tpublic pitches: number[];\r\n\tpublic pins: NotePin[];\r\n\tpublic start: number;\r\n\tpublic end: number;\r\n\tpublic continuesLastPattern: boolean;\r\n\t\r\n\tpublic constructor(pitch: number, start: number, end: number, size: number, fadeout: boolean = false) {\r\n\t\tthis.pitches = [pitch];\r\n\t\tthis.pins = [makeNotePin(0, 0, size), makeNotePin(0, end - start, fadeout ? 0 : size)];\r\n\t\tthis.start = start;\r\n\t\tthis.end = end;\r\n\t\tthis.continuesLastPattern = false;\r\n\t}\r\n\t\r\n\tpublic pickMainInterval(): number {\r\n\t\tlet longestFlatIntervalDuration: number = 0;\r\n\t\tlet mainInterval: number = 0;\r\n\t\tfor (let pinIndex: number = 1; pinIndex < this.pins.length; pinIndex++) {\r\n\t\t\tconst pinA: NotePin = this.pins[pinIndex - 1];\r\n\t\t\tconst pinB: NotePin = this.pins[pinIndex];\r\n\t\t\tif (pinA.interval == pinB.interval) {\r\n\t\t\t\tconst duration: number = pinB.time - pinA.time;\r\n\t\t\t\tif (longestFlatIntervalDuration < duration) {\r\n\t\t\t\t\tlongestFlatIntervalDuration = duration;\r\n\t\t\t\t\tmainInterval = pinA.interval;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (longestFlatIntervalDuration == 0) {\r\n\t\t\tlet loudestSize: number = 0;\r\n\t\t\tfor (let pinIndex: number = 0; pinIndex < this.pins.length; pinIndex++) {\r\n\t\t\t\tconst pin: NotePin = this.pins[pinIndex];\r\n\t\t\t\tif (loudestSize < pin.size) {\r\n\t\t\t\t\tloudestSize = pin.size;\r\n\t\t\t\t\tmainInterval = pin.interval;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn mainInterval;\r\n\t}\r\n\t\r\n\tpublic clone(): Note {\r\n\t\tconst newNote: Note = new Note(-1, this.start, this.end, Config.noteSizeMax);\r\n\t\tnewNote.pitches = this.pitches.concat();\r\n\t\tnewNote.pins = [];\r\n\t\tfor (const pin of this.pins) {\r\n\t\t\tnewNote.pins.push(makeNotePin(pin.interval, pin.time, pin.size));\r\n\t\t}\r\n\t\tnewNote.continuesLastPattern = this.continuesLastPattern;\r\n\t\treturn newNote;\r\n\t}\r\n\t\r\n\tpublic getEndPinIndex(part: number): number {\r\n\t\tlet endPinIndex: number;\r\n\t\tfor (endPinIndex = 1; endPinIndex < this.pins.length - 1; endPinIndex++) {\r\n\t\t\tif (this.pins[endPinIndex].time + this.start > part) break;\r\n\t\t}\r\n\t\treturn endPinIndex;\r\n\t}\r\n}\r\n\r\nexport class Pattern {\r\n\tpublic notes: Note[] = [];\r\n\tpublic readonly instruments: number[] = [0];\r\n\t\r\n\tpublic cloneNotes(): Note[] {\r\n\t\tconst result: Note[] = [];\r\n\t\tfor (const note of this.notes) {\r\n\t\t\tresult.push(note.clone());\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\tpublic reset(): void {\r\n\t\tthis.notes.length = 0;\r\n\t\tthis.instruments[0] = 0;\r\n\t\tthis.instruments.length = 1;\r\n\t}\r\n\t\r\n\tpublic toJsonObject(song: Song): any {\r\n\t\tconst noteArray: Object[] = [];\r\n\t\tfor (const note of this.notes) {\r\n\t\t\tconst pointArray: Object[] = [];\r\n\t\t\tfor (const pin of note.pins) {\r\n\t\t\t\tpointArray.push({\r\n\t\t\t\t\t\"tick\": (pin.time + note.start) * Config.rhythms[song.rhythm].stepsPerBeat / Config.partsPerBeat,\r\n\t\t\t\t\t\"pitchBend\": pin.interval,\r\n\t\t\t\t\t\"volume\": Math.round(pin.size * 100 / 3),\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst noteObject: any = {\r\n\t\t\t\t\"pitches\": note.pitches,\r\n\t\t\t\t\"points\": pointArray,\r\n\t\t\t};\r\n\t\t\tif (note.start == 0) {\r\n\t\t\t\tnoteObject[\"continuesLastPattern\"] = note.continuesLastPattern;\r\n\t\t\t}\r\n\t\t\tnoteArray.push(noteObject);\r\n\t\t}\r\n\t\t\r\n\t\tconst patternObject: any = {\"notes\": noteArray};\r\n\t\tif (song.patternInstruments) {\r\n\t\t\tpatternObject[\"instruments\"] = this.instruments.map(i => i + 1);\r\n\t\t}\r\n\t\treturn patternObject;\r\n\t}\r\n\t\r\n\tpublic fromJsonObject(patternObject: any, song: Song, channel: Channel, importedPartsPerBeat: number, isNoiseChannel: boolean): void {\r\n\t\tif (song.patternInstruments) {\r\n\t\t\tif (Array.isArray(patternObject[\"instruments\"])) {\r\n\t\t\t\tconst instruments: any[] = patternObject[\"instruments\"];\r\n\t\t\t\tconst instrumentCount: number = clamp(Config.instrumentCountMin, song.getMaxInstrumentsPerPatternForChannel(channel) + 1, instruments.length);\r\n\t\t\t\tfor (let j: number = 0; j < instrumentCount; j++) {\r\n\t\t\t\t\tthis.instruments[j] = clamp(0, channel.instruments.length, (instruments[j] | 0) - 1);\r\n\t\t\t\t}\r\n\t\t\t\tthis.instruments.length = instrumentCount;\r\n\t\t\t} else {\r\n\t\t\t\tthis.instruments[0] = clamp(0, channel.instruments.length, (patternObject[\"instrument\"] | 0) - 1);\r\n\t\t\t\tthis.instruments.length = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (patternObject[\"notes\"] && patternObject[\"notes\"].length > 0) {\r\n\t\t\tconst maxNoteCount: number = Math.min(song.beatsPerBar * Config.partsPerBeat, patternObject[\"notes\"].length >>> 0);\r\n\t\t\t\r\n\t\t\t// TODO: Consider supporting notes specified in any timing order, sorting them and truncating as necessary.\r\n\t\t\tlet tickClock: number = 0;\r\n\t\t\tfor (let j: number = 0; j < patternObject[\"notes\"].length; j++) {\r\n\t\t\t\tif (j >= maxNoteCount) break;\r\n\t\t\t\t\r\n\t\t\t\tconst noteObject = patternObject[\"notes\"][j];\r\n\t\t\t\tif (!noteObject || !noteObject[\"pitches\"] || !(noteObject[\"pitches\"].length >= 1) || !noteObject[\"points\"] || !(noteObject[\"points\"].length >= 2)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tconst note: Note = new Note(0, 0, 0, 0);\r\n\t\t\t\tnote.pitches = [];\r\n\t\t\t\tnote.pins = [];\r\n\t\t\t\t\r\n\t\t\t\tfor (let k: number = 0; k < noteObject[\"pitches\"].length; k++) {\r\n\t\t\t\t\tconst pitch: number = noteObject[\"pitches\"][k] | 0;\r\n\t\t\t\t\tif (note.pitches.indexOf(pitch) != -1) continue;\r\n\t\t\t\t\tnote.pitches.push(pitch);\r\n\t\t\t\t\tif (note.pitches.length >= Config.maxChordSize) break;\r\n\t\t\t\t}\r\n\t\t\t\tif (note.pitches.length < 1) continue;\r\n\t\t\t\t\r\n\t\t\t\tlet noteClock: number = tickClock;\r\n\t\t\t\tlet startInterval: number = 0;\r\n\t\t\t\tfor (let k: number = 0; k < noteObject[\"points\"].length; k++) {\r\n\t\t\t\t\tconst pointObject: any = noteObject[\"points\"][k];\r\n\t\t\t\t\tif (pointObject == undefined || pointObject[\"tick\"] == undefined) continue;\r\n\t\t\t\t\tconst interval: number = (pointObject[\"pitchBend\"] == undefined) ? 0 : (pointObject[\"pitchBend\"] | 0);\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst time: number = Math.round((+pointObject[\"tick\"]) * Config.partsPerBeat / importedPartsPerBeat);\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst size: number = (pointObject[\"volume\"] == undefined) ? 3 : Math.max(0, Math.min(3, Math.round((pointObject[\"volume\"] | 0) * 3 / 100)));\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (time > song.beatsPerBar * Config.partsPerBeat) continue;\r\n\t\t\t\t\tif (note.pins.length == 0) {\r\n\t\t\t\t\t\tif (time < noteClock) continue;\r\n\t\t\t\t\t\tnote.start = time;\r\n\t\t\t\t\t\tstartInterval = interval;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (time <= noteClock) continue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnoteClock = time;\r\n\t\t\t\t\t\r\n\t\t\t\t\tnote.pins.push(makeNotePin(interval - startInterval, time - note.start, size));\r\n\t\t\t\t}\r\n\t\t\t\tif (note.pins.length < 2) continue;\r\n\t\t\t\t\r\n\t\t\t\tnote.end = note.pins[note.pins.length - 1].time + note.start;\r\n\t\t\t\t\r\n\t\t\t\tconst maxPitch: number = isNoiseChannel ? Config.drumCount - 1 : Config.maxPitch;\r\n\t\t\t\tlet lowestPitch: number = maxPitch;\r\n\t\t\t\tlet highestPitch: number = 0;\r\n\t\t\t\tfor (let k: number = 0; k < note.pitches.length; k++) {\r\n\t\t\t\t\tnote.pitches[k] += startInterval;\r\n\t\t\t\t\tif (note.pitches[k] < 0 || note.pitches[k] > maxPitch) {\r\n\t\t\t\t\t\tnote.pitches.splice(k, 1);\r\n\t\t\t\t\t\tk--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (note.pitches[k] < lowestPitch) lowestPitch = note.pitches[k];\r\n\t\t\t\t\tif (note.pitches[k] > highestPitch) highestPitch = note.pitches[k];\r\n\t\t\t\t}\r\n\t\t\t\tif (note.pitches.length < 1) continue;\r\n\t\t\t\t\r\n\t\t\t\tfor (let k: number = 0; k < note.pins.length; k++) {\r\n\t\t\t\t\tconst pin: NotePin = note.pins[k];\r\n\t\t\t\t\tif (pin.interval + lowestPitch < 0) pin.interval = -lowestPitch;\r\n\t\t\t\t\tif (pin.interval + highestPitch > maxPitch) pin.interval = maxPitch - highestPitch;\r\n\t\t\t\t\tif (k >= 2) {\r\n\t\t\t\t\t\tif (pin.interval == note.pins[k-1].interval &&\r\n\t\t\t\t\t\t\tpin.interval == note.pins[k-2].interval &&\r\n\t\t\t\t\t\t\tpin.size == note.pins[k-1].size &&\r\n\t\t\t\t\t\t\tpin.size == note.pins[k-2].size)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tnote.pins.splice(k-1, 1);\r\n\t\t\t\t\t\t\tk--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (note.start == 0) {\r\n\t\t\t\t\tnote.continuesLastPattern = (noteObject[\"continuesLastPattern\"] === true);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnote.continuesLastPattern = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tthis.notes.push(note);\r\n\t\t\t\ttickClock = note.end;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport class Operator {\r\n\tpublic frequency: number = 0;\r\n\tpublic amplitude: number = 0;\r\n\t\r\n\tconstructor(index: number) {\r\n\t\tthis.reset(index);\r\n\t}\r\n\t\r\n\tpublic reset(index: number): void {\r\n\t\tthis.frequency = 0;\r\n\t\tthis.amplitude = (index <= 1) ? Config.operatorAmplitudeMax : 0;\r\n\t}\r\n}\r\n\r\nexport class SpectrumWave {\r\n\tpublic spectrum: number[] = [];\r\n\tpublic hash: number = -1;\r\n\t\r\n\tconstructor(isNoiseChannel: boolean) {\r\n\t\tthis.reset(isNoiseChannel);\r\n\t}\r\n\t\r\n\tpublic reset(isNoiseChannel: boolean): void {\r\n\t\tfor (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n\t\t\tif (isNoiseChannel) {\r\n\t\t\t\tthis.spectrum[i] = Math.round(Config.spectrumMax * (1 / Math.sqrt(1 + i / 3)));\r\n\t\t\t} else {\r\n\t\t\t\tconst isHarmonic: boolean = i==0 || i==7 || i==11 || i==14 || i==16 || i==18 || i==21 || i==23 || i>=25;\r\n\t\t\t\tthis.spectrum[i] = isHarmonic ? Math.max(0, Math.round(Config.spectrumMax * (1 - i / 30))) : 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.markCustomWaveDirty();\r\n\t}\r\n\t\r\n\tpublic markCustomWaveDirty(): void {\r\n\t\tconst hashMult: number = Synth.fittingPowerOfTwo(Config.spectrumMax + 2) - 1;\r\n\t\tlet hash: number = 0;\r\n\t\tfor (const point of this.spectrum) hash = ((hash * hashMult) + point) >>> 0;\r\n\t\tthis.hash = hash;\r\n\t}\r\n}\r\n\r\nclass SpectrumWaveState {\r\n\tpublic wave: Float32Array | null = null;\r\n\tprivate _hash: number = -1;\r\n\t\r\n\tpublic getCustomWave(settings: SpectrumWave, lowestOctave: number): Float32Array {\r\n\t\tif (this._hash == settings.hash) return this.wave!;\r\n\t\tthis._hash = settings.hash;\r\n\t\t\r\n\t\tconst waveLength: number = Config.spectrumNoiseLength;\r\n\t\tif (this.wave == null || this.wave.length != waveLength + 1) {\r\n\t\t\tthis.wave = new Float32Array(waveLength + 1);\r\n\t\t}\r\n\t\tconst wave: Float32Array = this.wave;\r\n\t\t\r\n\t\tfor (let i: number = 0; i < waveLength; i++) {\r\n\t\t\twave[i] = 0;\r\n\t\t}\r\n\t\t\r\n\t\tconst highestOctave: number = 14;\r\n\t\tconst falloffRatio: number = 0.25;\r\n\t\t// Nudge the 2/7 and 4/7 control points so that they form harmonic intervals.\r\n\t\tconst pitchTweak: number[] = [0, 1/7, Math.log2(5/4), 3/7, Math.log2(3/2), 5/7, 6/7];\r\n\t\tfunction controlPointToOctave(point: number): number {\r\n\t\t\treturn lowestOctave + Math.floor(point / Config.spectrumControlPointsPerOctave) + pitchTweak[(point + Config.spectrumControlPointsPerOctave) % Config.spectrumControlPointsPerOctave];\r\n\t\t}\r\n\t\t\r\n\t\tlet combinedAmplitude: number = 1;\r\n\t\tfor (let i: number = 0; i < Config.spectrumControlPoints + 1; i++) {\r\n\t\t\tconst value1: number = (i <= 0) ? 0 : settings.spectrum[i - 1];\r\n\t\t\tconst value2: number = (i >= Config.spectrumControlPoints) ? settings.spectrum[Config.spectrumControlPoints - 1] : settings.spectrum[i];\r\n\t\t\tconst octave1: number = controlPointToOctave(i - 1);\r\n\t\t\tlet octave2: number = controlPointToOctave(i);\r\n\t\t\tif (i >= Config.spectrumControlPoints) octave2 = highestOctave + (octave2 - highestOctave) * falloffRatio;\r\n\t\t\tif (value1 == 0 && value2 == 0) continue;\r\n\t\t\t\r\n\t\t\tcombinedAmplitude += 0.02 * drawNoiseSpectrum(wave, waveLength, octave1, octave2, value1 / Config.spectrumMax, value2 / Config.spectrumMax, -0.5);\r\n\t\t}\r\n\t\tif (settings.spectrum[Config.spectrumControlPoints - 1] > 0) {\r\n\t\t\tcombinedAmplitude += 0.02 * drawNoiseSpectrum(wave, waveLength, highestOctave + (controlPointToOctave(Config.spectrumControlPoints) - highestOctave) * falloffRatio, highestOctave, settings.spectrum[Config.spectrumControlPoints - 1] / Config.spectrumMax, 0, -0.5);\r\n\t\t}\r\n\t\t\r\n\t\tinverseRealFourierTransform(wave, waveLength);\r\n\t\tscaleElementsByFactor(wave, 5.0 / (Math.sqrt(waveLength) * Math.pow(combinedAmplitude, 0.75)));\r\n\t\t\r\n\t\t// Duplicate the first sample at the end for easier wrap-around interpolation.\r\n\t\twave[waveLength] = wave[0];\r\n\t\t\r\n\t\treturn wave;\r\n\t}\r\n}\r\n\r\nexport class HarmonicsWave {\r\n\tpublic harmonics: number[] = [];\r\n\tpublic hash: number = -1;\r\n\t\r\n\tconstructor() {\r\n\t\tthis.reset();\r\n\t}\r\n\t\r\n\tpublic reset(): void {\r\n\t\tfor (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n\t\t\tthis.harmonics[i] = 0;\r\n\t\t}\r\n\t\tthis.harmonics[0] = Config.harmonicsMax;\r\n\t\tthis.harmonics[3] = Config.harmonicsMax;\r\n\t\tthis.harmonics[6] = Config.harmonicsMax;\r\n\t\tthis.markCustomWaveDirty();\r\n\t}\r\n\t\r\n\tpublic markCustomWaveDirty(): void {\r\n\t\tconst hashMult: number = Synth.fittingPowerOfTwo(Config.harmonicsMax + 2) - 1;\r\n\t\tlet hash: number = 0;\r\n\t\tfor (const point of this.harmonics) hash = ((hash * hashMult) + point) >>> 0;\r\n\t\tthis.hash = hash;\r\n\t}\r\n}\r\n\r\nclass HarmonicsWaveState {\r\n\tpublic wave: Float32Array | null = null;\r\n\tprivate _hash: number = -1;\r\n\tprivate _generatedForType: InstrumentType;\r\n\t\r\n\tpublic getCustomWave(settings: HarmonicsWave, instrumentType: InstrumentType): Float32Array {\r\n\t\tif (this._hash == settings.hash && this._generatedForType == instrumentType) return this.wave!;\r\n\t\tthis._hash = settings.hash;\r\n\t\tthis._generatedForType = instrumentType;\r\n\t\t\r\n\t\tconst harmonicsRendered: number = (instrumentType == InstrumentType.pickedString) ? Config.harmonicsRenderedForPickedString : Config.harmonicsRendered;\r\n\t\t\r\n\t\tconst waveLength: number = Config.harmonicsWavelength;\r\n\t\tconst retroWave: Float32Array = getDrumWave(0, null, null);\r\n\t\t\r\n\t\tif (this.wave == null || this.wave.length != waveLength + 1) {\r\n\t\t\tthis.wave = new Float32Array(waveLength + 1);\r\n\t\t}\r\n\t\tconst wave: Float32Array = this.wave;\r\n\t\t\r\n\t\tfor (let i: number = 0; i < waveLength; i++) {\r\n\t\t\twave[i] = 0;\r\n\t\t}\r\n\t\t\r\n\t\tconst overallSlope: number = -0.25;\r\n\t\tlet combinedControlPointAmplitude: number = 1;\r\n\t\t\r\n\t\tfor (let harmonicIndex: number = 0; harmonicIndex < harmonicsRendered; harmonicIndex++) {\r\n\t\t\tconst harmonicFreq: number = harmonicIndex + 1;\r\n\t\t\tlet controlValue: number = harmonicIndex < Config.harmonicsControlPoints ? settings.harmonics[harmonicIndex] : settings.harmonics[Config.harmonicsControlPoints - 1];\r\n\t\t\tif (harmonicIndex >= Config.harmonicsControlPoints) {\r\n\t\t\t\tcontrolValue *= 1 - (harmonicIndex - Config.harmonicsControlPoints) / (harmonicsRendered - Config.harmonicsControlPoints);\r\n\t\t\t}\r\n\t\t\tconst normalizedValue: number = controlValue / Config.harmonicsMax;\r\n\t\t\tlet amplitude: number = Math.pow(2, controlValue - Config.harmonicsMax + 1) * Math.sqrt(normalizedValue);\r\n\t\t\tif (harmonicIndex < Config.harmonicsControlPoints) {\r\n\t\t\t\tcombinedControlPointAmplitude += amplitude;\r\n\t\t\t}\r\n\t\t\tamplitude *= Math.pow(harmonicFreq, overallSlope);\r\n\t\t\t\r\n\t\t\t// Multiply all the sine wave amplitudes by 1 or -1 based on the LFSR\r\n\t\t\t// retro wave (effectively random) to avoid egregiously tall spikes.\r\n\t\t\tamplitude *= retroWave[harmonicIndex + 589];\r\n\t\t\t\r\n\t\t\twave[waveLength - harmonicFreq] = amplitude;\r\n\t\t}\r\n\t\t\r\n\t\tinverseRealFourierTransform(wave, waveLength);\r\n\t\t\r\n\t\t// Limit the maximum wave amplitude.\r\n\t\tconst mult: number = 1 / Math.pow(combinedControlPointAmplitude, 0.7);\r\n\t\tfor (let i: number = 0; i < wave.length; i++) wave[i] *= mult;\r\n\t\t\r\n\t\tperformIntegral(wave);\r\n\t\t\r\n\t\t// The first sample should be zero, and we'll duplicate it at the end for easier interpolation.\r\n\t\twave[waveLength] = wave[0];\r\n\t\t\r\n\t\treturn wave;\r\n\t}\r\n}\r\n\r\nexport class FilterControlPoint {\r\n\tpublic freq: number = 0;\r\n\tpublic gain: number = Config.filterGainCenter;\r\n\tpublic type: FilterType = FilterType.peak;\r\n\t\r\n\tpublic set(freqSetting: number, gainSetting: number): void {\r\n\t\tthis.freq = freqSetting;\r\n\t\tthis.gain = gainSetting;\r\n\t}\r\n\t\r\n\tpublic getHz(): number {\r\n\t\treturn FilterControlPoint.getHzFromSettingValue(this.freq);\r\n\t}\r\n\t\r\n\tpublic static getHzFromSettingValue(value: number): number {\r\n\t\treturn Config.filterFreqReferenceHz * Math.pow(2.0, (value - Config.filterFreqReferenceSetting) * Config.filterFreqStep);\r\n\t}\r\n\tpublic static getSettingValueFromHz(hz: number): number {\r\n\t\treturn Math.log2(hz / Config.filterFreqReferenceHz) / Config.filterFreqStep + Config.filterFreqReferenceSetting;\r\n\t}\r\n\tpublic static getRoundedSettingValueFromHz(hz: number): number {\r\n\t\treturn Math.max(0, Math.min(Config.filterFreqRange - 1, Math.round(FilterControlPoint.getSettingValueFromHz(hz))));\r\n\t}\r\n\t\r\n\tpublic getLinearGain(peakMult: number = 1.0): number {\r\n\t\tconst power: number = (this.gain - Config.filterGainCenter) * Config.filterGainStep;\r\n\t\tconst neutral: number = (this.type == FilterType.peak) ? 0.0 : -0.5;\r\n\t\tconst interpolatedPower: number = neutral + (power - neutral) * peakMult;\r\n\t\treturn Math.pow(2.0, interpolatedPower);\r\n\t}\r\n\tpublic static getRoundedSettingValueFromLinearGain(linearGain: number): number {\r\n\t\treturn Math.max(0, Math.min(Config.filterGainRange - 1, Math.round(Math.log2(linearGain) / Config.filterGainStep + Config.filterGainCenter)));\r\n\t}\r\n\t\r\n\tpublic toCoefficients(filter: FilterCoefficients, sampleRate: number, freqMult: number = 1.0, peakMult: number = 1.0): void {\r\n\t\tconst cornerRadiansPerSample: number = 2.0 * Math.PI * Math.max(Config.filterFreqMinHz, Math.min(Config.filterFreqMaxHz, freqMult * this.getHz())) / sampleRate;\r\n\t\tconst linearGain: number = this.getLinearGain(peakMult);\r\n\t\tswitch (this.type) {\r\n\t\t\tcase FilterType.lowPass:\r\n\t\t\t\tfilter.lowPass2ndOrderButterworth(cornerRadiansPerSample, linearGain);\r\n\t\t\t\tbreak;\r\n\t\t\tcase FilterType.highPass:\r\n\t\t\t\tfilter.highPass2ndOrderButterworth(cornerRadiansPerSample, linearGain);\r\n\t\t\t\tbreak;\r\n\t\t\tcase FilterType.peak:\r\n\t\t\t\tfilter.peak2ndOrder(cornerRadiansPerSample, linearGain, 1.0);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error();\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic getVolumeCompensationMult(): number {\r\n\t\tconst octave: number = (this.freq - Config.filterFreqReferenceSetting) * Config.filterFreqStep;\r\n\t\tconst gainPow: number = (this.gain - Config.filterGainCenter) * Config.filterGainStep;\r\n\t\tswitch (this.type) {\r\n\t\t\tcase FilterType.lowPass:\r\n\t\t\t\tconst freqRelativeTo8khz: number = Math.pow(2.0, octave) * Config.filterFreqReferenceHz / 8000.0;\r\n\t\t\t\t// Reverse the frequency warping from importing legacy simplified filters to imitate how the legacy filter cutoff setting affected volume.\r\n\t\t\t\tconst warpedFreq: number = (Math.sqrt(1.0 + 4.0 * freqRelativeTo8khz) - 1.0) / 2.0;\r\n\t\t\t\tconst warpedOctave: number = Math.log2(warpedFreq);\r\n\t\t\t\treturn Math.pow(0.5, 0.2 * Math.max(0.0, gainPow + 1.0) + Math.min(0.0, Math.max(-3.0, 0.595 * warpedOctave + 0.35 * Math.min(0.0, gainPow + 1.0))));\r\n\t\t\tcase FilterType.highPass:\r\n\t\t\t\treturn Math.pow(0.5, 0.125 * Math.max(0.0, gainPow + 1.0) + Math.min(0.0, 0.3 * (-octave - Math.log2(Config.filterFreqReferenceHz / 125.0)) + 0.2 * Math.min(0.0, gainPow + 1.0)));\r\n\t\t\tcase FilterType.peak:\r\n\t\t\t\tconst distanceFromCenter: number = octave + Math.log2(Config.filterFreqReferenceHz / 2000.0);\r\n\t\t\t\tconst freqLoudness: number = Math.pow(1.0 / (1.0 + Math.pow(distanceFromCenter / 3.0, 2.0)), 2.0);\r\n\t\t\t\treturn Math.pow(0.5, 0.125 * Math.max(0.0, gainPow) + 0.1 * freqLoudness * Math.min(0.0, gainPow));\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport class FilterSettings {\r\n\tpublic readonly controlPoints: FilterControlPoint[] = [];\r\n\tpublic controlPointCount: number = 0;\r\n\t\r\n\tconstructor() {\r\n\t\tthis.reset();\r\n\t}\r\n\t\r\n\treset(): void {\r\n\t\tthis.controlPointCount = 0;\r\n\t}\r\n\t\r\n\taddPoint(type: FilterType, freqSetting: number, gainSetting: number): void {\r\n\t\tlet controlPoint: FilterControlPoint;\r\n\t\tif (this.controlPoints.length <= this.controlPointCount) {\r\n\t\t\tcontrolPoint = new FilterControlPoint();\r\n\t\t\tthis.controlPoints[this.controlPointCount] = controlPoint;\r\n\t\t} else {\r\n\t\t\tcontrolPoint = this.controlPoints[this.controlPointCount];\r\n\t\t}\r\n\t\tthis.controlPointCount++;\r\n\t\tcontrolPoint.type = type;\r\n\t\tcontrolPoint.set(freqSetting, gainSetting);\r\n\t}\r\n\t\r\n\tpublic toJsonObject(): Object {\r\n\t\tconst filterArray: any[] = [];\r\n\t\tfor (let i: number = 0; i < this.controlPointCount; i++) {\r\n\t\t\tconst point: FilterControlPoint = this.controlPoints[i];\r\n\t\t\tfilterArray.push({\r\n\t\t\t\t\"type\": Config.filterTypeNames[point.type],\r\n\t\t\t\t\"cutoffHz\": Math.round(point.getHz() * 100) / 100,\r\n\t\t\t\t\"linearGain\": Math.round(point.getLinearGain() * 10000) / 10000,\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn filterArray;\r\n\t}\r\n\t\r\n\tpublic fromJsonObject(filterObject: any): void {\r\n\t\tthis.controlPoints.length = 0;\r\n\t\tif (filterObject) {\r\n\t\t\tfor (const pointObject of filterObject) {\r\n\t\t\t\tconst point: FilterControlPoint = new FilterControlPoint();\r\n\t\t\t\tpoint.type = Config.filterTypeNames.indexOf(pointObject[\"type\"]);\r\n\t\t\t\tif (<any>point.type == -1) point.type = FilterType.peak;\r\n\t\t\t\tif (pointObject[\"cutoffHz\"] != undefined) {\r\n\t\t\t\t\tpoint.freq = FilterControlPoint.getRoundedSettingValueFromHz(pointObject[\"cutoffHz\"]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpoint.freq = 0;\r\n\t\t\t\t}\r\n\t\t\t\tif (pointObject[\"linearGain\"] != undefined) {\r\n\t\t\t\t\tpoint.gain = FilterControlPoint.getRoundedSettingValueFromLinearGain(pointObject[\"linearGain\"]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpoint.gain = Config.filterGainCenter;\r\n\t\t\t\t}\r\n\t\t\t\tthis.controlPoints.push(point);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.controlPointCount = this.controlPoints.length;\r\n\t}\r\n\t\r\n\tpublic convertLegacySettings(legacyCutoffSetting: number, legacyResonanceSetting: number, legacyEnv: Envelope): void {\r\n\t\tthis.reset();\r\n\t\t\r\n\t\tconst legacyFilterCutoffMaxHz: number = 8000; // This was carefully calculated to correspond to no change in response when filtering at 48000 samples per second... when using the legacy simplified low-pass filter.\r\n\t\tconst legacyFilterMax: number = 0.95;\r\n\t\tconst legacyFilterMaxRadians: number = Math.asin(legacyFilterMax / 2.0) * 2.0;\r\n\t\tconst legacyFilterMaxResonance: number = 0.95;\r\n\t\tconst legacyFilterCutoffRange: number = 11;\r\n\t\tconst legacyFilterResonanceRange: number = 8;\r\n\t\t\r\n\t\tconst resonant: boolean = (legacyResonanceSetting > 1);\r\n\t\tconst firstOrder: boolean = (legacyResonanceSetting == 0);\r\n\t\tconst cutoffAtMax: boolean = (legacyCutoffSetting == legacyFilterCutoffRange - 1);\r\n\t\tconst envDecays: boolean = (legacyEnv.type == EnvelopeType.flare || legacyEnv.type == EnvelopeType.twang || legacyEnv.type == EnvelopeType.decay || legacyEnv.type == EnvelopeType.noteSize);\r\n\t\t\r\n\t\tconst standardSampleRate: number = 48000;\r\n\t\tconst legacyHz: number = legacyFilterCutoffMaxHz * Math.pow(2.0, (legacyCutoffSetting - (legacyFilterCutoffRange - 1)) * 0.5);\r\n\t\tconst legacyRadians: number = Math.min(legacyFilterMaxRadians, 2 * Math.PI * legacyHz / standardSampleRate);\r\n\t\t\r\n\t\tif (legacyEnv.type == EnvelopeType.none && !resonant && cutoffAtMax) {\r\n\t\t\t// The response is flat and there's no envelopes, so don't even bother adding any control points.\r\n\t\t} else if (firstOrder) {\r\n\t\t\t// In general, a 1st order lowpass can be approximated by a 2nd order lowpass\r\n\t\t\t// with a cutoff ~4 octaves higher (*16) and a gain of 1/16.\r\n\t\t\t// However, BeepBox's original lowpass filters behaved oddly as they\r\n\t\t\t// approach the nyquist frequency, so I've devised this curved conversion\r\n\t\t\t// to guess at a perceptually appropriate new cutoff frequency and gain.\r\n\t\t\tconst extraOctaves: number = 3.5;\r\n\t\t\tconst targetRadians: number = legacyRadians * Math.pow(2.0, extraOctaves);\r\n\t\t\tconst curvedRadians: number = targetRadians / (1.0 + targetRadians / Math.PI);\r\n\t\t\tconst curvedHz: number = standardSampleRate * curvedRadians / (2.0 * Math.PI)\r\n\t\t\tconst freqSetting: number = FilterControlPoint.getRoundedSettingValueFromHz(curvedHz);\r\n\t\t\tconst finalHz: number = FilterControlPoint.getHzFromSettingValue(freqSetting);\r\n\t\t\tconst finalRadians: number = 2.0 * Math.PI * finalHz / standardSampleRate;\r\n\t\t\t\r\n\t\t\tconst legacyFilter: FilterCoefficients = new FilterCoefficients();\r\n\t\t\tlegacyFilter.lowPass1stOrderSimplified(legacyRadians);\r\n\t\t\tconst response: FrequencyResponse = new FrequencyResponse();\r\n\t\t\tresponse.analyze(legacyFilter, finalRadians);\r\n\t\t\tconst legacyFilterGainAtNewRadians: number = response.magnitude();\r\n\t\t\t\r\n\t\t\tlet logGain: number = Math.log2(legacyFilterGainAtNewRadians);\r\n\t\t\t// Bias slightly toward 2^(-extraOctaves):\r\n\t\t\tlogGain = -extraOctaves + (logGain + extraOctaves) * 0.82;\r\n\t\t\t// Decaying envelopes move the cutoff frequency back into an area where the best approximation of the first order slope requires a lower gain setting.\r\n\t\t\tif (envDecays) logGain = Math.min(logGain, -1.0);\r\n\t\t\tconst convertedGain: number = Math.pow(2.0, logGain);\r\n\t\t\tconst gainSetting: number = FilterControlPoint.getRoundedSettingValueFromLinearGain(convertedGain);\r\n\t\t\t\r\n\t\t\tthis.addPoint(FilterType.lowPass, freqSetting, gainSetting);\r\n\t\t} else {\r\n\t\t\tconst intendedGain: number = 0.5 / (1.0 - legacyFilterMaxResonance * Math.sqrt(Math.max(0.0, legacyResonanceSetting - 1.0) / (legacyFilterResonanceRange - 2.0)));\r\n\t\t\tconst invertedGain: number = 0.5 / intendedGain;\r\n\t\t\tconst maxRadians: number = 2.0 * Math.PI * legacyFilterCutoffMaxHz / standardSampleRate;\r\n\t\t\tconst freqRatio: number = legacyRadians / maxRadians;\r\n\t\t\tconst targetRadians: number = legacyRadians * (freqRatio * Math.pow(invertedGain, 0.9) + 1.0);\r\n\t\t\tconst curvedRadians: number = legacyRadians + (targetRadians - legacyRadians) * invertedGain;\r\n\t\t\tlet curvedHz: number;\r\n\t\t\tif (envDecays) {\r\n\t\t\t\tcurvedHz = standardSampleRate * Math.min(curvedRadians, legacyRadians * Math.pow(2, 0.25)) / (2.0 * Math.PI)\r\n\t\t\t} else {\r\n\t\t\t\tcurvedHz = standardSampleRate * curvedRadians / (2.0 * Math.PI)\r\n\t\t\t}\r\n\t\t\tconst freqSetting: number = FilterControlPoint.getRoundedSettingValueFromHz(curvedHz);\r\n\t\t\t\r\n\t\t\tlet legacyFilterGain: number;\r\n\t\t\tif (envDecays) {\r\n\t\t\t\tlegacyFilterGain = intendedGain;\r\n\t\t\t} else {\r\n\t\t\t\tconst legacyFilter: FilterCoefficients = new FilterCoefficients();\r\n\t\t\t\tlegacyFilter.lowPass2ndOrderSimplified(legacyRadians, intendedGain);\r\n\t\t\t\tconst response: FrequencyResponse = new FrequencyResponse();\r\n\t\t\t\tresponse.analyze(legacyFilter, curvedRadians);\r\n\t\t\t\tlegacyFilterGain = response.magnitude();\r\n\t\t\t}\r\n\t\t\tif (!resonant) legacyFilterGain = Math.min(legacyFilterGain, Math.sqrt(0.5));\r\n\t\t\tconst gainSetting: number = FilterControlPoint.getRoundedSettingValueFromLinearGain(legacyFilterGain);\r\n\t\t\t\r\n\t\t\tthis.addPoint(FilterType.lowPass, freqSetting, gainSetting);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport class EnvelopeSettings {\r\n\tpublic target: number = 0;\r\n\tpublic index: number = 0;\r\n\tpublic envelope: number = 0;\r\n\t\r\n\tconstructor() {\r\n\t\tthis.reset();\r\n\t}\r\n\t\r\n\treset(): void {\r\n\t\tthis.target = 0;\r\n\t\tthis.index = 0;\r\n\t\tthis.envelope = 0;\r\n\t}\r\n\t\r\n\tpublic toJsonObject(): Object {\r\n\t\tconst envelopeObject: any = {\r\n\t\t\t\"target\": Config.instrumentAutomationTargets[this.target].name,\r\n\t\t\t\"envelope\": Config.envelopes[this.envelope].name,\r\n\t\t};\r\n\t\tif (Config.instrumentAutomationTargets[this.target].maxCount > 1) {\r\n\t\t\tenvelopeObject[\"index\"] = this.index;\r\n\t\t}\r\n\t\treturn envelopeObject;\r\n\t}\r\n\t\r\n\tpublic fromJsonObject(envelopeObject: any): void {\r\n\t\tthis.reset();\r\n\t\t\r\n\t\tlet target: AutomationTarget = Config.instrumentAutomationTargets.dictionary[envelopeObject[\"target\"]];\r\n\t\tif (target == null) target = Config.instrumentAutomationTargets.dictionary[\"noteVolume\"];\r\n\t\tthis.target = target.index;\r\n\t\t\r\n\t\tlet envelope: Envelope = Config.envelopes.dictionary[envelopeObject[\"envelope\"]];\r\n\t\tif (envelope == null) envelope = Config.envelopes.dictionary[\"none\"];\r\n\t\tthis.envelope = envelope.index;\r\n\t\t\r\n\t\tif (envelopeObject[\"index\"] != undefined) {\r\n\t\t\tthis.index = clamp(0, Config.instrumentAutomationTargets[this.target].maxCount, envelopeObject[\"index\"] | 0);\r\n\t\t} else {\r\n\t\t\tthis.index = 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Settings that were available to old versions of BeepBox but are no longer available in the\r\n// current version that need to be reinterpreted as a group to determine the best way to\r\n// represent them in the current version.\r\ninterface LegacySettings {\r\n\tfilterCutoff?: number;\r\n\tfilterResonance?: number;\r\n\tfilterEnvelope?: Envelope;\r\n\tpulseEnvelope?: Envelope;\r\n\toperatorEnvelopes?: Envelope[];\r\n\tfeedbackEnvelope?: Envelope;\r\n}\r\n\r\nexport class Instrument {\r\n\tpublic type: InstrumentType = InstrumentType.chip;\r\n\tpublic preset: number = 0;\r\n\tpublic chipWave: number = 2;\r\n\tpublic chipNoise: number = 1;\r\n\tpublic eqFilter: FilterSettings = new FilterSettings();\r\n\tpublic noteFilter: FilterSettings = new FilterSettings();\r\n\tpublic envelopes: EnvelopeSettings[] = [];\r\n\tpublic envelopeCount: number = 0;\r\n\tpublic fadeIn: number = 0;\r\n\tpublic fadeOut: number = Config.fadeOutNeutral;\r\n\tpublic transition: number = Config.transitions.dictionary[\"normal\"].index;\r\n\tpublic pitchShift: number = 0;\r\n\tpublic detune: number = 0;\r\n\tpublic vibrato: number = 0;\r\n\tpublic unison: number = 0;\r\n\tpublic effects: number = 0;\r\n\tpublic chord: number = 1;\r\n\tpublic volume: number = 0;\r\n\tpublic pan: number = Config.panCenter;\r\n\tpublic pulseWidth: number = Config.pulseWidthRange - 1;\r\n\tpublic supersawDynamism: number = Config.supersawDynamismMax;\r\n\tpublic supersawSpread: number = Math.ceil(Config.supersawSpreadMax / 2.0);\r\n\tpublic supersawShape: number = 0;\r\n\tpublic stringSustain: number = 10;\r\n\tpublic stringSustainType: SustainType = SustainType.acoustic;\r\n\tpublic distortion: number = 0;\r\n\tpublic bitcrusherFreq: number = 0;\r\n\tpublic bitcrusherQuantization: number = 0;\r\n\tpublic chorus: number = 0;\r\n\tpublic reverb: number = 0;\r\n\tpublic echoSustain: number = 0;\r\n\tpublic echoDelay: number = 0;\r\n\tpublic algorithm: number = 0;\r\n\tpublic feedbackType: number = 0;\r\n\tpublic feedbackAmplitude: number = 0;\r\n\tpublic readonly operators: Operator[] = [];\r\n\tpublic readonly spectrumWave: SpectrumWave;\r\n\tpublic readonly harmonicsWave: HarmonicsWave = new HarmonicsWave();\r\n\tpublic readonly drumsetEnvelopes: number[] = [];\r\n\tpublic readonly drumsetSpectrumWaves: SpectrumWave[] = [];\r\n\t\r\n\tconstructor(isNoiseChannel: boolean) {\r\n\t\tthis.spectrumWave = new SpectrumWave(isNoiseChannel);\r\n\t\tfor (let i: number = 0; i < Config.operatorCount; i++) {\r\n\t\t\tthis.operators[i] = new Operator(i);\r\n\t\t}\r\n\t\tfor (let i: number = 0; i < Config.drumCount; i++) {\r\n\t\t\tthis.drumsetEnvelopes[i] = Config.envelopes.dictionary[\"twang 2\"].index;\r\n\t\t\tthis.drumsetSpectrumWaves[i] = new SpectrumWave(true);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic setTypeAndReset(type: InstrumentType, isNoiseChannel: boolean): void {\r\n\t\tthis.type = type;\r\n\t\tthis.preset = type;\r\n\t\tthis.volume = 0;\r\n\t\tthis.effects = 0;\r\n\t\tthis.chorus = Config.chorusRange - 1;\r\n\t\tthis.reverb = 2;\r\n\t\tthis.echoSustain = Math.floor((Config.echoSustainRange - 1) * 0.5);\r\n\t\tthis.echoDelay = Math.floor((Config.echoDelayRange - 1) * 0.5);\r\n\t\tthis.eqFilter.reset();\r\n\t\tthis.noteFilter.reset();\r\n\t\tthis.distortion = Math.floor((Config.distortionRange - 1) * 0.75);\r\n\t\tthis.bitcrusherFreq = Math.floor((Config.bitcrusherFreqRange - 1) * 0.5)\r\n\t\tthis.bitcrusherQuantization = Math.floor((Config.bitcrusherQuantizationRange - 1) * 0.5);\r\n\t\tthis.pan = Config.panCenter;\r\n\t\tthis.pitchShift = Config.pitchShiftCenter;\r\n\t\tthis.detune = Config.detuneCenter;\r\n\t\tthis.vibrato = 0;\r\n\t\tthis.unison = 0;\r\n\t\tthis.stringSustain = 10;\r\n\t\tthis.stringSustainType = Config.enableAcousticSustain ? SustainType.acoustic : SustainType.bright;\r\n\t\tthis.fadeIn = 0;\r\n\t\tthis.fadeOut = Config.fadeOutNeutral;\r\n\t\tthis.transition = Config.transitions.dictionary[\"normal\"].index;\r\n\t\tthis.envelopeCount = 0;\r\n\t\tswitch (type) {\r\n\t\t\tcase InstrumentType.chip:\r\n\t\t\t\tthis.chipWave = 2;\r\n\t\t\t\t// TODO: enable the chord effect?\r\n\t\t\t\tthis.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n\t\t\t\tbreak;\r\n\t\t\tcase InstrumentType.fm:\r\n\t\t\t\tthis.chord = Config.chords.dictionary[\"custom interval\"].index;\r\n\t\t\t\tthis.algorithm = 0;\r\n\t\t\t\tthis.feedbackType = 0;\r\n\t\t\t\tthis.feedbackAmplitude = 0;\r\n\t\t\t\tfor (let i: number = 0; i < this.operators.length; i++) {\r\n\t\t\t\t\tthis.operators[i].reset(i);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase InstrumentType.noise:\r\n\t\t\t\tthis.chipNoise = 1;\r\n\t\t\t\tthis.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n\t\t\t\tbreak;\r\n\t\t\tcase InstrumentType.spectrum:\r\n\t\t\t\tthis.chord = Config.chords.dictionary[\"simultaneous\"].index;\r\n\t\t\t\tthis.spectrumWave.reset(isNoiseChannel);\r\n\t\t\t\tbreak;\r\n\t\t\tcase InstrumentType.drumset:\r\n\t\t\t\tthis.chord = Config.chords.dictionary[\"simultaneous\"].index;\r\n\t\t\t\tfor (let i: number = 0; i < Config.drumCount; i++) {\r\n\t\t\t\t\tthis.drumsetEnvelopes[i] = Config.envelopes.dictionary[\"twang 2\"].index;\r\n\t\t\t\t\tthis.drumsetSpectrumWaves[i].reset(isNoiseChannel);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase InstrumentType.harmonics:\r\n\t\t\t\tthis.chord = Config.chords.dictionary[\"simultaneous\"].index;\r\n\t\t\t\tthis.harmonicsWave.reset();\r\n\t\t\t\tbreak;\r\n\t\t\tcase InstrumentType.pwm:\r\n\t\t\t\tthis.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n\t\t\t\tthis.pulseWidth = Config.pulseWidthRange - 1;\r\n\t\t\t\tbreak;\r\n\t\t\tcase InstrumentType.pickedString:\r\n\t\t\t\tthis.chord = Config.chords.dictionary[\"strum\"].index;\r\n\t\t\t\tthis.harmonicsWave.reset();\r\n\t\t\t\tbreak;\r\n\t\t\tcase InstrumentType.supersaw:\r\n\t\t\t\tthis.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n\t\t\t\tthis.supersawDynamism = Config.supersawDynamismMax;\r\n\t\t\t\tthis.supersawSpread = Math.ceil(Config.supersawSpreadMax / 2.0);\r\n\t\t\t\tthis.supersawShape = 0;\r\n\t\t\t\tthis.pulseWidth = Config.pulseWidthRange - 1;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(\"Unrecognized instrument type: \" + type);\r\n\t\t}\r\n\t\t// Chip/noise instruments had arpeggio and FM had custom interval but neither\r\n\t\t// explicitly saved the chorus setting beforeSeven so enable it here. The effects\r\n\t\t// will otherwise get overridden when reading SongTagCode.startInstrument.\r\n\t\tif (this.chord != Config.chords.dictionary[\"simultaneous\"].index) {\r\n\t\t\t// Enable chord if it was used.\r\n\t\t\tthis.effects = (this.effects | (1 << EffectType.chord));\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic convertLegacySettings(legacySettings: LegacySettings): void {\r\n\t\tlet legacyCutoffSetting: number | undefined = legacySettings.filterCutoff;\r\n\t\tlet legacyResonanceSetting: number | undefined = legacySettings.filterResonance;\r\n\t\tlet legacyFilterEnv: Envelope | undefined = legacySettings.filterEnvelope;\r\n\t\tlet legacyPulseEnv: Envelope | undefined = legacySettings.pulseEnvelope;\r\n\t\tlet legacyOperatorEnvelopes: Envelope[] | undefined = legacySettings.operatorEnvelopes;\r\n\t\tlet legacyFeedbackEnv: Envelope | undefined = legacySettings.feedbackEnvelope;\r\n\t\t\r\n\t\t// legacy defaults:\r\n\t\tif (legacyCutoffSetting == undefined) legacyCutoffSetting = (this.type == InstrumentType.chip) ? 6 : 10;\r\n\t\tif (legacyResonanceSetting == undefined) legacyResonanceSetting = 0;\r\n\t\tif (legacyFilterEnv == undefined) legacyFilterEnv = Config.envelopes.dictionary[\"none\"];\r\n\t\tif (legacyPulseEnv == undefined) legacyPulseEnv = Config.envelopes.dictionary[(this.type == InstrumentType.pwm) ? \"twang 2\" : \"none\"];\r\n\t\tif (legacyOperatorEnvelopes == undefined) legacyOperatorEnvelopes = [Config.envelopes.dictionary[(this.type == InstrumentType.fm) ? \"note size\" : \"none\"], Config.envelopes.dictionary[\"none\"], Config.envelopes.dictionary[\"none\"], Config.envelopes.dictionary[\"none\"]];\r\n\t\tif (legacyFeedbackEnv == undefined) legacyFeedbackEnv = Config.envelopes.dictionary[\"none\"];\r\n\t\t\r\n\t\t// The \"punch\" envelope is special: it goes *above* the chosen cutoff. But if the cutoff was already at the max, it couldn't go any higher... except in the current version of BeepBox I raised the max cutoff so it *can* but then it sounds different, so to preserve the original sound let's just remove the punch envelope.\r\n\t\tconst legacyFilterCutoffRange: number = 11;\r\n\t\tconst cutoffAtMax: boolean = (legacyCutoffSetting == legacyFilterCutoffRange - 1);\r\n\t\tif (cutoffAtMax && legacyFilterEnv.type == EnvelopeType.punch) legacyFilterEnv = Config.envelopes.dictionary[\"none\"];\r\n\t\t\r\n\t\tconst carrierCount: number = Config.algorithms[this.algorithm].carrierCount;\r\n\t\tlet noCarriersControlledByNoteSize: boolean = true;\r\n\t\tlet allCarriersControlledByNoteSize: boolean = true;\r\n\t\tlet noteSizeControlsSomethingElse: boolean = (legacyFilterEnv.type == EnvelopeType.noteSize) || (legacyPulseEnv.type == EnvelopeType.noteSize);\r\n\t\tif (this.type == InstrumentType.fm) {\r\n\t\t\tnoteSizeControlsSomethingElse = noteSizeControlsSomethingElse || (legacyFeedbackEnv.type == EnvelopeType.noteSize);\r\n\t\t\tfor (let i: number = 0; i < legacyOperatorEnvelopes.length; i++) {\r\n\t\t\t\tif (i < carrierCount) {\r\n\t\t\t\t\tif (legacyOperatorEnvelopes[i].type != EnvelopeType.noteSize) {\r\n\t\t\t\t\t\tallCarriersControlledByNoteSize = false;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnoCarriersControlledByNoteSize = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnoteSizeControlsSomethingElse = noteSizeControlsSomethingElse || (legacyOperatorEnvelopes[i].type == EnvelopeType.noteSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tthis.envelopeCount = 0;\r\n\t\t\r\n\t\tif (this.type == InstrumentType.fm) {\r\n\t\t\tif (allCarriersControlledByNoteSize && noteSizeControlsSomethingElse) {\r\n\t\t\t\tthis.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"noteVolume\"].index, 0, Config.envelopes.dictionary[\"note size\"].index);\r\n\t\t\t} else if (noCarriersControlledByNoteSize && !noteSizeControlsSomethingElse) {\r\n\t\t\t\tthis.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"none\"].index, 0, Config.envelopes.dictionary[\"note size\"].index);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (legacyFilterEnv.type == EnvelopeType.none) {\r\n\t\t\tthis.noteFilter.reset();\r\n\t\t\tthis.eqFilter.convertLegacySettings(legacyCutoffSetting, legacyResonanceSetting, legacyFilterEnv);\r\n\t\t\tthis.effects &= ~(1 << EffectType.noteFilter);\r\n\t\t} else {\r\n\t\t\tthis.eqFilter.reset();\r\n\t\t\tthis.noteFilter.convertLegacySettings(legacyCutoffSetting, legacyResonanceSetting, legacyFilterEnv);\r\n\t\t\tthis.effects |= 1 << EffectType.noteFilter;\r\n\t\t\tthis.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"noteFilterAllFreqs\"].index, 0, legacyFilterEnv.index);\r\n\t\t}\r\n\t\t\r\n\t\tif (legacyPulseEnv.type != EnvelopeType.none) {\r\n\t\t\tthis.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"pulseWidth\"].index, 0, legacyPulseEnv.index);\r\n\t\t}\r\n\t\t\r\n\t\tfor (let i: number = 0; i < legacyOperatorEnvelopes.length; i++) {\r\n\t\t\tif (i < carrierCount && allCarriersControlledByNoteSize) continue;\r\n\t\t\tif (legacyOperatorEnvelopes[i].type != EnvelopeType.none) {\r\n\t\t\t\tthis.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"operatorAmplitude\"].index, i, legacyOperatorEnvelopes[i].index);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (legacyFeedbackEnv.type != EnvelopeType.none) {\r\n\t\t\tthis.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"feedbackAmplitude\"].index, 0, legacyFeedbackEnv.index);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic toJsonObject(): Object {\r\n\t\tconst instrumentObject: any = {\r\n\t\t\t\"type\": Config.instrumentTypeNames[this.type],\r\n\t\t\t\"volume\": (5 - this.volume) * 20,\r\n\t\t\t\"eqFilter\": this.eqFilter.toJsonObject(),\r\n\t\t};\r\n\t\t\r\n\t\tif (this.preset != this.type) {\r\n\t\t\tinstrumentObject[\"preset\"] = this.preset;\r\n\t\t}\r\n\t\t\r\n\t\tconst effects: string[] = [];\r\n\t\tfor (const effect of Config.effectOrder) {\r\n\t\t\tif (this.effects & (1 << effect)) {\r\n\t\t\t\teffects.push(Config.effectNames[effect]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tinstrumentObject[\"effects\"] = effects;\r\n\t\t\r\n\t\t\r\n\t\tif (effectsIncludeTransition(this.effects)) {\r\n\t\t\tinstrumentObject[\"transition\"] = Config.transitions[this.transition].name;\r\n\t\t}\r\n\t\tif (effectsIncludeChord(this.effects)) {\r\n\t\t\tinstrumentObject[\"chord\"] = this.getChord().name;\r\n\t\t}\r\n\t\tif (effectsIncludePitchShift(this.effects)) {\r\n\t\t\tinstrumentObject[\"pitchShiftSemitones\"] = this.pitchShift;\r\n\t\t}\r\n\t\tif (effectsIncludeDetune(this.effects)) {\r\n\t\t\tinstrumentObject[\"detuneCents\"] = Synth.detuneToCents(this.detune - Config.detuneCenter);\r\n\t\t}\r\n\t\tif (effectsIncludeVibrato(this.effects)) {\r\n\t\t\tinstrumentObject[\"vibrato\"] = Config.vibratos[this.vibrato].name;\r\n\t\t}\r\n\t\tif (effectsIncludeNoteFilter(this.effects)) {\r\n\t\t\tinstrumentObject[\"noteFilter\"] = this.noteFilter.toJsonObject();\r\n\t\t}\r\n\t\tif (effectsIncludeDistortion(this.effects)) {\r\n\t\t\tinstrumentObject[\"distortion\"] = Math.round(100 * this.distortion / (Config.distortionRange - 1));\r\n\t\t}\r\n\t\tif (effectsIncludeBitcrusher(this.effects)) {\r\n\t\t\tinstrumentObject[\"bitcrusherOctave\"] = (Config.bitcrusherFreqRange - 1 - this.bitcrusherFreq) * Config.bitcrusherOctaveStep;\r\n\t\t\tinstrumentObject[\"bitcrusherQuantization\"] = Math.round(100 * this.bitcrusherQuantization / (Config.bitcrusherQuantizationRange - 1));\r\n\t\t}\r\n\t\tif (effectsIncludePanning(this.effects)) {\r\n\t\t\tinstrumentObject[\"pan\"] = Math.round(100 * (this.pan - Config.panCenter) / Config.panCenter);\r\n\t\t}\r\n\t\tif (effectsIncludeChorus(this.effects)) {\r\n\t\t\tinstrumentObject[\"chorus\"] = Math.round(100 * this.chorus / (Config.chorusRange - 1));\r\n\t\t}\r\n\t\tif (effectsIncludeEcho(this.effects)) {\r\n\t\t\tinstrumentObject[\"echoSustain\"] = Math.round(100 * this.echoSustain / (Config.echoSustainRange - 1));\r\n\t\t\tinstrumentObject[\"echoDelayBeats\"] = Math.round(1000 * (this.echoDelay + 1) * Config.echoDelayStepTicks / (Config.ticksPerPart * Config.partsPerBeat)) / 1000;\r\n\t\t}\r\n\t\tif (effectsIncludeReverb(this.effects)) {\r\n\t\t\tinstrumentObject[\"reverb\"] = Math.round(100 * this.reverb / (Config.reverbRange - 1));\r\n\t\t}\r\n\t\t\r\n\t\tif (this.type != InstrumentType.drumset) {\r\n\t\t\tinstrumentObject[\"fadeInSeconds\"] = Math.round(10000 * Synth.fadeInSettingToSeconds(this.fadeIn)) / 10000;\r\n\t\t\tinstrumentObject[\"fadeOutTicks\"] = Synth.fadeOutSettingToTicks(this.fadeOut);\r\n\t\t}\r\n\t\t\r\n\t\tif (this.type == InstrumentType.harmonics || this.type == InstrumentType.pickedString) {\r\n\t\t\tinstrumentObject[\"harmonics\"] = [];\r\n\t\t\tfor (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n\t\t\t\tinstrumentObject[\"harmonics\"][i] = Math.round(100 * this.harmonicsWave.harmonics[i] / Config.harmonicsMax);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (this.type == InstrumentType.noise) {\r\n\t\t\tinstrumentObject[\"wave\"] = Config.chipNoises[this.chipNoise].name;\r\n\t\t} else if (this.type == InstrumentType.spectrum) {\r\n\t\t\tinstrumentObject[\"spectrum\"] = [];\r\n\t\t\tfor (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n\t\t\t\tinstrumentObject[\"spectrum\"][i] = Math.round(100 * this.spectrumWave.spectrum[i] / Config.spectrumMax);\r\n\t\t\t}\r\n\t\t} else if (this.type == InstrumentType.drumset) {\r\n\t\t\tinstrumentObject[\"drums\"] = [];\r\n\t\t\tfor (let j: number = 0; j < Config.drumCount; j++) {\r\n\t\t\t\tconst spectrum: number[] = [];\r\n\t\t\t\tfor (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n\t\t\t\t\tspectrum[i] = Math.round(100 * this.drumsetSpectrumWaves[j].spectrum[i] / Config.spectrumMax);\r\n\t\t\t\t}\r\n\t\t\t\tinstrumentObject[\"drums\"][j] = {\r\n\t\t\t\t\t\"filterEnvelope\": this.getDrumsetEnvelope(j).name,\r\n\t\t\t\t\t\"spectrum\": spectrum,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t} else if (this.type == InstrumentType.chip) {\r\n\t\t\tinstrumentObject[\"wave\"] = Config.chipWaves[this.chipWave].name;\r\n\t\t\tinstrumentObject[\"unison\"] = Config.unisons[this.unison].name;\r\n\t\t} else if (this.type == InstrumentType.pwm) {\r\n\t\t\tinstrumentObject[\"pulseWidth\"] = Math.round(getPulseWidthRatio(this.pulseWidth) * 100 * 100000) / 100000;\r\n\t\t} else if (this.type == InstrumentType.supersaw) {\r\n\t\t\tinstrumentObject[\"pulseWidth\"] = Math.round(getPulseWidthRatio(this.pulseWidth) * 100 * 100000) / 100000;\r\n\t\t\tinstrumentObject[\"dynamism\"] = Math.round(100 * this.supersawDynamism / Config.supersawDynamismMax);\r\n\t\t\tinstrumentObject[\"spread\"] = Math.round(100 * this.supersawSpread / Config.supersawSpreadMax);\r\n\t\t\tinstrumentObject[\"shape\"] = Math.round(100 * this.supersawShape / Config.supersawShapeMax);\r\n\t\t} else if (this.type == InstrumentType.pickedString) {\r\n\t\t\tinstrumentObject[\"unison\"] = Config.unisons[this.unison].name;\r\n\t\t\tinstrumentObject[\"stringSustain\"] = Math.round(100 * this.stringSustain / (Config.stringSustainRange - 1));\r\n\t\t\tif (Config.enableAcousticSustain) {\r\n\t\t\t\tinstrumentObject[\"stringSustainType\"] = Config.sustainTypeNames[this.stringSustainType];\r\n\t\t\t}\r\n\t\t} else if (this.type == InstrumentType.harmonics) {\r\n\t\t\tinstrumentObject[\"unison\"] = Config.unisons[this.unison].name;\r\n\t\t} else if (this.type == InstrumentType.fm) {\r\n\t\t\tconst operatorArray: Object[] = [];\r\n\t\t\tfor (const operator of this.operators) {\r\n\t\t\t\toperatorArray.push({\r\n\t\t\t\t\t\"frequency\": Config.operatorFrequencies[operator.frequency].name,\r\n\t\t\t\t\t\"amplitude\": operator.amplitude,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tinstrumentObject[\"algorithm\"] = Config.algorithms[this.algorithm].name;\r\n\t\t\tinstrumentObject[\"feedbackType\"] = Config.feedbacks[this.feedbackType].name;\r\n\t\t\tinstrumentObject[\"feedbackAmplitude\"] = this.feedbackAmplitude;\r\n\t\t\tinstrumentObject[\"operators\"] = operatorArray;\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Unrecognized instrument type\");\r\n\t\t}\r\n\t\t\r\n\t\tconst envelopes: any[] = [];\r\n\t\tfor (let i = 0; i < this.envelopeCount; i++) {\r\n\t\t\tenvelopes.push(this.envelopes[i].toJsonObject());\r\n\t\t}\r\n\t\tinstrumentObject[\"envelopes\"] = envelopes;\r\n\t\t\r\n\t\treturn instrumentObject;\r\n\t}\r\n\t\r\n\tpublic fromJsonObject(instrumentObject: any, isNoiseChannel: boolean, legacyGlobalReverb: number = 0): void {\r\n\t\tif (instrumentObject == undefined) instrumentObject = {};\r\n\t\t\r\n\t\tlet type: InstrumentType = Config.instrumentTypeNames.indexOf(instrumentObject[\"type\"]);\r\n\t\tif (<any>type == -1) type = isNoiseChannel ? InstrumentType.noise : InstrumentType.chip;\r\n\t\tthis.setTypeAndReset(type, isNoiseChannel);\r\n\t\t\r\n\t\tif (instrumentObject[\"preset\"] != undefined) {\r\n\t\t\tthis.preset = instrumentObject[\"preset\"] >>> 0;\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"volume\"] != undefined) {\r\n\t\t\tthis.volume = clamp(0, Config.volumeRange, Math.round(5 - (instrumentObject[\"volume\"] | 0) / 20));\r\n\t\t} else {\r\n\t\t\tthis.volume = 0;\r\n\t\t}\r\n\t\t\r\n\t\tif (Array.isArray(instrumentObject[\"effects\"])) {\r\n\t\t\tlet effects: number = 0;\r\n\t\t\tfor (let i: number = 0; i < instrumentObject[\"effects\"].length; i++) {\r\n\t\t\t\teffects = effects | (1 << Config.effectNames.indexOf(instrumentObject[\"effects\"][i]));\r\n\t\t\t}\r\n\t\t\tthis.effects = (effects & ((1 << EffectType.length) - 1));\r\n\t\t} else {\r\n\t\t\t// The index of these names is reinterpreted as a bitfield, which relies on reverb and chorus being the first effects!\r\n\t\t\tconst legacyEffectsNames: string[] = [\"none\", \"reverb\", \"chorus\", \"chorus & reverb\"];\r\n\t\t\tthis.effects = legacyEffectsNames.indexOf(instrumentObject[\"effects\"]);\r\n\t\t\tif (this.effects == -1) this.effects = (this.type == InstrumentType.noise) ? 0 : 1;\r\n\t\t}\r\n\t\t\r\n\t\tthis.transition = Config.transitions.dictionary[\"normal\"].index; // default value.\r\n\t\tconst transitionProperty: any = instrumentObject[\"transition\"] || instrumentObject[\"envelope\"]; // the transition property used to be called envelope, so check that too.\r\n\t\tif (transitionProperty != undefined) {\r\n\t\t\tlet transition: Transition | undefined = Config.transitions.dictionary[transitionProperty];\r\n\t\t\tif (instrumentObject[\"fadeInSeconds\"] == undefined || instrumentObject[\"fadeOutTicks\"] == undefined) {\r\n\t\t\t\tconst legacySettings = (<any>{\r\n\t\t\t\t\t\"binary\":      {transition: \"interrupt\", fadeInSeconds: 0.0,    fadeOutTicks: -1},\r\n\t\t\t\t\t\"seamless\":    {transition: \"interrupt\", fadeInSeconds: 0.0,    fadeOutTicks: -1},\r\n\t\t\t\t\t\"sudden\":      {transition: \"normal\",    fadeInSeconds: 0.0,    fadeOutTicks: -3},\r\n\t\t\t\t\t\"hard\":        {transition: \"normal\",    fadeInSeconds: 0.0,    fadeOutTicks: -3},\r\n\t\t\t\t\t\"smooth\":      {transition: \"normal\",    fadeInSeconds: 0.025,  fadeOutTicks: -3},\r\n\t\t\t\t\t\"soft\":        {transition: \"normal\",    fadeInSeconds: 0.025,  fadeOutTicks: -3},\r\n\t\t\t\t\t// Note that the old slide transition has the same name as a new slide transition that is different.\r\n\t\t\t\t\t// Only apply legacy settings if the instrument JSON was created before, based on the presence\r\n\t\t\t\t\t// of the fade in/out fields.\r\n\t\t\t\t\t\"slide\":       {transition: \"slide in pattern\", fadeInSeconds: 0.025,  fadeOutTicks: -3},\r\n\t\t\t\t\t\"cross fade\":  {transition: \"normal\",    fadeInSeconds: 0.04,   fadeOutTicks:  6},\r\n\t\t\t\t\t\"hard fade\":   {transition: \"normal\",    fadeInSeconds: 0.0,    fadeOutTicks: 48},\r\n\t\t\t\t\t\"medium fade\": {transition: \"normal\",    fadeInSeconds: 0.0125, fadeOutTicks: 72},\r\n\t\t\t\t\t\"soft fade\":   {transition: \"normal\",    fadeInSeconds: 0.06,   fadeOutTicks: 96},\r\n\t\t\t\t})[transitionProperty];\r\n\t\t\t\tif (legacySettings != undefined) {\r\n\t\t\t\t\ttransition = Config.transitions.dictionary[legacySettings.transition];\r\n\t\t\t\t\t// These may be overridden below.\r\n\t\t\t\t\tthis.fadeIn = Synth.secondsToFadeInSetting(legacySettings.fadeInSeconds);\r\n\t\t\t\t\tthis.fadeOut = Synth.ticksToFadeOutSetting(legacySettings.fadeOutTicks);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (transition != undefined) this.transition = transition.index;\r\n\t\t\t\r\n\t\t\tif (this.transition != Config.transitions.dictionary[\"normal\"].index) {\r\n\t\t\t\t// Enable transition if it was used.\r\n\t\t\t\tthis.effects = (this.effects | (1 << EffectType.transition));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Overrides legacy settings in transition above.\r\n\t\tif (instrumentObject[\"fadeInSeconds\"] != undefined) {\r\n\t\t\tthis.fadeIn = Synth.secondsToFadeInSetting(+instrumentObject[\"fadeInSeconds\"]);\r\n\t\t}\r\n\t\tif (instrumentObject[\"fadeOutTicks\"] != undefined) {\r\n\t\t\tthis.fadeOut = Synth.ticksToFadeOutSetting(+instrumentObject[\"fadeOutTicks\"]);\r\n\t\t}\r\n\t\t\r\n\t\t{\r\n\t\t\t// Note that the chord setting may be overridden by instrumentObject[\"chorus\"] below.\r\n\t\t\tconst chordProperty: any = instrumentObject[\"chord\"];\r\n\t\t\tconst legacyChordNames: Dictionary<string> = {\"harmony\": \"simultaneous\"};\r\n\t\t\tconst chord: Chord | undefined = Config.chords.dictionary[legacyChordNames[chordProperty]] || Config.chords.dictionary[chordProperty];\r\n\t\t\tif (chord != undefined) {\r\n\t\t\t\tthis.chord = chord.index;\r\n\t\t\t} else {\r\n\t\t\t\t// Different instruments have different default chord types based on historical behaviour.\r\n\t\t\t\tif (this.type == InstrumentType.noise) {\r\n\t\t\t\t\tthis.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n\t\t\t\t} else if (this.type == InstrumentType.pickedString) {\r\n\t\t\t\t\tthis.chord = Config.chords.dictionary[\"strum\"].index;\r\n\t\t\t\t} else if (this.type == InstrumentType.chip) {\r\n\t\t\t\t\tthis.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n\t\t\t\t} else if (this.type == InstrumentType.fm) {\r\n\t\t\t\t\tthis.chord = Config.chords.dictionary[\"custom interval\"].index;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.chord = Config.chords.dictionary[\"simultaneous\"].index;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tthis.unison = Config.unisons.dictionary[\"none\"].index; // default value.\r\n\t\tconst unisonProperty: any = instrumentObject[\"unison\"] || instrumentObject[\"interval\"] || instrumentObject[\"chorus\"]; // The unison property has gone by various names in the past.\r\n\t\tif (unisonProperty != undefined) {\r\n\t\t\tconst legacyChorusNames: Dictionary<string> = {\"union\": \"none\", \"fifths\": \"fifth\", \"octaves\": \"octave\"};\r\n\t\t\tconst unison: Unison | undefined = Config.unisons.dictionary[legacyChorusNames[unisonProperty]] || Config.unisons.dictionary[unisonProperty];\r\n\t\t\tif (unison != undefined) this.unison = unison.index;\r\n\t\t}\r\n\t\tif (instrumentObject[\"chorus\"] == \"custom harmony\") {\r\n\t\t\t// The original chorus setting had an option that now maps to two different settings. Override those if necessary.\r\n\t\t\tthis.unison = Config.unisons.dictionary[\"hum\"].index;\r\n\t\t\tthis.chord = Config.chords.dictionary[\"custom interval\"].index;\r\n\t\t}\r\n\t\tif (this.chord != Config.chords.dictionary[\"simultaneous\"].index && !Array.isArray(instrumentObject[\"effects\"])) {\r\n\t\t\t// Enable chord if it was used.\r\n\t\t\tthis.effects = (this.effects | (1 << EffectType.chord));\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"pitchShiftSemitones\"] != undefined) {\r\n\t\t\tthis.pitchShift = clamp(0, Config.pitchShiftRange, Math.round(+instrumentObject[\"pitchShiftSemitones\"]));\r\n\t\t}\r\n\t\tif (instrumentObject[\"detuneCents\"] != undefined) {\r\n\t\t\tthis.detune = clamp(0, Config.detuneMax + 1, Math.round(Config.detuneCenter + Synth.centsToDetune(+instrumentObject[\"detuneCents\"])));\r\n\t\t}\r\n\t\t\r\n\t\tthis.vibrato = Config.vibratos.dictionary[\"none\"].index; // default value.\r\n\t\tconst vibratoProperty: any = instrumentObject[\"vibrato\"] || instrumentObject[\"effect\"]; // The vibrato property was previously called \"effect\", not to be confused with the current \"effects\".\r\n\t\tif (vibratoProperty != undefined) {\r\n\t\t\tconst legacyVibratoNames: Dictionary<string> = {\"vibrato light\": \"light\", \"vibrato delayed\": \"delayed\", \"vibrato heavy\": \"heavy\"};\r\n\t\t\tconst vibrato: Vibrato | undefined = Config.vibratos.dictionary[legacyVibratoNames[unisonProperty]] || Config.vibratos.dictionary[vibratoProperty];\r\n\t\t\tif (vibrato != undefined) this.vibrato = vibrato.index;\r\n\t\t\t\r\n\t\t\t// Old songs may have a vibrato effect without explicitly enabling it.\r\n\t\t\tif (vibrato != Config.vibratos.dictionary[\"none\"]) {\r\n\t\t\t\tthis.effects = (this.effects | (1 << EffectType.vibrato));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"pan\"] != undefined) {\r\n\t\t\tthis.pan = clamp(0, Config.panMax + 1, Math.round(Config.panCenter + (instrumentObject[\"pan\"] | 0) * Config.panCenter / 100));\r\n\t\t\t\r\n\t\t\t// Old songs may have a panning effect without explicitly enabling it.\r\n\t\t\tif (this.pan != Config.panCenter) {\r\n\t\t\t\tthis.effects = (this.effects | (1 << EffectType.panning));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.pan = Config.panCenter;\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"distortion\"] != undefined) {\r\n\t\t\tthis.distortion = clamp(0, Config.distortionRange, Math.round((Config.distortionRange - 1) * (instrumentObject[\"distortion\"] | 0) / 100));\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"bitcrusherOctave\"] != undefined) {\r\n\t\t\tthis.bitcrusherFreq = Config.bitcrusherFreqRange - 1 - (+instrumentObject[\"bitcrusherOctave\"]) / Config.bitcrusherOctaveStep;\r\n\t\t}\r\n\t\tif (instrumentObject[\"bitcrusherQuantization\"] != undefined) {\r\n\t\t\tthis.bitcrusherQuantization = clamp(0, Config.bitcrusherQuantizationRange, Math.round((Config.bitcrusherQuantizationRange - 1) * (instrumentObject[\"bitcrusherQuantization\"] | 0) / 100));\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"echoSustain\"] != undefined) {\r\n\t\t\tthis.echoSustain = clamp(0, Config.echoSustainRange, Math.round((Config.echoSustainRange - 1) * (instrumentObject[\"echoSustain\"] | 0) / 100));\r\n\t\t}\r\n\t\tif (instrumentObject[\"echoDelayBeats\"] != undefined) {\r\n\t\t\tthis.echoDelay = clamp(0, Config.echoDelayRange, Math.round((+instrumentObject[\"echoDelayBeats\"]) * (Config.ticksPerPart * Config.partsPerBeat) / Config.echoDelayStepTicks - 1.0));\r\n\t\t}\r\n\t\t\r\n\t\tif (!isNaN(instrumentObject[\"chorus\"])) {\r\n\t\t\tthis.chorus = clamp(0, Config.chorusRange, Math.round((Config.chorusRange - 1) * (instrumentObject[\"chorus\"] | 0) / 100));\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"reverb\"] != undefined) {\r\n\t\t\tthis.reverb = clamp(0, Config.reverbRange, Math.round((Config.reverbRange - 1) * (instrumentObject[\"reverb\"] | 0) / 100));\r\n\t\t} else {\r\n\t\t\tif (legacyGlobalReverb == 0) {\r\n\t\t\t\t// If the original song reverb was zero, just disable the instrument reverb effect entirely.\r\n\t\t\t\tthis.effects = (this.effects & (~(1 << EffectType.reverb)));\r\n\t\t\t} else {\r\n\t\t\t\tthis.reverb = legacyGlobalReverb;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"pulseWidth\"] != undefined) {\r\n\t\t\tthis.pulseWidth = clamp(0, Config.pulseWidthRange, Math.round(Math.log2((+instrumentObject[\"pulseWidth\"]) / 50) / 0.5 - 1 + 8));\r\n\t\t} else {\r\n\t\t\tthis.pulseWidth = Config.pulseWidthRange - 1;\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"dynamism\"] != undefined) {\r\n\t\t\tthis.supersawDynamism = clamp(0, Config.supersawDynamismMax + 1, Math.round(Config.supersawDynamismMax * (instrumentObject[\"dynamism\"] | 0) / 100));\r\n\t\t} else {\r\n\t\t\tthis.supersawDynamism = Config.supersawDynamismMax;\r\n\t\t}\r\n\t\tif (instrumentObject[\"spread\"] != undefined) {\r\n\t\t\tthis.supersawSpread = clamp(0, Config.supersawSpreadMax + 1, Math.round(Config.supersawSpreadMax * (instrumentObject[\"spread\"] | 0) / 100));\r\n\t\t} else {\r\n\t\t\tthis.supersawSpread = Math.ceil(Config.supersawSpreadMax / 2.0);\r\n\t\t}\r\n\t\tif (instrumentObject[\"shape\"] != undefined) {\r\n\t\t\tthis.supersawShape = clamp(0, Config.supersawShapeMax + 1, Math.round(Config.supersawShapeMax * (instrumentObject[\"shape\"] | 0) / 100));\r\n\t\t} else {\r\n\t\t\tthis.supersawShape = 0;\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"harmonics\"] != undefined) {\r\n\t\t\tfor (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n\t\t\t\tthis.harmonicsWave.harmonics[i] = Math.max(0, Math.min(Config.harmonicsMax, Math.round(Config.harmonicsMax * (+instrumentObject[\"harmonics\"][i]) / 100)));\r\n\t\t\t}\r\n\t\t\tthis.harmonicsWave.markCustomWaveDirty();\r\n\t\t} else {\r\n\t\t\tthis.harmonicsWave.reset();\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"spectrum\"] != undefined) {\r\n\t\t\tfor (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n\t\t\t\tthis.spectrumWave.spectrum[i] = Math.max(0, Math.min(Config.spectrumMax, Math.round(Config.spectrumMax * (+instrumentObject[\"spectrum\"][i]) / 100)));\r\n\t\t\t}\r\n\t\t\tthis.spectrumWave.markCustomWaveDirty();\r\n\t\t} else {\r\n\t\t\tthis.spectrumWave.reset(isNoiseChannel);\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"stringSustain\"] != undefined) {\r\n\t\t\tthis.stringSustain = clamp(0, Config.stringSustainRange, Math.round((Config.stringSustainRange - 1) * (instrumentObject[\"stringSustain\"] | 0) / 100));\r\n\t\t} else {\r\n\t\t\tthis.stringSustain = 10;\r\n\t\t}\r\n\t\tthis.stringSustainType = Config.enableAcousticSustain ? Config.sustainTypeNames.indexOf(instrumentObject[\"stringSustainType\"]) : SustainType.bright;\r\n\t\tif (<any>this.stringSustainType == -1) this.stringSustainType = SustainType.bright;\r\n\t\t\r\n\t\tif (this.type == InstrumentType.noise) {\r\n\t\t\tthis.chipNoise = Config.chipNoises.findIndex(wave=>wave.name==instrumentObject[\"wave\"]);\r\n\t\t\tif (this.chipNoise == -1) this.chipNoise = 1;\r\n\t\t}\r\n\t\t\r\n\t\tconst legacyEnvelopeNames: Dictionary<string> = {\"custom\": \"note size\", \"steady\": \"none\", \"pluck 1\": \"twang 1\", \"pluck 2\": \"twang 2\", \"pluck 3\": \"twang 3\"};\r\n\t\tconst getEnvelope = (name: any): Envelope | undefined => (legacyEnvelopeNames[name] != undefined) ? Config.envelopes.dictionary[legacyEnvelopeNames[name]] : Config.envelopes.dictionary[name];\r\n\t\t\r\n\t\tif (this.type == InstrumentType.drumset) {\r\n\t\t\tif (instrumentObject[\"drums\"] != undefined) {\r\n\t\t\t\tfor (let j: number = 0; j < Config.drumCount; j++) {\r\n\t\t\t\t\tconst drum: any = instrumentObject[\"drums\"][j];\r\n\t\t\t\t\tif (drum == undefined) continue;\r\n\t\t\t\t\t\r\n\t\t\t\t\tthis.drumsetEnvelopes[j] = Config.envelopes.dictionary[\"twang 2\"].index; // default value.\r\n\t\t\t\t\tif (drum[\"filterEnvelope\"] != undefined) {\r\n\t\t\t\t\t\tconst envelope: Envelope | undefined = getEnvelope(drum[\"filterEnvelope\"]);\r\n\t\t\t\t\t\tif (envelope != undefined) this.drumsetEnvelopes[j] = envelope.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (drum[\"spectrum\"] != undefined) {\r\n\t\t\t\t\t\tfor (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n\t\t\t\t\t\t\tthis.drumsetSpectrumWaves[j].spectrum[i] = Math.max(0, Math.min(Config.spectrumMax, Math.round(Config.spectrumMax * (+drum[\"spectrum\"][i]) / 100)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (this.type == InstrumentType.chip) {\r\n\t\t\tconst legacyWaveNames: Dictionary<number> = {\"triangle\": 1, \"square\": 2, \"pulse wide\": 3, \"pulse narrow\": 4, \"sawtooth\": 5, \"double saw\": 6, \"double pulse\": 7, \"spiky\": 8, \"plateau\": 0};\r\n\t\t\tthis.chipWave = legacyWaveNames[instrumentObject[\"wave\"]] != undefined ? legacyWaveNames[instrumentObject[\"wave\"]] : Config.chipWaves.findIndex(wave=>wave.name==instrumentObject[\"wave\"]);\r\n\t\t\tif (this.chipWave == -1) this.chipWave = 1;\r\n\t\t}\r\n\t\t\r\n\t\tif (this.type == InstrumentType.fm) {\r\n\t\t\tthis.algorithm = Config.algorithms.findIndex(algorithm=>algorithm.name==instrumentObject[\"algorithm\"]);\r\n\t\t\tif (this.algorithm == -1) this.algorithm = 0;\r\n\t\t\tthis.feedbackType = Config.feedbacks.findIndex(feedback=>feedback.name==instrumentObject[\"feedbackType\"]);\r\n\t\t\tif (this.feedbackType == -1) this.feedbackType = 0;\r\n\t\t\tif (instrumentObject[\"feedbackAmplitude\"] != undefined) {\r\n\t\t\t\tthis.feedbackAmplitude = clamp(0, Config.operatorAmplitudeMax + 1, instrumentObject[\"feedbackAmplitude\"] | 0);\r\n\t\t\t} else {\r\n\t\t\t\tthis.feedbackAmplitude = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (let j: number = 0; j < Config.operatorCount; j++) {\r\n\t\t\t\tconst operator: Operator = this.operators[j];\r\n\t\t\t\tlet operatorObject: any = undefined;\r\n\t\t\t\tif (instrumentObject[\"operators\"] != undefined) operatorObject = instrumentObject[\"operators\"][j];\r\n\t\t\t\tif (operatorObject == undefined) operatorObject = {};\r\n\t\t\t\t\r\n\t\t\t\toperator.frequency = Config.operatorFrequencies.findIndex(freq=>freq.name==operatorObject[\"frequency\"]);\r\n\t\t\t\tif (operator.frequency == -1) operator.frequency = 0;\r\n\t\t\t\tif (operatorObject[\"amplitude\"] != undefined) {\r\n\t\t\t\t\toperator.amplitude = clamp(0, Config.operatorAmplitudeMax + 1, operatorObject[\"amplitude\"] | 0);\r\n\t\t\t\t} else {\r\n\t\t\t\t\toperator.amplitude = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (instrumentObject[\"noteFilter\"] != undefined) {\r\n\t\t\tthis.noteFilter.fromJsonObject(instrumentObject[\"noteFilter\"]);\r\n\t\t} else {\r\n\t\t\tthis.noteFilter.reset();\r\n\t\t}\r\n\t\tif (Array.isArray(instrumentObject[\"eqFilter\"])) {\r\n\t\t\tthis.eqFilter.fromJsonObject(instrumentObject[\"eqFilter\"]);\r\n\t\t} else {\r\n\t\t\tthis.eqFilter.reset();\r\n\t\t\t\r\n\t\t\tconst legacySettings: LegacySettings = {};\r\n\t\t\t\r\n\t\t\t// Try converting from legacy filter settings.\r\n\t\t\tconst filterCutoffMaxHz: number = 8000;\r\n\t\t\tconst filterCutoffRange: number = 11;\r\n\t\t\tconst filterResonanceRange: number = 8;\r\n\t\t\tif (instrumentObject[\"filterCutoffHz\"] != undefined) {\r\n\t\t\t\tlegacySettings.filterCutoff = clamp(0, filterCutoffRange, Math.round((filterCutoffRange - 1) + 2.0 * Math.log((instrumentObject[\"filterCutoffHz\"] | 0) / filterCutoffMaxHz) / Math.LN2));\r\n\t\t\t} else {\r\n\t\t\t\tlegacySettings.filterCutoff = (this.type == InstrumentType.chip) ? 6 : 10;\r\n\t\t\t}\r\n\t\t\tif (instrumentObject[\"filterResonance\"] != undefined) {\r\n\t\t\t\tlegacySettings.filterResonance = clamp(0, filterResonanceRange, Math.round((filterResonanceRange - 1) * (instrumentObject[\"filterResonance\"] | 0) / 100));\r\n\t\t\t} else {\r\n\t\t\t\tlegacySettings.filterResonance = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlegacySettings.filterEnvelope = getEnvelope(instrumentObject[\"filterEnvelope\"]);\r\n\t\t\tlegacySettings.pulseEnvelope = getEnvelope(instrumentObject[\"pulseEnvelope\"]);\r\n\t\t\tlegacySettings.feedbackEnvelope = getEnvelope(instrumentObject[\"feedbackEnvelope\"]);\r\n\t\t\tif (Array.isArray(instrumentObject[\"operators\"])) {\r\n\t\t\t\tlegacySettings.operatorEnvelopes = [];\r\n\t\t\t\tfor (let j: number = 0; j < Config.operatorCount; j++) {\r\n\t\t\t\t\tlet envelope: Envelope | undefined;\r\n\t\t\t\t\tif (instrumentObject[\"operators\"][j] != undefined) {\r\n\t\t\t\t\t\tenvelope = getEnvelope(instrumentObject[\"operators\"][j][\"envelope\"]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlegacySettings.operatorEnvelopes[j] = (envelope != undefined) ? envelope : Config.envelopes.dictionary[\"none\"];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Try converting from even older legacy filter settings.\r\n\t\t\tif (instrumentObject[\"filter\"] != undefined) {\r\n\t\t\t\tconst legacyToCutoff: number[] = [10, 6, 3, 0, 8, 5, 2];\r\n\t\t\t\tconst legacyToEnvelope: string[] = [\"none\", \"none\", \"none\", \"none\", \"decay 1\", \"decay 2\", \"decay 3\"];\r\n\t\t\t\tconst filterNames: string[] = [\"none\", \"bright\", \"medium\", \"soft\", \"decay bright\", \"decay medium\", \"decay soft\"];\r\n\t\t\t\tconst oldFilterNames: Dictionary<number> = {\"sustain sharp\": 1, \"sustain medium\": 2, \"sustain soft\": 3, \"decay sharp\": 4};\r\n\t\t\t\tlet legacyFilter: number = oldFilterNames[instrumentObject[\"filter\"]] != undefined ? oldFilterNames[instrumentObject[\"filter\"]] : filterNames.indexOf(instrumentObject[\"filter\"]);\r\n\t\t\t\tif (legacyFilter == -1) legacyFilter = 0;\r\n\t\t\t\tlegacySettings.filterCutoff = legacyToCutoff[legacyFilter];\r\n\t\t\t\tlegacySettings.filterEnvelope = getEnvelope(legacyToEnvelope[legacyFilter]);\r\n\t\t\t\tlegacySettings.filterResonance = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.convertLegacySettings(legacySettings);\r\n\t\t}\r\n\t\t\r\n\t\tif (Array.isArray(instrumentObject[\"envelopes\"])) {\r\n\t\t\tconst envelopeArray: any[] = instrumentObject[\"envelopes\"];\r\n\t\t\tfor (let i = 0; i < envelopeArray.length; i++) {\r\n\t\t\t\tif (this.envelopeCount >= Config.maxEnvelopeCount) break;\r\n\t\t\t\tconst tempEnvelope: EnvelopeSettings = new EnvelopeSettings();\r\n\t\t\t\ttempEnvelope.fromJsonObject(envelopeArray[i]);\r\n\t\t\t\tthis.addEnvelope(tempEnvelope.target, tempEnvelope.index, tempEnvelope.envelope);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static frequencyFromPitch(pitch: number): number {\r\n\t\treturn 440.0 * Math.pow(2.0, (pitch - 69.0) / 12.0);\r\n\t}\r\n\t\r\n\tpublic addEnvelope(target: number, index: number, envelope: number): void {\r\n\t\tif (!this.supportsEnvelopeTarget(target, index)) throw new Error();\r\n\t\tif (this.envelopeCount >= Config.maxEnvelopeCount) throw new Error();\r\n\t\twhile (this.envelopes.length <= this.envelopeCount) this.envelopes[this.envelopes.length] = new EnvelopeSettings();\r\n\t\tconst envelopeSettings: EnvelopeSettings = this.envelopes[this.envelopeCount];\r\n\t\tenvelopeSettings.target = target;\r\n\t\tenvelopeSettings.index = index;\r\n\t\tenvelopeSettings.envelope = envelope;\r\n\t\tthis.envelopeCount++;\r\n\t}\r\n\t\r\n\tpublic supportsEnvelopeTarget(target: number, index: number): boolean {\r\n\t\tconst automationTarget: AutomationTarget = Config.instrumentAutomationTargets[target];\r\n\t\tif (automationTarget.computeIndex == null && automationTarget.name != \"none\") {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (index >= automationTarget.maxCount) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (automationTarget.compatibleInstruments != null && automationTarget.compatibleInstruments.indexOf(this.type) == -1) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (automationTarget.effect != null && (this.effects & (1 << automationTarget.effect)) == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (automationTarget.isFilter) {\r\n\t\t\t//if (automationTarget.perNote) {\r\n\t\t\t\tif (index >= this.noteFilter.controlPointCount) return false;\r\n\t\t\t//} else {\r\n\t\t\t//\tif (index >= this.eqFilter.controlPointCount)   return false;\r\n\t\t\t//}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tpublic clearInvalidEnvelopeTargets(): void {\r\n\t\tfor (let envelopeIndex: number = 0; envelopeIndex < this.envelopeCount; envelopeIndex++) {\r\n\t\t\tconst target: number = this.envelopes[envelopeIndex].target;\r\n\t\t\tconst index: number = this.envelopes[envelopeIndex].index;\r\n\t\t\tif (!this.supportsEnvelopeTarget(target, index)) {\r\n\t\t\t\tthis.envelopes[envelopeIndex].target = Config.instrumentAutomationTargets.dictionary[\"none\"].index;\r\n\t\t\t\tthis.envelopes[envelopeIndex].index = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic getTransition(): Transition {\r\n\t\treturn effectsIncludeTransition(this.effects) ? Config.transitions[this.transition] : Config.transitions.dictionary[\"normal\"];\r\n\t}\r\n\t\r\n\tpublic getFadeInSeconds(): number {\r\n\t\treturn (this.type == InstrumentType.drumset) ? 0.0 : Synth.fadeInSettingToSeconds(this.fadeIn);\r\n\t}\r\n\t\r\n\tpublic getFadeOutTicks(): number {\r\n\t\treturn (this.type == InstrumentType.drumset) ? Config.drumsetFadeOutTicks : Synth.fadeOutSettingToTicks(this.fadeOut)\r\n\t}\r\n\t\r\n\tpublic getChord(): Chord {\r\n\t\treturn effectsIncludeChord(this.effects) ? Config.chords[this.chord] : Config.chords.dictionary[\"simultaneous\"];\r\n\t}\r\n\t\r\n\tpublic getDrumsetEnvelope(pitch: number): Envelope {\r\n\t\tif (this.type != InstrumentType.drumset) throw new Error(\"Can't getDrumsetEnvelope() for non-drumset.\");\r\n\t\treturn Config.envelopes[this.drumsetEnvelopes[pitch]];\r\n\t}\r\n}\r\n\r\nexport class Channel {\r\n\tpublic octave: number = 0;\r\n\tpublic readonly instruments: Instrument[] = [];\r\n\tpublic readonly patterns: Pattern[] = [];\r\n\tpublic readonly bars: number[] = [];\r\n\tpublic muted: boolean = false;\r\n}\r\n\r\nexport class Song {\r\n\tprivate static readonly _format: string = \"BeepBox\";\r\n\tprivate static readonly _oldestVersion: number = 2;\r\n\tprivate static readonly _latestVersion: number = 9;\r\n\t\r\n\tpublic scale: number;\r\n\tpublic key: number;\r\n\tpublic tempo: number;\r\n\tpublic beatsPerBar: number;\r\n\tpublic barCount: number;\r\n\tpublic patternsPerChannel: number;\r\n\tpublic rhythm: number;\r\n\tpublic layeredInstruments: boolean;\r\n\tpublic patternInstruments: boolean;\r\n\tpublic loopStart: number;\r\n\tpublic loopLength: number;\r\n\tpublic pitchChannelCount: number;\r\n\tpublic noiseChannelCount: number;\r\n\tpublic readonly channels: Channel[] = [];\r\n\t\r\n\tconstructor(string?: string) {\r\n\t\tif (string != undefined) {\r\n\t\t\tthis.fromBase64String(string);\r\n\t\t} else {\r\n\t\t\tthis.initToDefault(true);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic getChannelCount(): number {\r\n\t\treturn this.pitchChannelCount + this.noiseChannelCount;\r\n\t}\r\n\t\r\n\tpublic getMaxInstrumentsPerChannel(): number {\r\n\t\treturn Math.max(\r\n\t\t\tthis.layeredInstruments ? Config.layeredInstrumentCountMax : Config.instrumentCountMin,\r\n\t\t\tthis.patternInstruments ? Config.patternInstrumentCountMax : Config.instrumentCountMin);\r\n\t}\r\n\t\r\n\tpublic getMaxInstrumentsPerPattern(channelIndex: number): number {\r\n\t\treturn this.getMaxInstrumentsPerPatternForChannel(this.channels[channelIndex]);\r\n\t}\r\n\t\r\n\tpublic getMaxInstrumentsPerPatternForChannel(channel: Channel): number {\r\n\t\treturn this.layeredInstruments\r\n\t\t\t? Math.min(Config.layeredInstrumentCountMax, channel.instruments.length)\r\n\t\t\t: 1;\r\n\t}\r\n\t\r\n\tpublic getChannelIsNoise(channelIndex: number): boolean {\r\n\t\treturn (channelIndex >= this.pitchChannelCount);\r\n\t}\r\n\t\r\n\tpublic initToDefault(andResetChannels: boolean = true): void {\r\n\t\tthis.scale = 0;\r\n\t\tthis.key = 0;\r\n\t\tthis.loopStart = 0;\r\n\t\tthis.loopLength = 4;\r\n\t\tthis.tempo = 150;\r\n\t\tthis.beatsPerBar = 8;\r\n\t\tthis.barCount = 16;\r\n\t\tthis.patternsPerChannel = 8;\r\n\t\tthis.rhythm = 1;\r\n\t\tthis.layeredInstruments = false;\r\n\t\tthis.patternInstruments = false;\r\n\t\t\r\n\t\tif (andResetChannels) {\r\n\t\t\tthis.pitchChannelCount = 3;\r\n\t\t\tthis.noiseChannelCount = 1;\r\n\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\tconst isNoiseChannel: boolean = channelIndex >= this.pitchChannelCount;\r\n\t\t\t\tif (this.channels.length <= channelIndex) {\r\n\t\t\t\t\tthis.channels[channelIndex] = new Channel();\r\n\t\t\t\t}\r\n\t\t\t\tconst channel: Channel = this.channels[channelIndex];\r\n\t\t\t\tchannel.octave = isNoiseChannel ? 0 : 4 - channelIndex; // [4, 3, 2, 0]: Descending octaves with drums at zero in last channel.\r\n\t\t\t\r\n\t\t\t\tfor (let pattern: number = 0; pattern < this.patternsPerChannel; pattern++) {\r\n\t\t\t\t\tif (channel.patterns.length <= pattern) {\r\n\t\t\t\t\t\tchannel.patterns[pattern] = new Pattern();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchannel.patterns[pattern].reset();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tchannel.patterns.length = this.patternsPerChannel;\r\n\t\t\t\r\n\t\t\t\tfor (let instrument: number = 0; instrument < Config.instrumentCountMin; instrument++) {\r\n\t\t\t\t\tif (channel.instruments.length <= instrument) {\r\n\t\t\t\t\t\tchannel.instruments[instrument] = new Instrument(isNoiseChannel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchannel.instruments[instrument].setTypeAndReset(isNoiseChannel ? InstrumentType.noise : InstrumentType.chip, isNoiseChannel);\r\n\t\t\t\t}\r\n\t\t\t\tchannel.instruments.length = Config.instrumentCountMin;\r\n\t\t\t\r\n\t\t\t\tfor (let bar: number = 0; bar < this.barCount; bar++) {\r\n\t\t\t\t\tchannel.bars[bar] = bar < 4 ? 1 : 0;\r\n\t\t\t\t}\r\n\t\t\t\tchannel.bars.length = this.barCount;\r\n\t\t\t}\r\n\t\t\tthis.channels.length = this.getChannelCount();\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic toBase64String(): string {\r\n\t\tlet bits: BitFieldWriter;\r\n\t\tlet buffer: number[] = [];\r\n\t\t\r\n\t\tbuffer.push(base64IntToCharCode[Song._latestVersion]);\r\n\t\tbuffer.push(SongTagCode.channelCount, base64IntToCharCode[this.pitchChannelCount], base64IntToCharCode[this.noiseChannelCount]);\r\n\t\tbuffer.push(SongTagCode.scale, base64IntToCharCode[this.scale]);\r\n\t\tbuffer.push(SongTagCode.key, base64IntToCharCode[this.key]);\r\n\t\tbuffer.push(SongTagCode.loopStart, base64IntToCharCode[this.loopStart >> 6], base64IntToCharCode[this.loopStart & 0x3f]);\r\n\t\tbuffer.push(SongTagCode.loopEnd, base64IntToCharCode[(this.loopLength - 1) >> 6], base64IntToCharCode[(this.loopLength - 1) & 0x3f]);\r\n\t\tbuffer.push(SongTagCode.tempo, base64IntToCharCode[this.tempo >> 6], base64IntToCharCode[this.tempo & 63]);\r\n\t\tbuffer.push(SongTagCode.beatCount, base64IntToCharCode[this.beatsPerBar - 1]);\r\n\t\tbuffer.push(SongTagCode.barCount, base64IntToCharCode[(this.barCount - 1) >> 6], base64IntToCharCode[(this.barCount - 1) & 0x3f]);\r\n\t\tbuffer.push(SongTagCode.patternCount, base64IntToCharCode[(this.patternsPerChannel - 1) >> 6], base64IntToCharCode[(this.patternsPerChannel - 1) & 0x3f]);\r\n\t\tbuffer.push(SongTagCode.rhythm, base64IntToCharCode[this.rhythm]);\r\n\t\t\r\n\t\tbuffer.push(SongTagCode.instrumentCount, base64IntToCharCode[(<any>this.layeredInstruments << 1) | <any>this.patternInstruments]);\r\n\t\tif (this.layeredInstruments || this.patternInstruments) {\r\n\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\tbuffer.push(base64IntToCharCode[this.channels[channelIndex].instruments.length - Config.instrumentCountMin]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tbuffer.push(SongTagCode.channelOctave);\r\n\t\tfor (let channelIndex: number = 0; channelIndex < this.pitchChannelCount; channelIndex++) {\r\n\t\t\tbuffer.push(base64IntToCharCode[this.channels[channelIndex].octave]);\r\n\t\t}\r\n\t\t\r\n\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\tfor (let i: number = 0; i < this.channels[channelIndex].instruments.length; i++) {\r\n\t\t\t\tconst instrument: Instrument = this.channels[channelIndex].instruments[i];\r\n\t\t\t\tbuffer.push(SongTagCode.startInstrument, base64IntToCharCode[instrument.type]);\r\n\t\t\t\tbuffer.push(SongTagCode.volume, base64IntToCharCode[instrument.volume]);\r\n\t\t\t\tbuffer.push(SongTagCode.preset, base64IntToCharCode[instrument.preset >> 6], base64IntToCharCode[instrument.preset & 63]);\r\n\t\t\t\t\r\n\t\t\t\tbuffer.push(SongTagCode.eqFilter, base64IntToCharCode[instrument.eqFilter.controlPointCount]);\r\n\t\t\t\tfor (let j: number = 0; j < instrument.eqFilter.controlPointCount; j++) {\r\n\t\t\t\t\tconst point: FilterControlPoint = instrument.eqFilter.controlPoints[j];\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[point.type], base64IntToCharCode[point.freq], base64IntToCharCode[point.gain]);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// The list of enabled effects is represented as a 12-bit bitfield using two six-bit characters.\r\n\t\t\t\tbuffer.push(SongTagCode.effects, base64IntToCharCode[instrument.effects >> 6], base64IntToCharCode[instrument.effects & 63]);\r\n\t\t\t\tif (effectsIncludeNoteFilter(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.noteFilter.controlPointCount]);\r\n\t\t\t\t\tfor (let j: number = 0; j < instrument.noteFilter.controlPointCount; j++) {\r\n\t\t\t\t\t\tconst point: FilterControlPoint = instrument.noteFilter.controlPoints[j];\r\n\t\t\t\t\t\tbuffer.push(base64IntToCharCode[point.type], base64IntToCharCode[point.freq], base64IntToCharCode[point.gain]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludeTransition(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.transition]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludeChord(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.chord]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludePitchShift(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.pitchShift]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludeDetune(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.detune]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludeVibrato(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.vibrato]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludeDistortion(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.distortion]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludeBitcrusher(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.bitcrusherFreq], base64IntToCharCode[instrument.bitcrusherQuantization]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludePanning(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.pan]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludeChorus(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.chorus]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludeEcho(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.echoSustain], base64IntToCharCode[instrument.echoDelay]);\r\n\t\t\t\t}\r\n\t\t\t\tif (effectsIncludeReverb(instrument.effects)) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.reverb]);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (instrument.type != InstrumentType.drumset) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.fadeInOut, base64IntToCharCode[instrument.fadeIn], base64IntToCharCode[instrument.fadeOut]);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (instrument.type == InstrumentType.harmonics || instrument.type == InstrumentType.pickedString) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.harmonics);\r\n\t\t\t\t\tconst harmonicsBits: BitFieldWriter = new BitFieldWriter();\r\n\t\t\t\t\tfor (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n\t\t\t\t\t\tharmonicsBits.write(Config.harmonicsControlPointBits, instrument.harmonicsWave.harmonics[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tharmonicsBits.encodeBase64(buffer);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (instrument.type == InstrumentType.chip) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.wave, base64IntToCharCode[instrument.chipWave]);\r\n\t\t\t\t\tbuffer.push(SongTagCode.unison, base64IntToCharCode[instrument.unison]);\r\n\t\t\t\t} else if (instrument.type == InstrumentType.fm) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.algorithm, base64IntToCharCode[instrument.algorithm]);\r\n\t\t\t\t\tbuffer.push(SongTagCode.feedbackType, base64IntToCharCode[instrument.feedbackType]);\r\n\t\t\t\t\tbuffer.push(SongTagCode.feedbackAmplitude, base64IntToCharCode[instrument.feedbackAmplitude]);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuffer.push(SongTagCode.operatorFrequencies);\r\n\t\t\t\t\tfor (let o: number = 0; o < Config.operatorCount; o++) {\r\n\t\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.operators[o].frequency]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbuffer.push(SongTagCode.operatorAmplitudes);\r\n\t\t\t\t\tfor (let o: number = 0; o < Config.operatorCount; o++) {\r\n\t\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.operators[o].amplitude]);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (instrument.type == InstrumentType.noise) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.wave, base64IntToCharCode[instrument.chipNoise]);\r\n\t\t\t\t} else if (instrument.type == InstrumentType.spectrum) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.spectrum);\r\n\t\t\t\t\tconst spectrumBits: BitFieldWriter = new BitFieldWriter();\r\n\t\t\t\t\tfor (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n\t\t\t\t\t\tspectrumBits.write(Config.spectrumControlPointBits, instrument.spectrumWave.spectrum[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tspectrumBits.encodeBase64(buffer);\r\n\t\t\t\t} else if (instrument.type == InstrumentType.drumset) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.drumsetEnvelopes);\r\n\t\t\t\t\tfor (let j: number = 0; j < Config.drumCount; j++) {\r\n\t\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.drumsetEnvelopes[j]]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuffer.push(SongTagCode.spectrum);\r\n\t\t\t\t\tconst spectrumBits: BitFieldWriter = new BitFieldWriter();\r\n\t\t\t\t\tfor (let j: number = 0; j < Config.drumCount; j++) {\r\n\t\t\t\t\t\tfor (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n\t\t\t\t\t\t\tspectrumBits.write(Config.spectrumControlPointBits, instrument.drumsetSpectrumWaves[j].spectrum[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tspectrumBits.encodeBase64(buffer);\r\n\t\t\t\t} else if (instrument.type == InstrumentType.harmonics) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.unison, base64IntToCharCode[instrument.unison]);\r\n\t\t\t\t} else if (instrument.type == InstrumentType.pwm) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.pulseWidth, base64IntToCharCode[instrument.pulseWidth]);\r\n\t\t\t\t} else if (instrument.type == InstrumentType.supersaw) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.supersaw, base64IntToCharCode[instrument.supersawDynamism], base64IntToCharCode[instrument.supersawSpread], base64IntToCharCode[instrument.supersawShape]);\r\n\t\t\t\t\tbuffer.push(SongTagCode.pulseWidth, base64IntToCharCode[instrument.pulseWidth]);\r\n\t\t\t\t} else if (instrument.type == InstrumentType.pickedString) {\r\n\t\t\t\t\tbuffer.push(SongTagCode.unison, base64IntToCharCode[instrument.unison]);\r\n\t\t\t\t\tif (Config.stringSustainRange > 0x20 || SustainType.length > 2) {\r\n\t\t\t\t\t\tthrow new Error(\"Not enough bits to represent sustain value and type in same base64 character.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbuffer.push(SongTagCode.stringSustain, base64IntToCharCode[instrument.stringSustain | (instrument.stringSustainType << 5)]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(\"Unknown instrument type.\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbuffer.push(SongTagCode.envelopes, base64IntToCharCode[instrument.envelopeCount]);\r\n\t\t\t\tfor (let envelopeIndex: number = 0; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.envelopes[envelopeIndex].target]);\r\n\t\t\t\t\tif (Config.instrumentAutomationTargets[instrument.envelopes[envelopeIndex].target].maxCount > 1) {\r\n\t\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.envelopes[envelopeIndex].index]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbuffer.push(base64IntToCharCode[instrument.envelopes[envelopeIndex].envelope]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tbuffer.push(SongTagCode.bars);\r\n\t\tbits = new BitFieldWriter();\r\n\t\tlet neededBits: number = 0;\r\n\t\twhile ((1 << neededBits) < this.patternsPerChannel + 1) neededBits++;\r\n\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) for (let i: number = 0; i < this.barCount; i++) {\r\n\t\t\tbits.write(neededBits, this.channels[channelIndex].bars[i]);\r\n\t\t}\r\n\t\tbits.encodeBase64(buffer);\r\n\t\t\r\n\t\tbuffer.push(SongTagCode.patterns);\r\n\t\tbits = new BitFieldWriter();\r\n\t\tconst shapeBits: BitFieldWriter = new BitFieldWriter();\r\n\t\tconst bitsPerNoteSize: number = Song.getNeededBits(Config.noteSizeMax);\r\n\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\tconst channel: Channel = this.channels[channelIndex];\r\n\t\t\tconst maxInstrumentsPerPattern: number = this.getMaxInstrumentsPerPattern(channelIndex);\r\n\t\t\tconst neededInstrumentCountBits: number = Song.getNeededBits(maxInstrumentsPerPattern - Config.instrumentCountMin);\r\n\t\t\tconst neededInstrumentIndexBits: number = Song.getNeededBits(channel.instruments.length - 1);\r\n\t\t\tconst isNoiseChannel: boolean = this.getChannelIsNoise(channelIndex);\r\n\t\t\tconst octaveOffset: number = isNoiseChannel ? 0 : channel.octave * Config.pitchesPerOctave;\r\n\t\t\tlet lastPitch: number = (isNoiseChannel ? 4 : octaveOffset);\r\n\t\t\tconst recentPitches: number[] = isNoiseChannel ? [4,6,7,2,3,8,0,10] : [0, 7, 12, 19, 24, -5, -12];\r\n\t\t\tconst recentShapes: string[] = [];\r\n\t\t\tfor (let i: number = 0; i < recentPitches.length; i++) {\r\n\t\t\t\trecentPitches[i] += octaveOffset;\r\n\t\t\t}\r\n\t\t\tfor (const pattern of channel.patterns) {\r\n\t\t\t\tif (this.patternInstruments) {\r\n\t\t\t\t\tconst instrumentCount: number = validateRange(Config.instrumentCountMin, maxInstrumentsPerPattern, pattern.instruments.length);\r\n\t\t\t\t\tbits.write(neededInstrumentCountBits, instrumentCount - Config.instrumentCountMin);\r\n\t\t\t\t\tfor (let i: number = 0; i < instrumentCount; i++) {\r\n\t\t\t\t\t\tbits.write(neededInstrumentIndexBits, pattern.instruments[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (pattern.notes.length > 0) {\r\n\t\t\t\t\tbits.write(1, 1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tlet curPart: number = 0;\r\n\t\t\t\t\tfor (const note of pattern.notes) {\r\n\t\t\t\t\t\tif (note.start > curPart) {\r\n\t\t\t\t\t\t\tbits.write(2, 0); // rest\r\n\t\t\t\t\t\t\tbits.writePartDuration(note.start - curPart);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tshapeBits.clear();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// 0: 1 pitch, 10: 2 pitches, 110: 3 pitches, 111: 4 pitches\r\n\t\t\t\t\t\tfor (let i: number = 1; i < note.pitches.length; i++) shapeBits.write(1,1);\r\n\t\t\t\t\t\tif (note.pitches.length < Config.maxChordSize) shapeBits.write(1,0);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tshapeBits.writePinCount(note.pins.length - 1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tshapeBits.write(bitsPerNoteSize, note.pins[0].size);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet shapePart: number = 0;\r\n\t\t\t\t\t\tlet startPitch: number = note.pitches[0];\r\n\t\t\t\t\t\tlet currentPitch: number = startPitch;\r\n\t\t\t\t\t\tconst pitchBends: number[] = [];\r\n\t\t\t\t\t\tfor (let i: number = 1; i < note.pins.length; i++) {\r\n\t\t\t\t\t\t\tconst pin: NotePin = note.pins[i];\r\n\t\t\t\t\t\t\tconst nextPitch: number = startPitch + pin.interval;\r\n\t\t\t\t\t\t\tif (currentPitch != nextPitch) {\r\n\t\t\t\t\t\t\t\tshapeBits.write(1, 1);\r\n\t\t\t\t\t\t\t\tpitchBends.push(nextPitch);\r\n\t\t\t\t\t\t\t\tcurrentPitch = nextPitch;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tshapeBits.write(1, 0);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tshapeBits.writePartDuration(pin.time - shapePart);\r\n\t\t\t\t\t\t\tshapePart = pin.time;\r\n\t\t\t\t\t\t\tshapeBits.write(bitsPerNoteSize, pin.size);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tconst shapeString: string = String.fromCharCode.apply(null, shapeBits.encodeBase64([]));\r\n\t\t\t\t\t\tconst shapeIndex: number = recentShapes.indexOf(shapeString);\r\n\t\t\t\t\t\tif (shapeIndex == -1) {\r\n\t\t\t\t\t\t\tbits.write(2, 1); // new shape\r\n\t\t\t\t\t\t\tbits.concat(shapeBits);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbits.write(1, 1); // old shape\r\n\t\t\t\t\t\t\tbits.writeLongTail(0, 0, shapeIndex);\r\n\t\t\t\t\t\t\trecentShapes.splice(shapeIndex, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trecentShapes.unshift(shapeString);\r\n\t\t\t\t\t\tif (recentShapes.length > 10) recentShapes.pop();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tconst allPitches: number[] = note.pitches.concat(pitchBends);\r\n\t\t\t\t\t\tfor (let i: number = 0; i < allPitches.length; i++) {\r\n\t\t\t\t\t\t\tconst pitch: number = allPitches[i];\r\n\t\t\t\t\t\t\tconst pitchIndex: number = recentPitches.indexOf(pitch);\r\n\t\t\t\t\t\t\tif (pitchIndex == -1) {\r\n\t\t\t\t\t\t\t\tlet interval: number = 0;\r\n\t\t\t\t\t\t\t\tlet pitchIter: number = lastPitch;\r\n\t\t\t\t\t\t\t\tif (pitchIter < pitch) {\r\n\t\t\t\t\t\t\t\t\twhile (pitchIter != pitch) {\r\n\t\t\t\t\t\t\t\t\t\tpitchIter++;\r\n\t\t\t\t\t\t\t\t\t\tif (recentPitches.indexOf(pitchIter) == -1) interval++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\twhile (pitchIter != pitch) {\r\n\t\t\t\t\t\t\t\t\t\tpitchIter--;\r\n\t\t\t\t\t\t\t\t\t\tif (recentPitches.indexOf(pitchIter) == -1) interval--;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbits.write(1, 0);\r\n\t\t\t\t\t\t\t\tbits.writePitchInterval(interval);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbits.write(1, 1);\r\n\t\t\t\t\t\t\t\tbits.write(3, pitchIndex);\r\n\t\t\t\t\t\t\t\trecentPitches.splice(pitchIndex, 1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\trecentPitches.unshift(pitch);\r\n\t\t\t\t\t\t\tif (recentPitches.length > 8) recentPitches.pop();\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (i == note.pitches.length - 1) {\r\n\t\t\t\t\t\t\t\tlastPitch = note.pitches[0];\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tlastPitch = pitch;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (note.start == 0) {\r\n\t\t\t\t\t\t\tbits.write(1, note.continuesLastPattern ? 1 : 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcurPart = note.end;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (curPart < this.beatsPerBar * Config.partsPerBeat) {\r\n\t\t\t\t\t\tbits.write(2, 0); // rest\r\n\t\t\t\t\t\tbits.writePartDuration(this.beatsPerBar * Config.partsPerBeat - curPart);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbits.write(1, 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet stringLength: number = bits.lengthBase64();\r\n\t\tlet digits: number[] = [];\r\n\t\twhile (stringLength > 0) {\r\n\t\t\tdigits.unshift(base64IntToCharCode[stringLength & 0x3f]);\r\n\t\t\tstringLength = stringLength >> 6;\r\n\t\t}\r\n\t\tbuffer.push(base64IntToCharCode[digits.length]);\r\n\t\tArray.prototype.push.apply(buffer, digits); // append digits to buffer.\r\n\t\tbits.encodeBase64(buffer);\r\n\t\t\r\n\t\tconst maxApplyArgs: number = 64000;\r\n\t\tif (buffer.length < maxApplyArgs) {\r\n\t\t\t// Note: Function.apply may break for long argument lists. \r\n\t\t\treturn String.fromCharCode.apply(null, buffer);\r\n\t\t} else {\r\n\t\t\tlet result: string = \"\";\r\n\t\t\tfor (let i: number = 0; i < buffer.length; i += maxApplyArgs) {\r\n\t\t\t\tresult += String.fromCharCode.apply(null, buffer.slice(i, i + maxApplyArgs));\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate static _envelopeFromLegacyIndex(legacyIndex: number): Envelope {\r\n\t\t// I swapped the order of \"custom\"/\"steady\", now \"none\"/\"note size\".\r\n\t\tif (legacyIndex == 0) legacyIndex = 1; else if (legacyIndex == 1) legacyIndex = 0;\r\n\t\treturn Config.envelopes[clamp(0, Config.envelopes.length, legacyIndex)];\r\n\t}\r\n\t\r\n\tpublic fromBase64String(compressed: string): void {\r\n\t\tif (compressed == null || compressed == \"\") {\r\n\t\t\tthis.initToDefault(true);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet charIndex: number = 0;\r\n\t\t// skip whitespace.\r\n\t\twhile (compressed.charCodeAt(charIndex) <= CharCode.SPACE) charIndex++;\r\n\t\t// skip hash mark.\r\n\t\tif (compressed.charCodeAt(charIndex) == CharCode.HASH) charIndex++;\r\n\t\t// if it starts with curly brace, treat it as JSON.\r\n\t\tif (compressed.charCodeAt(charIndex) == CharCode.LEFT_CURLY_BRACE) {\r\n\t\t\tthis.fromJsonObject(JSON.parse(charIndex == 0 ? compressed : compressed.substring(charIndex)));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tconst version: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\tif (version == -1 || version > Song._latestVersion || version < Song._oldestVersion) return;\r\n\t\tconst beforeThree: boolean = version < 3;\r\n\t\tconst beforeFour:  boolean = version < 4;\r\n\t\tconst beforeFive:  boolean = version < 5;\r\n\t\tconst beforeSix:   boolean = version < 6;\r\n\t\tconst beforeSeven: boolean = version < 7;\r\n\t\tconst beforeEight: boolean = version < 8;\r\n\t\tconst beforeNine:  boolean = version < 9;\r\n\t\tthis.initToDefault(beforeNine);\r\n\t\t\r\n\t\tif (beforeThree) {\r\n\t\t\t// Originally, the only instrument transition was \"instant\" and the only drum wave was \"retro\".\r\n\t\t\tfor (const channel of this.channels) {\r\n\t\t\t\tchannel.instruments[0].transition = Config.transitions.dictionary[\"interrupt\"].index;\r\n\t\t\t\tchannel.instruments[0].effects |= 1 << EffectType.transition;\r\n\t\t\t}\r\n\t\t\tthis.channels[3].instruments[0].chipNoise = 0;\r\n\t\t}\r\n\t\t\r\n\t\tlet legacySettingsCache: LegacySettings[][] | null = null;\r\n\t\tif (beforeNine) {\r\n\t\t\t// Unfortunately, old versions of BeepBox had a variety of different ways of saving\r\n\t\t\t// filter-and-envelope-related parameters in the URL, and none of them directly\r\n\t\t\t// correspond to the new way of saving these parameters. We can approximate the old\r\n\t\t\t// settings by collecting all the old settings for an instrument and passing them to\r\n\t\t\t// convertLegacySettings(), so I use this data structure to collect the settings\r\n\t\t\t// for each instrument if necessary.\r\n\t\t\tlegacySettingsCache = [];\r\n\t\t\tfor (let i: number = legacySettingsCache.length; i < this.getChannelCount(); i++) {\r\n\t\t\t\tlegacySettingsCache[i] = [];\r\n\t\t\t\tfor (let j: number = 0; j < Config.instrumentCountMin; j++) legacySettingsCache[i][j] = {};\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlet legacyGlobalReverb: number = 0; // beforeNine reverb was song-global, record that reverb here and adapt it to instruments as needed.\r\n\t\t\r\n\t\tlet instrumentChannelIterator: number = 0;\r\n\t\tlet instrumentIndexIterator: number = -1;\r\n\t\tlet command: SongTagCode;\r\n\t\twhile (charIndex < compressed.length) switch(command = compressed.charCodeAt(charIndex++)) {\r\n\t\t\tcase SongTagCode.channelCount: {\r\n\t\t\t\tthis.pitchChannelCount = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\tthis.noiseChannelCount = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\tthis.pitchChannelCount = validateRange(Config.pitchChannelCountMin, Config.pitchChannelCountMax, this.pitchChannelCount);\r\n\t\t\t\tthis.noiseChannelCount = validateRange(Config.noiseChannelCountMin, Config.noiseChannelCountMax, this.noiseChannelCount);\r\n\t\t\t\tfor (let channelIndex = this.channels.length; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\tthis.channels[channelIndex] = new Channel();\r\n\t\t\t\t}\r\n\t\t\t\tthis.channels.length = this.getChannelCount();\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tfor (let i: number = legacySettingsCache!.length; i < this.getChannelCount(); i++) {\r\n\t\t\t\t\t\tlegacySettingsCache![i] = [];\r\n\t\t\t\t\t\tfor (let j: number = 0; j < Config.instrumentCountMin; j++) legacySettingsCache![i][j] = {};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.scale: {\r\n\t\t\t\tthis.scale = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\tif (beforeThree && this.scale == 10) this.scale = 11;\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.key: {\r\n\t\t\t\tif (beforeSeven) {\r\n\t\t\t\t\tthis.key = clamp(0, Config.keys.length, 11 - base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.key = clamp(0, Config.keys.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.loopStart: {\r\n\t\t\t\tif (beforeFive) {\r\n\t\t\t\t\tthis.loopStart = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.loopStart = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.loopEnd: {\r\n\t\t\t\tif (beforeFive) {\r\n\t\t\t\t\tthis.loopLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.loopLength = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.tempo: {\r\n\t\t\t\tif (beforeFour) {\r\n\t\t\t\t\tthis.tempo = [95, 120, 151, 190][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];\r\n\t\t\t\t} else if (beforeSeven) {\r\n\t\t\t\t\tthis.tempo = [88, 95, 103, 111, 120, 130, 140, 151, 163, 176, 190, 206, 222, 240, 259][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.tempo = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t}\r\n\t\t\t\tthis.tempo = clamp(Config.tempoMin, Config.tempoMax + 1, this.tempo);\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.reverb: {\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tlegacyGlobalReverb = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tlegacyGlobalReverb = clamp(0, 4, legacyGlobalReverb);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Do nothing? This song tag code is deprecated for now.\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.beatCount: {\r\n\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\tthis.beatsPerBar = [6, 7, 8, 9, 10][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.beatsPerBar = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n\t\t\t\t}\r\n\t\t\t\tthis.beatsPerBar = Math.max(Config.beatsPerBarMin, Math.min(Config.beatsPerBarMax, this.beatsPerBar));\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.barCount: {\r\n\t\t\t\tconst barCount: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n\t\t\t\tthis.barCount = validateRange(Config.barCountMin, Config.barCountMax, barCount);\r\n\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\tfor (let bar = this.channels[channelIndex].bars.length; bar < this.barCount; bar++) {\r\n\t\t\t\t\t\tthis.channels[channelIndex].bars[bar] = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.channels[channelIndex].bars.length = this.barCount;\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.patternCount: {\r\n\t\t\t\tlet patternsPerChannel: number;\r\n\t\t\t\tif (beforeEight) {\r\n\t\t\t\t\tpatternsPerChannel = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpatternsPerChannel = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n\t\t\t\t}\r\n\t\t\t\tthis.patternsPerChannel = validateRange(1, Config.barCountMax, patternsPerChannel);\r\n\t\t\t\tconst channelCount: number = this.getChannelCount();\r\n\t\t\t\tfor (let channelIndex: number = 0; channelIndex < channelCount; channelIndex++) {\r\n\t\t\t\t\tconst patterns: Pattern[] = this.channels[channelIndex].patterns;\r\n\t\t\t\t\tfor (let pattern = patterns.length; pattern < this.patternsPerChannel; pattern++) {\r\n\t\t\t\t\t\tpatterns[pattern] = new Pattern();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpatterns.length = this.patternsPerChannel;\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.instrumentCount: {\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tconst instrumentsPerChannel: number = validateRange(Config.instrumentCountMin, Config.patternInstrumentCountMax, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + Config.instrumentCountMin);\r\n\t\t\t\t\tthis.layeredInstruments = false;\r\n\t\t\t\t\tthis.patternInstruments = (instrumentsPerChannel > 1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\tconst isNoiseChannel: boolean = channelIndex >= this.pitchChannelCount;\r\n\t\t\t\t\t\tfor (let instrumentIndex: number = this.channels[channelIndex].instruments.length; instrumentIndex < instrumentsPerChannel; instrumentIndex++) {\r\n\t\t\t\t\t\t\tthis.channels[channelIndex].instruments[instrumentIndex] = new Instrument(isNoiseChannel);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.channels[channelIndex].instruments.length = instrumentsPerChannel;\r\n\t\t\t\t\t\tif (beforeSix) {\r\n\t\t\t\t\t\t\tfor (let instrumentIndex: number = 0; instrumentIndex < instrumentsPerChannel; instrumentIndex++) {\r\n\t\t\t\t\t\t\t\tthis.channels[channelIndex].instruments[instrumentIndex].setTypeAndReset(isNoiseChannel ? InstrumentType.noise : InstrumentType.chip, isNoiseChannel);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (let j: number = legacySettingsCache![channelIndex].length; j < instrumentsPerChannel; j++) {\r\n\t\t\t\t\t\t\tlegacySettingsCache![channelIndex][j] = {};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst instrumentsFlagBits: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tthis.layeredInstruments = (instrumentsFlagBits & (1 << 1)) != 0;\r\n\t\t\t\t\tthis.patternInstruments = (instrumentsFlagBits & (1 << 0)) != 0;\r\n\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\tlet instrumentCount: number = 1;\r\n\t\t\t\t\t\tif (this.layeredInstruments || this.patternInstruments) {\r\n\t\t\t\t\t\t\tinstrumentCount = validateRange(Config.instrumentCountMin, this.getMaxInstrumentsPerChannel(), base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + Config.instrumentCountMin);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst channel: Channel = this.channels[channelIndex];\r\n\t\t\t\t\t\tconst isNoiseChannel: boolean = this.getChannelIsNoise(channelIndex);\r\n\t\t\t\t\t\tfor (let i: number = channel.instruments.length; i < instrumentCount; i++) {\r\n\t\t\t\t\t\t\tchannel.instruments[i] = new Instrument(isNoiseChannel);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tchannel.instruments.length = instrumentCount;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.rhythm: {\r\n\t\t\t\tthis.rhythm = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.channelOctave: {\r\n\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\tconst channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tthis.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);\r\n\t\t\t\t\tif (channelIndex >= this.pitchChannelCount) this.channels[channelIndex].octave = 0;\r\n\t\t\t\t} else if (beforeNine) {\r\n\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\tthis.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);\r\n\t\t\t\t\t\tif (channelIndex >= this.pitchChannelCount) this.channels[channelIndex].octave = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.pitchChannelCount; channelIndex++) {\r\n\t\t\t\t\t\tthis.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (let channelIndex: number = this.pitchChannelCount; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\tthis.channels[channelIndex].octave = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.startInstrument: {\r\n\t\t\t\tinstrumentIndexIterator++;\r\n\t\t\t\tif (instrumentIndexIterator >= this.channels[instrumentChannelIterator].instruments.length) {\r\n\t\t\t\t\tinstrumentChannelIterator++;\r\n\t\t\t\t\tinstrumentIndexIterator = 0;\r\n\t\t\t\t}\r\n\t\t\t\tvalidateRange(0, this.channels.length - 1, instrumentChannelIterator);\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tconst instrumentType: number = validateRange(0, InstrumentType.length - 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\tinstrument.setTypeAndReset(instrumentType, instrumentChannelIterator >= this.pitchChannelCount);\r\n\t\t\t\t\r\n\t\t\t\tif (beforeSeven) {\r\n\t\t\t\t\tinstrument.effects = 0;\r\n\t\t\t\t\t// the reverb effect was applied to all pitched instruments if nonzero but never explicitly enabled if beforeSeven, so enable it here.\r\n\t\t\t\t\tif (legacyGlobalReverb > 0 && !this.getChannelIsNoise(instrumentChannelIterator)) {\r\n\t\t\t\t\t\tinstrument.reverb = legacyGlobalReverb;\r\n\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.reverb;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Chip/noise instruments had arpeggio and FM had custom interval but neither\r\n\t\t\t\t\t// explicitly saved the chorus setting beforeSeven so enable it here.\r\n\t\t\t\t\tif (instrument.chord != Config.chords.dictionary[\"simultaneous\"].index) {\r\n\t\t\t\t\t\t// Enable chord if it was used.\r\n\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.chord;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.preset: {\r\n\t\t\t\tconst presetValue: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = presetValue;\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.wave: {\r\n\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\tconst legacyWaves: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 0];\r\n\t\t\t\t\tconst channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n\t\t\t\t\tinstrument.chipWave = clamp(0, Config.chipWaves.length, legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]] | 0);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Version 2 didn't save any settings for settings for filters, or envelopes,\r\n\t\t\t\t\t// just waves, so initialize them here I guess.\r\n\t\t\t\t\tinstrument.convertLegacySettings(legacySettingsCache![channelIndex][0]);\r\n\t\t\t\t\t\r\n\t\t\t\t} else if (beforeSix) {\r\n\t\t\t\t\tconst legacyWaves: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 0];\r\n\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\tfor (const instrument of this.channels[channelIndex].instruments) {\r\n\t\t\t\t\t\t\tif (channelIndex >= this.pitchChannelCount) {\r\n\t\t\t\t\t\t\t\tinstrument.chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tinstrument.chipWave = clamp(0, Config.chipWaves.length, legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]] | 0);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (beforeSeven) {\r\n\t\t\t\t\tconst legacyWaves: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 0];\r\n\t\t\t\t\tif (instrumentChannelIterator >= this.pitchChannelCount) {\r\n\t\t\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipWave = clamp(0, Config.chipWaves.length, legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]] | 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (instrumentChannelIterator >= this.pitchChannelCount) {\r\n\t\t\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipWave = clamp(0, Config.chipWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.eqFilter: {\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tif (beforeSeven) {\r\n\t\t\t\t\t\tconst legacyToCutoff: number[] = [10, 6, 3, 0, 8, 5, 2];\r\n\t\t\t\t\t\tconst legacyToEnvelope: string[] = [\"none\", \"none\", \"none\", \"none\", \"decay 1\", \"decay 2\", \"decay 3\"];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\t\t\tconst channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\t\t\tconst instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n\t\t\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![channelIndex][0];\r\n\t\t\t\t\t\t\tconst legacyFilter: number = [1, 3, 4, 5][clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];\r\n\t\t\t\t\t\t\tlegacySettings.filterCutoff = legacyToCutoff[legacyFilter];\r\n\t\t\t\t\t\t\tlegacySettings.filterResonance = 0;\r\n\t\t\t\t\t\t\tlegacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];\r\n\t\t\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t\t\t} else if (beforeSix) {\r\n\t\t\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\t\t\tfor (let i: number = 0; i < this.channels[channelIndex].instruments.length; i++) {\r\n\t\t\t\t\t\t\t\t\tconst instrument: Instrument = this.channels[channelIndex].instruments[i];\r\n\t\t\t\t\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![channelIndex][i];\r\n\t\t\t\t\t\t\t\t\tconst legacyFilter: number = clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);\r\n\t\t\t\t\t\t\t\t\tif (channelIndex < this.pitchChannelCount) {\r\n\t\t\t\t\t\t\t\t\t\tlegacySettings.filterCutoff = legacyToCutoff[legacyFilter];\r\n\t\t\t\t\t\t\t\t\t\tlegacySettings.filterResonance = 0;\r\n\t\t\t\t\t\t\t\t\t\tlegacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tlegacySettings.filterCutoff = 10;\r\n\t\t\t\t\t\t\t\t\t\tlegacySettings.filterResonance = 0;\r\n\t\t\t\t\t\t\t\t\t\tlegacySettings.filterEnvelope = Config.envelopes.dictionary[\"none\"];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tconst legacyFilter: number = clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\t\t\tlegacySettings.filterCutoff = legacyToCutoff[legacyFilter];\r\n\t\t\t\t\t\t\tlegacySettings.filterResonance = 0;\r\n\t\t\t\t\t\t\tlegacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];\r\n\t\t\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconst filterCutoffRange: number = 11;\r\n\t\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\t\tlegacySettings.filterCutoff = clamp(0, filterCutoffRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\tconst originalControlPointCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tinstrument.eqFilter.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalControlPointCount);\r\n\t\t\t\t\tfor (let i: number = instrument.eqFilter.controlPoints.length; i < instrument.eqFilter.controlPointCount; i++) {\r\n\t\t\t\t\t\tinstrument.eqFilter.controlPoints[i] = new FilterControlPoint();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (let i: number = 0; i < instrument.eqFilter.controlPointCount; i++) {\r\n\t\t\t\t\t\tconst point: FilterControlPoint = instrument.eqFilter.controlPoints[i];\r\n\t\t\t\t\t\tpoint.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\tpoint.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\tpoint.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (let i: number = instrument.eqFilter.controlPointCount; i < originalControlPointCount; i++) {\r\n\t\t\t\t\t\tcharIndex += 3;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.filterResonance: {\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tconst filterResonanceRange: number = 8;\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\tlegacySettings.filterResonance = clamp(0, filterResonanceRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Do nothing? This song tag code is deprecated for now.\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.drumsetEnvelopes: {\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tif (instrument.type == InstrumentType.drumset) {\r\n\t\t\t\t\t\tfor (let i: number = 0; i < Config.drumCount; i++) {\r\n\t\t\t\t\t\t\tinstrument.drumsetEnvelopes[i] = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]).index;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// This used to be used for general filter envelopes.\r\n\t\t\t\t\t\t// The presence of an envelope affects how convertLegacySettings\r\n\t\t\t\t\t\t// decides the closest possible approximation, so update it.\r\n\t\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\t\tlegacySettings.filterEnvelope = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// This tag is now only used for drumset filter envelopes.\r\n\t\t\t\t\tfor (let i: number = 0; i < Config.drumCount; i++) {\r\n\t\t\t\t\t\tinstrument.drumsetEnvelopes[i] = clamp(0, Config.envelopes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.pulseWidth: {\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tinstrument.pulseWidth = clamp(0, Config.pulseWidthRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\tlegacySettings.pulseEnvelope = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.supersaw: {\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tinstrument.supersawDynamism = clamp(0, Config.supersawDynamismMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\tinstrument.supersawSpread = clamp(0, Config.supersawSpreadMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\tinstrument.supersawShape = clamp(0, Config.supersawShapeMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.stringSustain: {\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tconst sustainValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\tinstrument.stringSustain = clamp(0, Config.stringSustainRange, sustainValue & 0x1F);\r\n\t\t\t\tinstrument.stringSustainType = Config.enableAcousticSustain ? clamp(0, SustainType.length, sustainValue >> 5) : SustainType.bright;\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.fadeInOut: {\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\t// this tag was used for a combination of transition and fade in/out.\r\n\t\t\t\t\tconst legacySettings = [\r\n\t\t\t\t\t\t{transition: \"interrupt\", fadeInSeconds: 0.0,    fadeOutTicks: -1},\r\n\t\t\t\t\t\t{transition: \"normal\",    fadeInSeconds: 0.0,    fadeOutTicks: -3},\r\n\t\t\t\t\t\t{transition: \"normal\",    fadeInSeconds: 0.025,  fadeOutTicks: -3},\r\n\t\t\t\t\t\t{transition: \"slide in pattern\", fadeInSeconds: 0.025,  fadeOutTicks: -3},\r\n\t\t\t\t\t\t{transition: \"normal\",    fadeInSeconds: 0.04,   fadeOutTicks:  6},\r\n\t\t\t\t\t\t{transition: \"normal\",    fadeInSeconds: 0.0,    fadeOutTicks: 48},\r\n\t\t\t\t\t\t{transition: \"normal\",    fadeInSeconds: 0.0125, fadeOutTicks: 72},\r\n\t\t\t\t\t\t{transition: \"normal\",    fadeInSeconds: 0.06,   fadeOutTicks: 96},\r\n\t\t\t\t\t];\r\n\t\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\t\tconst channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\t\tconst settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];\r\n\t\t\t\t\t\tconst instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n\t\t\t\t\t\tinstrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);\r\n\t\t\t\t\t\tinstrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);\r\n\t\t\t\t\t\tinstrument.transition = Config.transitions.dictionary[settings.transition].index;\r\n\t\t\t\t\t\tif (instrument.transition != Config.transitions.dictionary[\"normal\"].index) {\r\n\t\t\t\t\t\t\t// Enable transition if it was used.\r\n\t\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.transition;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (beforeSix) {\r\n\t\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\t\tfor (const instrument of this.channels[channelIndex].instruments) {\r\n\t\t\t\t\t\t\t\tconst settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];\r\n\t\t\t\t\t\t\t\tinstrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);\r\n\t\t\t\t\t\t\t\tinstrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);\r\n\t\t\t\t\t\t\t\tinstrument.transition = Config.transitions.dictionary[settings.transition].index;\r\n\t\t\t\t\t\t\t\tif (instrument.transition != Config.transitions.dictionary[\"normal\"].index) {\r\n\t\t\t\t\t\t\t\t\t// Enable transition if it was used.\r\n\t\t\t\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.transition;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconst settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];\r\n\t\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\t\tinstrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);\r\n\t\t\t\t\t\tinstrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);\r\n\t\t\t\t\t\tinstrument.transition = Config.transitions.dictionary[settings.transition].index;\r\n\t\t\t\t\t\tif (instrument.transition != Config.transitions.dictionary[\"normal\"].index) {\r\n\t\t\t\t\t\t\t// Enable transition if it was used.\r\n\t\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.transition;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\tinstrument.fadeIn = clamp(0, Config.fadeInRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\tinstrument.fadeOut = clamp(0, Config.fadeOutTicks.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.vibrato: {\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tif (beforeSeven) {\r\n\t\t\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\t\t\tconst legacyEffects: number[] = [0, 3, 2, 0];\r\n\t\t\t\t\t\t\tconst legacyEnvelopes: string[] = [\"none\", \"none\", \"none\", \"tremolo2\"];\r\n\t\t\t\t\t\t\tconst channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\t\t\tconst effect: number = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t\tconst instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n\t\t\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![channelIndex][0];\r\n\t\t\t\t\t\t\tinstrument.vibrato = legacyEffects[effect];\r\n\t\t\t\t\t\t\tif (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == EnvelopeType.none) {\r\n\t\t\t\t\t\t\t\t// Imitate the legacy tremolo with a filter envelope.\r\n\t\t\t\t\t\t\t\tlegacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];\r\n\t\t\t\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n\t\t\t\t\t\t\t\t// Enable vibrato if it was used.\r\n\t\t\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.vibrato;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (beforeSix) {\r\n\t\t\t\t\t\t\tconst legacyEffects: number[] = [0, 1, 2, 3, 0, 0];\r\n\t\t\t\t\t\t\tconst legacyEnvelopes: string[] = [\"none\", \"none\", \"none\", \"none\", \"tremolo5\", \"tremolo2\"];\r\n\t\t\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\t\t\tfor (let i: number = 0; i < this.channels[channelIndex].instruments.length; i++) {\r\n\t\t\t\t\t\t\t\t\tconst effect: number = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t\t\t\tconst instrument: Instrument = this.channels[channelIndex].instruments[i];\r\n\t\t\t\t\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![channelIndex][i];\r\n\t\t\t\t\t\t\t\t\tinstrument.vibrato = legacyEffects[effect];\r\n\t\t\t\t\t\t\t\t\tif (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == EnvelopeType.none) {\r\n\t\t\t\t\t\t\t\t\t\t// Imitate the legacy tremolo with a filter envelope.\r\n\t\t\t\t\t\t\t\t\t\tlegacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];\r\n\t\t\t\t\t\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n\t\t\t\t\t\t\t\t\t\t// Enable vibrato if it was used.\r\n\t\t\t\t\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.vibrato;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (legacyGlobalReverb != 0 && !this.getChannelIsNoise(channelIndex)) {\r\n\t\t\t\t\t\t\t\t\t\t// Enable reverb if it was used globaly before. (Global reverb was added before the effects option so I need to pick somewhere else to initialize instrument reverb, and I picked the vibrato command.)\r\n\t\t\t\t\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.reverb;\r\n\t\t\t\t\t\t\t\t\t\tinstrument.reverb = legacyGlobalReverb;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tconst legacyEffects: number[] = [0, 1, 2, 3, 0, 0];\r\n\t\t\t\t\t\t\tconst legacyEnvelopes: string[] = [\"none\", \"none\", \"none\", \"none\", \"tremolo5\", \"tremolo2\"];\r\n\t\t\t\t\t\t\tconst effect: number = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\t\t\tinstrument.vibrato = legacyEffects[effect];\r\n\t\t\t\t\t\t\tif (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == EnvelopeType.none) {\r\n\t\t\t\t\t\t\t\t// Imitate the legacy tremolo with a filter envelope.\r\n\t\t\t\t\t\t\t\tlegacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];\r\n\t\t\t\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n\t\t\t\t\t\t\t\t// Enable vibrato if it was used.\r\n\t\t\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.vibrato;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (legacyGlobalReverb != 0) {\r\n\t\t\t\t\t\t\t\t// Enable reverb if it was used globaly before. (Global reverb was added before the effects option so I need to pick somewhere else to initialize instrument reverb, and I picked the vibrato command.)\r\n\t\t\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.reverb;\r\n\t\t\t\t\t\t\t\tinstrument.reverb = legacyGlobalReverb;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\t\tconst vibrato: number = clamp(0, Config.vibratos.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\tinstrument.vibrato = vibrato;\r\n\t\t\t\t\t\tif (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n\t\t\t\t\t\t\t// Enable vibrato if it was used.\r\n\t\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.vibrato;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Do nothing? This song tag code is deprecated for now.\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.unison: {\r\n\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\tconst channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tthis.channels[channelIndex].instruments[0].unison = clamp(0, Config.unisons.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t} else if (beforeSix) {\r\n\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\tfor (const instrument of this.channels[channelIndex].instruments) {\r\n\t\t\t\t\t\t\tconst originalValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\t\t\tlet unison: number = clamp(0, Config.unisons.length, originalValue);\r\n\t\t\t\t\t\t\tif (originalValue == 8) {\r\n\t\t\t\t\t\t\t\t// original \"custom harmony\" now maps to \"hum\" and \"custom interval\".\r\n\t\t\t\t\t\t\t\tunison = 2;\r\n\t\t\t\t\t\t\t\tinstrument.chord = 3;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tinstrument.unison = unison;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (beforeSeven) {\r\n\t\t\t\t\tconst originalValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tlet unison: number = clamp(0, Config.unisons.length, originalValue);\r\n\t\t\t\t\tif (originalValue == 8) {\r\n\t\t\t\t\t\t// original \"custom harmony\" now maps to \"hum\" and \"custom interval\".\r\n\t\t\t\t\t\tunison = 2;\r\n\t\t\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chord = 3;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].unison = unison;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].unison = clamp(0, Config.unisons.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.chord: {\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\tinstrument.chord = clamp(0, Config.chords.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\tif (instrument.chord != Config.chords.dictionary[\"simultaneous\"].index) {\r\n\t\t\t\t\t\t// Enable chord if it was used.\r\n\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.chord;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Do nothing? This song tag code is deprecated for now.\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.effects: {\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tinstrument.effects = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] & ((1 << EffectType.length) - 1));\r\n\t\t\t\t\tif (legacyGlobalReverb == 0) {\r\n\t\t\t\t\t\t// Disable reverb if legacy song reverb was zero.\r\n\t\t\t\t\t\tinstrument.effects &= ~(1 << EffectType.reverb);\r\n\t\t\t\t\t} else if (effectsIncludeReverb(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.reverb = legacyGlobalReverb;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (instrument.pan != Config.panCenter) {\r\n\t\t\t\t\t\t// Enable panning if panning slider isn't centered.\r\n\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.panning;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n\t\t\t\t\t\t// Enable vibrato if it was used.\r\n\t\t\t\t\t\tinstrument.effects |= 1 << EffectType.panning;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// convertLegacySettings may need to force-enable note filter, call\r\n\t\t\t\t\t// it again here to make sure that this override takes precedence.\r\n\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// BeepBox currently uses two base64 characters at 6 bits each for a bitfield representing all the enabled effects.\r\n\t\t\t\t\tif (EffectType.length > 12) throw new Error();\r\n\t\t\t\t\tinstrument.effects = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (effectsIncludeNoteFilter(instrument.effects)) {\r\n\t\t\t\t\t\tconst originalControlPointCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\t\tinstrument.noteFilter.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalControlPointCount);\r\n\t\t\t\t\t\tfor (let i: number = instrument.noteFilter.controlPoints.length; i < instrument.noteFilter.controlPointCount; i++) {\r\n\t\t\t\t\t\t\tinstrument.noteFilter.controlPoints[i] = new FilterControlPoint();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let i: number = 0; i < instrument.noteFilter.controlPointCount; i++) {\r\n\t\t\t\t\t\t\tconst point: FilterControlPoint = instrument.noteFilter.controlPoints[i];\r\n\t\t\t\t\t\t\tpoint.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t\tpoint.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t\tpoint.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let i: number = instrument.noteFilter.controlPointCount; i < originalControlPointCount; i++) {\r\n\t\t\t\t\t\t\tcharIndex += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludeTransition(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.transition = clamp(0, Config.transitions.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludeChord(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.chord = clamp(0, Config.chords.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludePitchShift(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.pitchShift = clamp(0, Config.pitchShiftRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludeDetune(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.detune = clamp(0, Config.detuneMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludeVibrato(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.vibrato = clamp(0, Config.vibratos.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludeDistortion(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.distortion = clamp(0, Config.distortionRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludeBitcrusher(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.bitcrusherFreq = clamp(0, Config.bitcrusherFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\tinstrument.bitcrusherQuantization = clamp(0, Config.bitcrusherQuantizationRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludePanning(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.pan = clamp(0, Config.panMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludeChorus(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.chorus = clamp(0, Config.chorusRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludeEcho(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.echoSustain = clamp(0, Config.echoSustainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\tinstrument.echoDelay = clamp(0, Config.echoDelayRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (effectsIncludeReverb(instrument.effects)) {\r\n\t\t\t\t\t\tinstrument.reverb = clamp(0, Config.reverbRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Clamp the range.\r\n\t\t\t\tinstrument.effects &= (1 << EffectType.length) - 1;\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.volume: {\r\n\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\tconst channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n\t\t\t\t\tinstrument.volume = clamp(0, Config.volumeRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t// legacy mute value:\r\n\t\t\t\t\tif (instrument.volume == 5) instrument.volume = Config.volumeRange - 1;\r\n\t\t\t\t} else if (beforeSix) {\r\n\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\tfor (const instrument of this.channels[channelIndex].instruments) {\r\n\t\t\t\t\t\t\tinstrument.volume = clamp(0, Config.volumeRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t\t// legacy mute value:\r\n\t\t\t\t\t\t\tif (instrument.volume == 5) instrument.volume = Config.volumeRange - 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (beforeSeven) {\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\tinstrument.volume = clamp(0, Config.volumeRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t// legacy mute value:\r\n\t\t\t\t\tif (instrument.volume == 5) instrument.volume = Config.volumeRange - 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\tinstrument.volume = clamp(0, Config.volumeRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.pan: {\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\tinstrument.pan = clamp(0, Config.panMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Do nothing? This song tag code is deprecated for now.\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.algorithm: {\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tinstrument.algorithm = clamp(0, Config.algorithms.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\t// The algorithm determines the carrier count, which affects how legacy settings are imported.\r\n\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.feedbackType: {\r\n\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].feedbackType = clamp(0, Config.feedbacks.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.feedbackAmplitude: {\r\n\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].feedbackAmplitude = clamp(0, Config.operatorAmplitudeMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.feedbackEnvelope: {\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\tlegacySettings.feedbackEnvelope = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Do nothing? This song tag code is deprecated for now.\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.operatorFrequencies: {\r\n\t\t\t\tfor (let o: number = 0; o < Config.operatorCount; o++) {\r\n\t\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].operators[o].frequency = clamp(0, Config.operatorFrequencies.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.operatorAmplitudes: {\r\n\t\t\t\tfor (let o: number = 0; o < Config.operatorCount; o++) {\r\n\t\t\t\t\tthis.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].operators[o].amplitude = clamp(0, Config.operatorAmplitudeMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.envelopes: {\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\tconst legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n\t\t\t\t\tlegacySettings.operatorEnvelopes = [];\r\n\t\t\t\t\tfor (let o: number = 0; o < Config.operatorCount; o++) {\r\n\t\t\t\t\t\tlegacySettings.operatorEnvelopes[o] = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinstrument.convertLegacySettings(legacySettings);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst envelopeCount: number = clamp(0, Config.maxEnvelopeCount + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\tfor (let i: number = 0; i < envelopeCount; i++) {\r\n\t\t\t\t\t\tconst target: number = clamp(0, Config.instrumentAutomationTargets.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\tlet index: number = 0;\r\n\t\t\t\t\t\tconst maxCount: number = Config.instrumentAutomationTargets[target].maxCount;\r\n\t\t\t\t\t\tif (maxCount > 1) {\r\n\t\t\t\t\t\t\tindex = clamp(0, maxCount, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst envelope: number = clamp(0, Config.envelopes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\t\tinstrument.addEnvelope(target, index, envelope);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.spectrum: {\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tif (instrument.type == InstrumentType.spectrum) {\r\n\t\t\t\t\tconst byteCount: number = Math.ceil(Config.spectrumControlPoints * Config.spectrumControlPointBits / 6)\r\n\t\t\t\t\tconst bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + byteCount);\r\n\t\t\t\t\tfor (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n\t\t\t\t\t\tinstrument.spectrumWave.spectrum[i] = bits.read(Config.spectrumControlPointBits);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinstrument.spectrumWave.markCustomWaveDirty();\r\n\t\t\t\t\tcharIndex += byteCount;\r\n\t\t\t\t} else if (instrument.type == InstrumentType.drumset) {\r\n\t\t\t\t\tconst byteCount: number = Math.ceil(Config.drumCount * Config.spectrumControlPoints * Config.spectrumControlPointBits / 6)\r\n\t\t\t\t\tconst bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + byteCount);\r\n\t\t\t\t\tfor (let j: number = 0; j < Config.drumCount; j++) {\r\n\t\t\t\t\t\tfor (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n\t\t\t\t\t\t\tinstrument.drumsetSpectrumWaves[j].spectrum[i] = bits.read(Config.spectrumControlPointBits);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tinstrument.drumsetSpectrumWaves[j].markCustomWaveDirty();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcharIndex += byteCount;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(\"Unhandled instrument type for spectrum song tag code.\");\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.harmonics: {\r\n\t\t\t\tconst instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\t\t\t\tconst byteCount: number = Math.ceil(Config.harmonicsControlPoints * Config.harmonicsControlPointBits / 6)\r\n\t\t\t\tconst bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + byteCount);\r\n\t\t\t\tfor (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n\t\t\t\t\tinstrument.harmonicsWave.harmonics[i] = bits.read(Config.harmonicsControlPointBits);\r\n\t\t\t\t}\r\n\t\t\t\tinstrument.harmonicsWave.markCustomWaveDirty();\r\n\t\t\t\tcharIndex += byteCount;\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.bars: {\r\n\t\t\t\tlet subStringLength: number;\r\n\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\tconst channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tconst barCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tsubStringLength = Math.ceil(barCount * 0.5);\r\n\t\t\t\t\tconst bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + subStringLength);\r\n\t\t\t\t\tfor (let i: number = 0; i < barCount; i++) {\r\n\t\t\t\t\t\tthis.channels[channelIndex].bars[i] = bits.read(3) + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (beforeFive) {\r\n\t\t\t\t\tlet neededBits: number = 0;\r\n\t\t\t\t\twhile ((1 << neededBits) < this.patternsPerChannel) neededBits++;\r\n\t\t\t\t\tsubStringLength = Math.ceil(this.getChannelCount() * this.barCount * neededBits / 6);\r\n\t\t\t\t\tconst bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + subStringLength);\r\n\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\tfor (let i: number = 0; i < this.barCount; i++) {\r\n\t\t\t\t\t\t\tthis.channels[channelIndex].bars[i] = bits.read(neededBits) + 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet neededBits: number = 0;\r\n\t\t\t\t\twhile ((1 << neededBits) < this.patternsPerChannel + 1) neededBits++;\r\n\t\t\t\t\tsubStringLength = Math.ceil(this.getChannelCount() * this.barCount * neededBits / 6);\r\n\t\t\t\t\tconst bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + subStringLength);\r\n\t\t\t\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\t\t\t\tfor (let i: number = 0; i < this.barCount; i++) {\r\n\t\t\t\t\t\t\tthis.channels[channelIndex].bars[i] = bits.read(neededBits);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcharIndex += subStringLength;\r\n\t\t\t} break;\r\n\t\t\tcase SongTagCode.patterns: {\r\n\t\t\t\tlet bitStringLength: number = 0;\r\n\t\t\t\tlet channelIndex: number;\r\n\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\tchannelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// The old format used the next character to represent the number of patterns in the channel, which is usually eight, the default. \r\n\t\t\t\t\tcharIndex++; //let patternCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\t\r\n\t\t\t\t\tbitStringLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\tbitStringLength = bitStringLength << 6;\r\n\t\t\t\t\tbitStringLength += base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchannelIndex = 0;\r\n\t\t\t\t\tlet bitStringLengthLength: number = validateRange(1, 4, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\t\t\t\t\twhile (bitStringLengthLength > 0) {\r\n\t\t\t\t\t\tbitStringLength = bitStringLength << 6;\r\n\t\t\t\t\t\tbitStringLength += base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\t\t\t\t\t\tbitStringLengthLength--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tconst bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + bitStringLength);\r\n\t\t\t\tcharIndex += bitStringLength;\r\n\t\t\t\t\r\n\t\t\t\tconst bitsPerNoteSize: number = Song.getNeededBits(Config.noteSizeMax);\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\tconst channel: Channel = this.channels[channelIndex];\r\n\t\t\t\t\tconst isNoiseChannel: boolean = this.getChannelIsNoise(channelIndex);\r\n\t\t\t\t\tconst maxInstrumentsPerPattern: number = this.getMaxInstrumentsPerPattern(channelIndex);\r\n\t\t\t\t\tconst neededInstrumentCountBits: number = Song.getNeededBits(maxInstrumentsPerPattern - Config.instrumentCountMin);\r\n\t\t\t\t\tconst neededInstrumentIndexBits: number = Song.getNeededBits(channel.instruments.length - 1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst octaveOffset: number = isNoiseChannel ? 0 : channel.octave * 12;\r\n\t\t\t\t\tlet lastPitch: number = (isNoiseChannel ? 4 : octaveOffset);\r\n\t\t\t\t\tconst recentPitches: number[] = isNoiseChannel ? [4,6,7,2,3,8,0,10] : [0, 7, 12, 19, 24, -5, -12];\r\n\t\t\t\t\tconst recentShapes: any[] = [];\r\n\t\t\t\t\tfor (let i: number = 0; i < recentPitches.length; i++) {\r\n\t\t\t\t\t\trecentPitches[i] += octaveOffset;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (let i: number = 0; i < this.patternsPerChannel; i++) {\r\n\t\t\t\t\t\tconst newPattern: Pattern = channel.patterns[i];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (beforeNine) {\r\n\t\t\t\t\t\t\tnewPattern.instruments[0] = validateRange(0, channel.instruments.length - 1, bits.read(neededInstrumentIndexBits));\r\n\t\t\t\t\t\t\tnewPattern.instruments.length = 1;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (this.patternInstruments) {\r\n\t\t\t\t\t\t\t\tconst instrumentCount: number = validateRange(Config.instrumentCountMin, maxInstrumentsPerPattern, bits.read(neededInstrumentCountBits) + Config.instrumentCountMin);\r\n\t\t\t\t\t\t\t\tfor (let j: number = 0; j < instrumentCount; j++) {\r\n\t\t\t\t\t\t\t\t\tnewPattern.instruments[j] = validateRange(0, channel.instruments.length - 1, bits.read(neededInstrumentIndexBits));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tnewPattern.instruments.length = instrumentCount;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tnewPattern.instruments[0] = 0;\r\n\t\t\t\t\t\t\t\tnewPattern.instruments.length = Config.instrumentCountMin;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (!beforeThree && bits.read(1) == 0) {\r\n\t\t\t\t\t\t\tnewPattern.notes.length = 0;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet curPart: number = 0;\r\n\t\t\t\t\t\tconst newNotes: Note[] = newPattern.notes;\r\n\t\t\t\t\t\tlet noteCount: number = 0;\r\n\t\t\t\t\t\twhile (curPart < this.beatsPerBar * Config.partsPerBeat) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tconst useOldShape: boolean = bits.read(1) == 1;\r\n\t\t\t\t\t\t\tlet newNote: boolean = false;\r\n\t\t\t\t\t\t\tlet shapeIndex: number = 0;\r\n\t\t\t\t\t\t\tif (useOldShape) {\r\n\t\t\t\t\t\t\t\tshapeIndex = validateRange(0, recentShapes.length - 1, bits.readLongTail(0, 0));\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tnewNote = bits.read(1) == 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (!useOldShape && !newNote) {\r\n\t\t\t\t\t\t\t\tconst restLength: number = beforeSeven\r\n\t\t\t\t\t\t\t\t\t? bits.readLegacyPartDuration() * Config.partsPerBeat / Config.rhythms[this.rhythm].stepsPerBeat\r\n\t\t\t\t\t\t\t\t\t: bits.readPartDuration();\r\n\t\t\t\t\t\t\t\tcurPart += restLength;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tlet shape: any;\r\n\t\t\t\t\t\t\t\tif (useOldShape) {\r\n\t\t\t\t\t\t\t\t\tshape = recentShapes[shapeIndex];\r\n\t\t\t\t\t\t\t\t\trecentShapes.splice(shapeIndex, 1);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tshape = {};\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tshape.pitchCount = 1;\r\n\t\t\t\t\t\t\t\t\twhile (shape.pitchCount < Config.maxChordSize && bits.read(1) == 1) shape.pitchCount++;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tshape.pinCount = bits.readPinCount();\r\n\t\t\t\t\t\t\t\t\tshape.initialSize = bits.read(bitsPerNoteSize);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tshape.pins = [];\r\n\t\t\t\t\t\t\t\t\tshape.length = 0;\r\n\t\t\t\t\t\t\t\t\tshape.bendCount = 0;\r\n\t\t\t\t\t\t\t\t\tfor (let j: number = 0; j < shape.pinCount; j++) {\r\n\t\t\t\t\t\t\t\t\t\tlet pinObj: any = {};\r\n\t\t\t\t\t\t\t\t\t\tpinObj.pitchBend = bits.read(1) == 1;\r\n\t\t\t\t\t\t\t\t\t\tif (pinObj.pitchBend) shape.bendCount++;\r\n\t\t\t\t\t\t\t\t\t\tshape.length += beforeSeven\r\n\t\t\t\t\t\t\t\t\t\t\t? bits.readLegacyPartDuration() * Config.partsPerBeat / Config.rhythms[this.rhythm].stepsPerBeat\r\n\t\t\t\t\t\t\t\t\t\t\t: bits.readPartDuration();\r\n\t\t\t\t\t\t\t\t\t\tpinObj.time = shape.length;\r\n\t\t\t\t\t\t\t\t\t\tpinObj.size = bits.read(bitsPerNoteSize);\r\n\t\t\t\t\t\t\t\t\t\tshape.pins.push(pinObj);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\trecentShapes.unshift(shape);\r\n\t\t\t\t\t\t\t\tif (recentShapes.length > 10) recentShapes.pop(); // TODO: Use Deque?\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tlet note: Note;\r\n\t\t\t\t\t\t\t\tif (newNotes.length <= noteCount) {\r\n\t\t\t\t\t\t\t\t\tnote = new Note(0, curPart, curPart + shape.length, shape.initialSize);\r\n\t\t\t\t\t\t\t\t\tnewNotes[noteCount++] = note;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tnote = newNotes[noteCount++];\r\n\t\t\t\t\t\t\t\t\tnote.start = curPart;\r\n\t\t\t\t\t\t\t\t\tnote.end = curPart + shape.length;\r\n\t\t\t\t\t\t\t\t\tnote.pins[0].size = shape.initialSize;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tlet pitch: number;\r\n\t\t\t\t\t\t\t\tlet pitchCount: number = 0;\r\n\t\t\t\t\t\t\t\tconst pitchBends: number[] = []; // TODO: allocate this array only once! keep separate length and iterator index. Use Deque?\r\n\t\t\t\t\t\t\t\tfor (let j: number = 0; j < shape.pitchCount + shape.bendCount; j++) {\r\n\t\t\t\t\t\t\t\t\tconst useOldPitch: boolean = bits.read(1) == 1;\r\n\t\t\t\t\t\t\t\t\tif (!useOldPitch) {\r\n\t\t\t\t\t\t\t\t\t\tconst interval: number = bits.readPitchInterval();\r\n\t\t\t\t\t\t\t\t\t\tpitch = lastPitch;\r\n\t\t\t\t\t\t\t\t\t\tlet intervalIter: number = interval;\r\n\t\t\t\t\t\t\t\t\t\twhile (intervalIter > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tpitch++;\r\n\t\t\t\t\t\t\t\t\t\t\twhile (recentPitches.indexOf(pitch) != -1) pitch++;\r\n\t\t\t\t\t\t\t\t\t\t\tintervalIter--;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\twhile (intervalIter < 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tpitch--;\r\n\t\t\t\t\t\t\t\t\t\t\twhile (recentPitches.indexOf(pitch) != -1) pitch--;\r\n\t\t\t\t\t\t\t\t\t\t\tintervalIter++;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tconst pitchIndex: number = validateRange(0, recentPitches.length - 1, bits.read(3));\r\n\t\t\t\t\t\t\t\t\t\tpitch = recentPitches[pitchIndex];\r\n\t\t\t\t\t\t\t\t\t\trecentPitches.splice(pitchIndex, 1);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\trecentPitches.unshift(pitch);\r\n\t\t\t\t\t\t\t\t\tif (recentPitches.length > 8) recentPitches.pop();\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif (j < shape.pitchCount) {\r\n\t\t\t\t\t\t\t\t\t\tnote.pitches[pitchCount++] = pitch;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tpitchBends.push(pitch);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif (j == shape.pitchCount - 1) {\r\n\t\t\t\t\t\t\t\t\t\tlastPitch = note.pitches[0];\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tlastPitch = pitch;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tnote.pitches.length = pitchCount;\r\n\t\t\t\t\t\t\t\tpitchBends.unshift(note.pitches[0]); // TODO: Use Deque?\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tlet pinCount: number = 1;\r\n\t\t\t\t\t\t\t\tfor (const pinObj of shape.pins) {\r\n\t\t\t\t\t\t\t\t\tif (pinObj.pitchBend) pitchBends.shift();\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tconst interval: number = pitchBends[0] - note.pitches[0];\r\n\t\t\t\t\t\t\t\t\tif (note.pins.length <= pinCount) {\r\n\t\t\t\t\t\t\t\t\t\tnote.pins[pinCount++] = makeNotePin(interval, pinObj.time, pinObj.size);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tconst pin: NotePin = note.pins[pinCount++];\r\n\t\t\t\t\t\t\t\t\t\tpin.interval = interval;\r\n\t\t\t\t\t\t\t\t\t\tpin.time = pinObj.time;\r\n\t\t\t\t\t\t\t\t\t\tpin.size = pinObj.size;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tnote.pins.length = pinCount;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (note.start == 0 && !beforeNine) {\r\n\t\t\t\t\t\t\t\t\tnote.continuesLastPattern = (bits.read(1) == 1);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tnote.continuesLastPattern = false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tcurPart = validateRange(0, this.beatsPerBar * Config.partsPerBeat, note.end);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnewNotes.length = noteCount;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (beforeThree) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchannelIndex++;\r\n\t\t\t\t\t\tif (channelIndex >= this.getChannelCount()) break;\r\n\t\t\t\t\t}\r\n\t\t\t\t} // while (true)\r\n\t\t\t} break;\r\n\t\t\tdefault: {\r\n\t\t\t\tthrow new Error(\"Unrecognized song tag code \" + String.fromCharCode(command) + \" at index \" + (charIndex - 1));\r\n\t\t\t} break;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic toJsonObject(enableIntro: boolean = true, loopCount: number = 1, enableOutro: boolean = true): Object {\r\n\t\tconst channelArray: Object[] = [];\r\n\t\tfor (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n\t\t\tconst channel: Channel = this.channels[channelIndex];\r\n\t\t\tconst instrumentArray: Object[] = [];\r\n\t\t\tconst isNoiseChannel: boolean = this.getChannelIsNoise(channelIndex);\r\n\t\t\tfor (const instrument of channel.instruments) {\r\n\t\t\t\tinstrumentArray.push(instrument.toJsonObject());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst patternArray: Object[] = [];\r\n\t\t\tfor (const pattern of channel.patterns) {\r\n\t\t\t\tpatternArray.push(pattern.toJsonObject(this));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst sequenceArray: number[] = [];\r\n\t\t\tif (enableIntro) for (let i: number = 0; i < this.loopStart; i++) {\r\n\t\t\t\tsequenceArray.push(channel.bars[i]);\r\n\t\t\t}\r\n\t\t\tfor (let l: number = 0; l < loopCount; l++) for (let i: number = this.loopStart; i < this.loopStart + this.loopLength; i++) {\r\n\t\t\t\tsequenceArray.push(channel.bars[i]);\r\n\t\t\t}\r\n\t\t\tif (enableOutro) for (let i: number = this.loopStart + this.loopLength; i < this.barCount; i++) {\r\n\t\t\t\tsequenceArray.push(channel.bars[i]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst channelObject: any = {\r\n\t\t\t\t\"type\": isNoiseChannel ? \"drum\" : \"pitch\",\r\n\t\t\t\t\"instruments\": instrumentArray,\r\n\t\t\t\t\"patterns\": patternArray,\r\n\t\t\t\t\"sequence\": sequenceArray,\r\n\t\t\t};\r\n\t\t\tif (!isNoiseChannel) {\r\n\t\t\t\t// For compatibility with old versions the octave is offset by one.\r\n\t\t\t\tchannelObject[\"octaveScrollBar\"] = channel.octave - 1;\r\n\t\t\t}\r\n\t\t\tchannelArray.push(channelObject);\r\n\t\t}\r\n\t\t\r\n\t\treturn {\r\n\t\t\t\"format\": Song._format,\r\n\t\t\t\"version\": Song._latestVersion,\r\n\t\t\t\"scale\": Config.scales[this.scale].name,\r\n\t\t\t\"key\": Config.keys[this.key].name,\r\n\t\t\t\"introBars\": this.loopStart,\r\n\t\t\t\"loopBars\": this.loopLength,\r\n\t\t\t\"beatsPerBar\": this.beatsPerBar,\r\n\t\t\t\"ticksPerBeat\": Config.rhythms[this.rhythm].stepsPerBeat,\r\n\t\t\t\"beatsPerMinute\": this.tempo,\r\n\t\t\t//\"patternCount\": this.patternsPerChannel, // derive this from pattern arrays.\r\n\t\t\t\"layeredInstruments\": this.layeredInstruments,\r\n\t\t\t\"patternInstruments\": this.patternInstruments,\r\n\t\t\t\"channels\": channelArray,\r\n\t\t};\r\n\t}\r\n\t\r\n\tpublic fromJsonObject(jsonObject: any): void {\r\n\t\tthis.initToDefault(true);\r\n\t\tif (!jsonObject) return;\r\n\t\t\r\n\t\t//const version: number = jsonObject[\"version\"] | 0;\r\n\t\t//if (version > Song._latestVersion) return; // Go ahead and try to parse something from the future I guess? JSON is pretty easy-going!\r\n\t\t\r\n\t\tthis.scale = 11; // default to expert.\r\n\t\tif (jsonObject[\"scale\"] != undefined) {\r\n\t\t\tconst oldScaleNames: Dictionary<string> = {\r\n\t\t\t\t\"romani :)\": \"double harmonic :)\",\r\n\t\t\t\t\"romani :(\": \"double harmonic :(\",\r\n\t\t\t\t\"dbl harmonic :)\": \"double harmonic :)\",\r\n\t\t\t\t\"dbl harmonic :(\": \"double harmonic :(\",\r\n\t\t\t\t\"enigma\": \"strange\",\r\n\t\t\t};\r\n\t\t\tconst scaleName: string = (oldScaleNames[jsonObject[\"scale\"]] != undefined) ? oldScaleNames[jsonObject[\"scale\"]] : jsonObject[\"scale\"];\r\n\t\t\tconst scale: number = Config.scales.findIndex(scale => scale.name == scaleName);\r\n\t\t\tif (scale != -1) this.scale = scale;\r\n\t\t}\r\n\t\t\r\n\t\tif (jsonObject[\"key\"] != undefined) {\r\n\t\t\tif (typeof(jsonObject[\"key\"]) == \"number\") {\r\n\t\t\t\tthis.key = ((jsonObject[\"key\"] + 1200) >>> 0) % Config.keys.length;\r\n\t\t\t} else if (typeof(jsonObject[\"key\"]) == \"string\") {\r\n\t\t\t\tconst key: string = jsonObject[\"key\"];\r\n\t\t\t\tconst letter: string = key.charAt(0).toUpperCase();\r\n\t\t\t\tconst symbol: string = key.charAt(1).toLowerCase();\r\n\t\t\t\tconst letterMap: Readonly<Dictionary<number>> = {\"C\": 0, \"D\": 2, \"E\": 4, \"F\": 5, \"G\": 7, \"A\": 9, \"B\": 11};\r\n\t\t\t\tconst accidentalMap: Readonly<Dictionary<number>> = {\"#\": 1, \"♯\": 1, \"b\": -1, \"♭\": -1};\r\n\t\t\t\tlet index: number | undefined = letterMap[letter];\r\n\t\t\t\tconst offset: number | undefined = accidentalMap[symbol];\r\n\t\t\t\tif (index != undefined) {\r\n\t\t\t\t\tif (offset != undefined) index += offset;\r\n\t\t\t\t\tif (index < 0) index += 12;\r\n\t\t\t\t\tindex = index % 12;\r\n\t\t\t\t\tthis.key = index;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (jsonObject[\"beatsPerMinute\"] != undefined) {\r\n\t\t\tthis.tempo = clamp(Config.tempoMin, Config.tempoMax + 1, jsonObject[\"beatsPerMinute\"] | 0);\r\n\t\t}\r\n\t\t\r\n\t\tlet legacyGlobalReverb: number = 0; // In older songs, reverb was song-global, record that here and pass it to Instrument.fromJsonObject() for context.\r\n\t\tif (jsonObject[\"reverb\"] != undefined) {\r\n\t\t\tlegacyGlobalReverb = clamp(0, 4, jsonObject[\"reverb\"] | 0);\r\n\t\t}\r\n\t\t\r\n\t\tif (jsonObject[\"beatsPerBar\"] != undefined) {\r\n\t\t\tthis.beatsPerBar = Math.max(Config.beatsPerBarMin, Math.min(Config.beatsPerBarMax, jsonObject[\"beatsPerBar\"] | 0));\r\n\t\t}\r\n\t\t\r\n\t\tlet importedPartsPerBeat: number = 4;\r\n\t\tif (jsonObject[\"ticksPerBeat\"] != undefined) {\r\n\t\t\timportedPartsPerBeat = (jsonObject[\"ticksPerBeat\"] | 0) || 4;\r\n\t\t\tthis.rhythm = Config.rhythms.findIndex(rhythm=>rhythm.stepsPerBeat==importedPartsPerBeat);\r\n\t\t\tif (this.rhythm == -1) {\r\n\t\t\t\tthis.rhythm = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlet maxInstruments: number = 1;\r\n\t\tlet maxPatterns: number = 1;\r\n\t\tlet maxBars: number = 1;\r\n\t\tif (jsonObject[\"channels\"] != undefined) {\r\n\t\t\tfor (const channelObject of jsonObject[\"channels\"]) {\r\n\t\t\t\tif (channelObject[\"instruments\"]) maxInstruments = Math.max(maxInstruments, channelObject[\"instruments\"].length | 0);\r\n\t\t\t\tif (channelObject[\"patterns\"]) maxPatterns = Math.max(maxPatterns, channelObject[\"patterns\"].length | 0);\r\n\t\t\t\tif (channelObject[\"sequence\"]) maxBars = Math.max(maxBars, channelObject[\"sequence\"].length | 0);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (jsonObject[\"layeredInstruments\"] != undefined) {\r\n\t\t\tthis.layeredInstruments = !!jsonObject[\"layeredInstruments\"];\r\n\t\t} else {\r\n\t\t\tthis.layeredInstruments = false;\r\n\t\t}\r\n\t\tif (jsonObject[\"patternInstruments\"] != undefined) {\r\n\t\t\tthis.patternInstruments = !!jsonObject[\"patternInstruments\"];\r\n\t\t} else {\r\n\t\t\tthis.patternInstruments = (maxInstruments > 1);\r\n\t\t}\r\n\t\tthis.patternsPerChannel = Math.min(maxPatterns, Config.barCountMax);\r\n\t\tthis.barCount = Math.min(maxBars, Config.barCountMax);\r\n\t\t\r\n\t\tif (jsonObject[\"introBars\"] != undefined) {\r\n\t\t\tthis.loopStart = clamp(0, this.barCount, jsonObject[\"introBars\"] | 0);\r\n\t\t}\r\n\t\tif (jsonObject[\"loopBars\"] != undefined) {\r\n\t\t\tthis.loopLength = clamp(1, this.barCount - this.loopStart + 1, jsonObject[\"loopBars\"] | 0);\r\n\t\t}\r\n\t\t\r\n\t\tconst newPitchChannels: Channel[] = [];\r\n\t\tconst newNoiseChannels: Channel[] = [];\r\n\t\tif (jsonObject[\"channels\"] != undefined) {\r\n\t\t\tfor (let channelIndex: number = 0; channelIndex < jsonObject[\"channels\"].length; channelIndex++) {\r\n\t\t\t\tlet channelObject: any = jsonObject[\"channels\"][channelIndex];\r\n\t\t\t\t\r\n\t\t\t\tconst channel: Channel = new Channel();\r\n\t\t\t\t\r\n\t\t\t\tlet isNoiseChannel: boolean = false;\r\n\t\t\t\tif (channelObject[\"type\"] != undefined) {\r\n\t\t\t\t\tisNoiseChannel = (channelObject[\"type\"] == \"drum\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// for older files, assume drums are channel 3.\r\n\t\t\t\t\tisNoiseChannel = (channelIndex >= 3);\r\n\t\t\t\t}\r\n\t\t\t\tif (isNoiseChannel) {\r\n\t\t\t\t\tnewNoiseChannels.push(channel);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnewPitchChannels.push(channel);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (channelObject[\"octaveScrollBar\"] != undefined) {\r\n\t\t\t\t\tchannel.octave = clamp(0, Config.pitchOctaves, (channelObject[\"octaveScrollBar\"] | 0) + 1);\r\n\t\t\t\t\tif (isNoiseChannel) channel.octave = 0;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (Array.isArray(channelObject[\"instruments\"])) {\r\n\t\t\t\t\tconst instrumentObjects: any[] = channelObject[\"instruments\"];\r\n\t\t\t\t\tfor (let i: number = 0; i < instrumentObjects.length; i++) {\r\n\t\t\t\t\t\tif (i >= this.getMaxInstrumentsPerChannel()) break;\r\n\t\t\t\t\t\tconst instrument: Instrument = new Instrument(isNoiseChannel);\r\n\t\t\t\t\t\tchannel.instruments[i] = instrument;\r\n\t\t\t\t\t\tinstrument.fromJsonObject(instrumentObjects[i], isNoiseChannel, legacyGlobalReverb);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfor (let i: number = 0; i < this.patternsPerChannel; i++) {\r\n\t\t\t\t\tconst pattern: Pattern = new Pattern();\r\n\t\t\t\t\tchannel.patterns[i] = pattern;\r\n\t\t\t\t\t\r\n\t\t\t\t\tlet patternObject: any = undefined;\r\n\t\t\t\t\tif (channelObject[\"patterns\"]) patternObject = channelObject[\"patterns\"][i];\r\n\t\t\t\t\tif (patternObject == undefined) continue;\r\n\t\t\t\t\t\r\n\t\t\t\t\tpattern.fromJsonObject(patternObject, this, channel, importedPartsPerBeat, isNoiseChannel);\r\n\t\t\t\t}\r\n\t\t\t\tchannel.patterns.length = this.patternsPerChannel;\r\n\t\t\t\t\r\n\t\t\t\tfor (let i: number = 0; i < this.barCount; i++) {\r\n\t\t\t\t\tchannel.bars[i] = (channelObject[\"sequence\"] != undefined) ? Math.min(this.patternsPerChannel, channelObject[\"sequence\"][i] >>> 0) : 0;\r\n\t\t\t\t}\r\n\t\t\t\tchannel.bars.length = this.barCount;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (newPitchChannels.length > Config.pitchChannelCountMax) newPitchChannels.length = Config.pitchChannelCountMax;\r\n\t\tif (newNoiseChannels.length > Config.noiseChannelCountMax) newNoiseChannels.length = Config.noiseChannelCountMax;\r\n\t\tthis.pitchChannelCount = newPitchChannels.length;\r\n\t\tthis.noiseChannelCount = newNoiseChannels.length;\r\n\t\tthis.channels.length = 0;\r\n\t\tArray.prototype.push.apply(this.channels, newPitchChannels);\r\n\t\tArray.prototype.push.apply(this.channels, newNoiseChannels);\r\n\t}\r\n\t\r\n\tpublic getPattern(channelIndex: number, bar: number): Pattern | null {\r\n\t\tif (bar < 0 || bar >= this.barCount) return null;\r\n\t\tconst patternIndex: number = this.channels[channelIndex].bars[bar];\r\n\t\tif (patternIndex == 0) return null;\r\n\t\treturn this.channels[channelIndex].patterns[patternIndex - 1];\r\n\t}\r\n\t\r\n\tpublic getBeatsPerMinute(): number {\r\n\t\treturn this.tempo;\r\n\t}\r\n\t\r\n\tpublic static getNeededBits(maxValue: number): number {\r\n\t\treturn 32 - Math.clz32(Math.ceil(maxValue + 1) - 1);\r\n\t}\r\n}\r\n\r\nclass PickedString {\r\n\tpublic delayLine: Float32Array | null = null;\r\n\tpublic delayIndex: number;\r\n\tpublic allPassSample: number;\r\n\tpublic allPassPrevInput: number;\r\n\tpublic sustainFilterSample: number;\r\n\tpublic sustainFilterPrevOutput2: number;\r\n\tpublic sustainFilterPrevInput1: number;\r\n\tpublic sustainFilterPrevInput2: number;\r\n\tpublic fractionalDelaySample: number;\r\n\tpublic prevDelayLength: number;\r\n\tpublic delayLengthDelta: number;\r\n\tpublic delayResetOffset: number;\r\n\t\r\n\tpublic allPassG: number = 0.0;\r\n\tpublic allPassGDelta: number = 0.0;\r\n\tpublic sustainFilterA1: number = 0.0;\r\n\tpublic sustainFilterA1Delta: number = 0.0;\r\n\tpublic sustainFilterA2: number = 0.0;\r\n\tpublic sustainFilterA2Delta: number = 0.0;\r\n\tpublic sustainFilterB0: number = 0.0;\r\n\tpublic sustainFilterB0Delta: number = 0.0;\r\n\tpublic sustainFilterB1: number = 0.0;\r\n\tpublic sustainFilterB1Delta: number = 0.0;\r\n\tpublic sustainFilterB2: number = 0.0;\r\n\tpublic sustainFilterB2Delta: number = 0.0;\r\n\t\r\n\tconstructor() {\r\n\t\tthis.reset();\r\n\t}\r\n\t\r\n\tpublic reset(): void {\r\n\t\tthis.delayIndex = -1;\r\n\t\tthis.allPassSample = 0.0;\r\n\t\tthis.allPassPrevInput = 0.0;\r\n\t\tthis.sustainFilterSample = 0.0;\r\n\t\tthis.sustainFilterPrevOutput2 = 0.0;\r\n\t\tthis.sustainFilterPrevInput1 = 0.0;\r\n\t\tthis.sustainFilterPrevInput2 = 0.0;\r\n\t\tthis.fractionalDelaySample = 0.0;\r\n\t\tthis.prevDelayLength = -1.0;\r\n\t\tthis.delayResetOffset = 0;\r\n\t}\r\n\t\r\n\tpublic update(synth: Synth, instrumentState: InstrumentState, tone: Tone, stringIndex: number, roundedSamplesPerTick: number, stringDecayStart: number, stringDecayEnd: number, sustainType: SustainType): void {\r\n\t\tconst allPassCenter: number = 2.0 * Math.PI * Config.pickedStringDispersionCenterFreq / synth.samplesPerSecond;\r\n\t\t\r\n\t\tconst prevDelayLength: number = this.prevDelayLength;\r\n\t\t\r\n\t\tconst phaseDeltaStart: number = tone.phaseDeltas[stringIndex];\r\n\t\tconst phaseDeltaScale: number = tone.phaseDeltaScales[stringIndex];\r\n\t\tconst phaseDeltaEnd: number = phaseDeltaStart * Math.pow(phaseDeltaScale, roundedSamplesPerTick);\r\n\t\t\r\n\t\tconst radiansPerSampleStart: number = Math.PI * 2.0 * phaseDeltaStart;\r\n\t\tconst radiansPerSampleEnd: number   = Math.PI * 2.0 * phaseDeltaEnd;\r\n\t\t\r\n\t\tconst centerHarmonicStart: number = radiansPerSampleStart * 2.0;\r\n\t\tconst centerHarmonicEnd: number   = radiansPerSampleEnd * 2.0;\r\n\t\t\r\n\t\tconst allPassRadiansStart: number = Math.min(Math.PI, radiansPerSampleStart * Config.pickedStringDispersionFreqMult * Math.pow(allPassCenter / radiansPerSampleStart, Config.pickedStringDispersionFreqScale));\r\n\t\tconst allPassRadiansEnd: number = Math.min(Math.PI, radiansPerSampleEnd * Config.pickedStringDispersionFreqMult * Math.pow(allPassCenter / radiansPerSampleEnd, Config.pickedStringDispersionFreqScale));\r\n\t\t\r\n\t\tconst shelfRadians: number = 2.0 * Math.PI * Config.pickedStringShelfHz / synth.samplesPerSecond;\r\n\t\tconst decayCurveStart: number = (Math.pow(100.0, stringDecayStart) - 1.0) / 99.0;\r\n\t\tconst decayCurveEnd: number   = (Math.pow(100.0, stringDecayEnd  ) - 1.0) / 99.0;\r\n\t\tconst register: number = sustainType == SustainType.acoustic ? 0.25 : 0.0;\r\n\t\tconst registerShelfCenter: number = 15.6;\r\n\t\tconst registerLowpassCenter: number = 3.0 * synth.samplesPerSecond / 48000;\r\n\t\t//const decayRateStart: number = Math.pow(0.5, decayCurveStart * shelfRadians / radiansPerSampleStart);\r\n\t\t//const decayRateEnd: number   = Math.pow(0.5, decayCurveEnd   * shelfRadians / radiansPerSampleEnd);\r\n\t\tconst decayRateStart: number = Math.pow(0.5, decayCurveStart * Math.pow(shelfRadians / (radiansPerSampleStart * registerShelfCenter), (1.0 + 2.0 * register)) * registerShelfCenter);\r\n\t\tconst decayRateEnd:   number = Math.pow(0.5, decayCurveEnd   * Math.pow(shelfRadians / (radiansPerSampleEnd   * registerShelfCenter), (1.0 + 2.0 * register)) * registerShelfCenter);\r\n\t\t\r\n\t\tconst expressionDecayStart: number = Math.pow(decayRateStart, 0.002);\r\n\t\tconst expressionDecayEnd: number   = Math.pow(decayRateEnd,   0.002);\r\n\t\t\r\n\t\tSynth.tempFilterStartCoefficients.allPass1stOrderInvertPhaseAbove(allPassRadiansStart);\r\n\t\tsynth.tempFrequencyResponse.analyze(Synth.tempFilterStartCoefficients, centerHarmonicStart);\r\n\t\tconst allPassGStart: number = Synth.tempFilterStartCoefficients.b[0]; /* same as a[1] */\r\n\t\tconst allPassPhaseDelayStart: number = -synth.tempFrequencyResponse.angle() / centerHarmonicStart;\r\n\t\t\r\n\t\tSynth.tempFilterEndCoefficients.allPass1stOrderInvertPhaseAbove(allPassRadiansEnd);\r\n\t\tsynth.tempFrequencyResponse.analyze(Synth.tempFilterEndCoefficients, centerHarmonicEnd);\r\n\t\tconst allPassGEnd: number = Synth.tempFilterEndCoefficients.b[0]; /* same as a[1] */\r\n\t\tconst allPassPhaseDelayEnd: number = -synth.tempFrequencyResponse.angle() / centerHarmonicEnd;\r\n\t\t\r\n\t\t// 1st order shelf filters and 2nd order lowpass filters have differently shaped frequency\r\n\t\t// responses, as well as adjustable shapes. I originally picked a 1st order shelf filter,\r\n\t\t// but I kinda prefer 2nd order lowpass filters now and I designed a couple settings:\r\n\t\tconst enum PickedStringBrightnessType {\r\n\t\t\tbright, // 1st order shelf\r\n\t\t\tnormal, // 2nd order lowpass, rounded corner\r\n\t\t\tresonant, // 3rd order lowpass, harder corner\r\n\t\t}\r\n\t\tconst brightnessType: PickedStringBrightnessType = <any> sustainType == SustainType.bright ? PickedStringBrightnessType.bright : PickedStringBrightnessType.normal;\r\n\t\tif (brightnessType == PickedStringBrightnessType.bright) {\r\n\t\t\tconst shelfGainStart: number = Math.pow(decayRateStart, Config.stringDecayRate);\r\n\t\t\tconst shelfGainEnd: number   = Math.pow(decayRateEnd,   Config.stringDecayRate);\r\n\t\t\tSynth.tempFilterStartCoefficients.highShelf2ndOrder(shelfRadians, shelfGainStart, 0.5);\r\n\t\t\tSynth.tempFilterEndCoefficients.highShelf2ndOrder(shelfRadians, shelfGainEnd, 0.5);\r\n\t\t} else {\r\n\t\t\tconst cornerHardness: number = Math.pow(brightnessType == PickedStringBrightnessType.normal ? 0.0 : 1.0, 0.25);\r\n\t\t\tconst lowpass1stOrderCutoffRadiansStart: number = Math.pow(registerLowpassCenter * registerLowpassCenter * radiansPerSampleStart * 3.3 * 48000 / synth.samplesPerSecond, 0.5 + register) / registerLowpassCenter / Math.pow(decayCurveStart, .5);\r\n\t\t\tconst lowpass1stOrderCutoffRadiansEnd:   number = Math.pow(registerLowpassCenter * registerLowpassCenter * radiansPerSampleEnd   * 3.3 * 48000 / synth.samplesPerSecond, 0.5 + register) / registerLowpassCenter / Math.pow(decayCurveEnd,   .5);\r\n\t\t\tconst lowpass2ndOrderCutoffRadiansStart: number = lowpass1stOrderCutoffRadiansStart * Math.pow(2.0, 0.5 - 1.75 * (1.0 - Math.pow(1.0 - cornerHardness, 0.85)));\r\n\t\t\tconst lowpass2ndOrderCutoffRadiansEnd:   number = lowpass1stOrderCutoffRadiansEnd   * Math.pow(2.0, 0.5 - 1.75 * (1.0 - Math.pow(1.0 - cornerHardness, 0.85)));\r\n\t\t\tconst lowpass2ndOrderGainStart: number = Math.pow(2.0, -Math.pow(2.0, -Math.pow(cornerHardness, 0.9)));\r\n\t\t\tconst lowpass2ndOrderGainEnd:   number = Math.pow(2.0, -Math.pow(2.0, -Math.pow(cornerHardness, 0.9)));\r\n\t\t\tSynth.tempFilterStartCoefficients.lowPass2ndOrderButterworth(warpInfinityToNyquist(lowpass2ndOrderCutoffRadiansStart), lowpass2ndOrderGainStart);\r\n\t\t\tSynth.tempFilterEndCoefficients  .lowPass2ndOrderButterworth(warpInfinityToNyquist(lowpass2ndOrderCutoffRadiansEnd),   lowpass2ndOrderGainEnd);\r\n\t\t}\r\n\t\t\r\n\t\tsynth.tempFrequencyResponse.analyze(Synth.tempFilterStartCoefficients, centerHarmonicStart);\r\n\t\tconst sustainFilterA1Start: number = Synth.tempFilterStartCoefficients.a[1];\r\n\t\tconst sustainFilterA2Start: number = Synth.tempFilterStartCoefficients.a[2];\r\n\t\tconst sustainFilterB0Start: number = Synth.tempFilterStartCoefficients.b[0] * expressionDecayStart;\r\n\t\tconst sustainFilterB1Start: number = Synth.tempFilterStartCoefficients.b[1] * expressionDecayStart;\r\n\t\tconst sustainFilterB2Start: number = Synth.tempFilterStartCoefficients.b[2] * expressionDecayStart;\r\n\t\tconst sustainFilterPhaseDelayStart: number = -synth.tempFrequencyResponse.angle() / centerHarmonicStart;\r\n\t\t\r\n\t\tsynth.tempFrequencyResponse.analyze(Synth.tempFilterEndCoefficients, centerHarmonicEnd);\r\n\t\tconst sustainFilterA1End: number = Synth.tempFilterEndCoefficients.a[1];\r\n\t\tconst sustainFilterA2End: number = Synth.tempFilterEndCoefficients.a[2];\r\n\t\tconst sustainFilterB0End: number = Synth.tempFilterEndCoefficients.b[0] * expressionDecayEnd;\r\n\t\tconst sustainFilterB1End: number = Synth.tempFilterEndCoefficients.b[1] * expressionDecayEnd;\r\n\t\tconst sustainFilterB2End: number = Synth.tempFilterEndCoefficients.b[2] * expressionDecayEnd;\r\n\t\tconst sustainFilterPhaseDelayEnd: number = -synth.tempFrequencyResponse.angle() / centerHarmonicEnd;\r\n\t\t\r\n\t\tconst periodLengthStart: number = 1.0 / phaseDeltaStart;\r\n\t\tconst periodLengthEnd: number = 1.0 / phaseDeltaEnd;\r\n\t\tconst minBufferLength: number = Math.ceil(Math.max(periodLengthStart, periodLengthEnd) * 2);\r\n\t\tconst delayLength: number = periodLengthStart - allPassPhaseDelayStart - sustainFilterPhaseDelayStart;\r\n\t\tconst delayLengthEnd: number = periodLengthEnd - allPassPhaseDelayEnd - sustainFilterPhaseDelayEnd;\r\n\t\t\r\n\t\tthis.prevDelayLength = delayLength;\r\n\t\tthis.delayLengthDelta = (delayLengthEnd - delayLength) / roundedSamplesPerTick;\r\n\t\tthis.allPassG = allPassGStart;\r\n\t\tthis.sustainFilterA1 = sustainFilterA1Start;\r\n\t\tthis.sustainFilterA2 = sustainFilterA2Start;\r\n\t\tthis.sustainFilterB0 = sustainFilterB0Start;\r\n\t\tthis.sustainFilterB1 = sustainFilterB1Start;\r\n\t\tthis.sustainFilterB2 = sustainFilterB2Start;\r\n\t\tthis.allPassGDelta = (allPassGEnd - allPassGStart) / roundedSamplesPerTick;\r\n\t\tthis.sustainFilterA1Delta = (sustainFilterA1End - sustainFilterA1Start) / roundedSamplesPerTick;\r\n\t\tthis.sustainFilterA2Delta = (sustainFilterA2End - sustainFilterA2Start) / roundedSamplesPerTick;\r\n\t\tthis.sustainFilterB0Delta = (sustainFilterB0End - sustainFilterB0Start) / roundedSamplesPerTick;\r\n\t\tthis.sustainFilterB1Delta = (sustainFilterB1End - sustainFilterB1Start) / roundedSamplesPerTick;\r\n\t\tthis.sustainFilterB2Delta = (sustainFilterB2End - sustainFilterB2Start) / roundedSamplesPerTick;\r\n\t\t\r\n\t\tconst pitchChanged: boolean = Math.abs(Math.log2(delayLength / prevDelayLength)) > 0.01;\r\n\t\t\r\n\t\tconst reinitializeImpulse: boolean = (this.delayIndex == -1 || pitchChanged);\r\n\t\tif (this.delayLine == null || this.delayLine.length <= minBufferLength) {\r\n\t\t\t// The delay line buffer will get reused for other tones so might as well\r\n\t\t\t// start off with a buffer size that is big enough for most notes.\r\n\t\t\tconst likelyMaximumLength: number = Math.ceil(2 * synth.samplesPerSecond / Instrument.frequencyFromPitch(12));\r\n\t\t\tconst newDelayLine: Float32Array = new Float32Array(Synth.fittingPowerOfTwo(Math.max(likelyMaximumLength, minBufferLength)));\r\n\t\t\tif (!reinitializeImpulse && this.delayLine != null) {\r\n\t\t\t\t// If the tone has already started but the buffer needs to be reallocated,\r\n\t\t\t\t// transfer the old data to the new buffer.\r\n\t\t\t\tconst oldDelayBufferMask: number = (this.delayLine.length - 1) >> 0;\r\n\t\t\t\tconst startCopyingFromIndex: number = this.delayIndex + this.delayResetOffset;\r\n\t\t\t\tthis.delayIndex = this.delayLine.length - this.delayResetOffset;\r\n\t\t\t\tfor (let i: number = 0; i < this.delayLine.length; i++) {\r\n\t\t\t\t\tnewDelayLine[i] = this.delayLine[(startCopyingFromIndex + i) & oldDelayBufferMask];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.delayLine = newDelayLine;\r\n\t\t}\r\n\t\tconst delayLine: Float32Array = this.delayLine;\r\n\t\tconst delayBufferMask: number = (delayLine.length - 1) >> 0;\r\n\t\t\r\n\t\tif (reinitializeImpulse) {\r\n\t\t\t// -1 delay index means the tone was reset.\r\n\t\t\t// Also, if the pitch changed suddenly (e.g. from seamless or arpeggio) then reset the wave.\r\n\t\t\t\r\n\t\t\tthis.delayIndex = 0;\r\n\t\t\tthis.allPassSample = 0.0;\r\n\t\t\tthis.allPassPrevInput = 0.0;\r\n\t\t\tthis.sustainFilterSample = 0.0;\r\n\t\t\tthis.sustainFilterPrevOutput2 = 0.0;\r\n\t\t\tthis.sustainFilterPrevInput1 = 0.0;\r\n\t\t\tthis.sustainFilterPrevInput2 = 0.0;\r\n\t\t\tthis.fractionalDelaySample = 0.0;\r\n\t\t\t\r\n\t\t\t// Clear away a region of the delay buffer for the new impulse.\r\n\t\t\tconst startImpulseFrom: number = -delayLength;\r\n\t\t\tconst startZerosFrom: number = Math.floor(startImpulseFrom - periodLengthStart / 2);\r\n\t\t\tconst stopZerosAt: number = Math.ceil(startZerosFrom + periodLengthStart * 2);\r\n\t\t\tthis.delayResetOffset = stopZerosAt; // And continue clearing the area in front of the delay line.\r\n\t\t\tfor (let i: number = startZerosFrom; i <= stopZerosAt; i++) {\r\n\t\t\t\tdelayLine[i & delayBufferMask] = 0.0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst impulseWave: Float32Array = instrumentState.wave!;\r\n\t\t\tconst impulseWaveLength: number = impulseWave.length - 1; // The first sample is duplicated at the end, don't double-count it.\r\n\t\t\tconst impulsePhaseDelta: number = impulseWaveLength / periodLengthStart;\r\n\t\t\t\r\n\t\t\tconst fadeDuration: number = Math.min(periodLengthStart * 0.2, synth.samplesPerSecond * 0.003);\r\n\t\t\tconst startImpulseFromSample: number = Math.ceil(startImpulseFrom);\r\n\t\t\tconst stopImpulseAt: number = startImpulseFrom + periodLengthStart + fadeDuration;\r\n\t\t\tconst stopImpulseAtSample: number = stopImpulseAt;\r\n\t\t\tlet impulsePhase: number = (startImpulseFromSample - startImpulseFrom) * impulsePhaseDelta;\r\n\t\t\tlet prevWaveIntegral: number = 0.0;\r\n\t\t\tfor (let i: number = startImpulseFromSample; i <= stopImpulseAtSample; i++) {\r\n\t\t\t\tconst impulsePhaseInt: number = impulsePhase|0;\r\n\t\t\t\tconst index: number = impulsePhaseInt % impulseWaveLength;\r\n\t\t\t\tlet nextWaveIntegral: number = impulseWave[index];\r\n\t\t\t\tconst phaseRatio: number = impulsePhase - impulsePhaseInt;\r\n\t\t\t\tnextWaveIntegral += (impulseWave[index+1] - nextWaveIntegral) * phaseRatio;\r\n\t\t\t\tconst sample: number = (nextWaveIntegral - prevWaveIntegral) / impulsePhaseDelta;\r\n\t\t\t\tconst fadeIn: number = Math.min(1.0, (i - startImpulseFrom) / fadeDuration);\r\n\t\t\t\tconst fadeOut: number = Math.min(1.0, (stopImpulseAt - i) / fadeDuration);\r\n\t\t\t\tconst combinedFade: number = fadeIn * fadeOut;\r\n\t\t\t\tconst curvedFade: number = combinedFade * combinedFade * (3.0 - 2.0 * combinedFade); // A cubic sigmoid from 0 to 1.\r\n\t\t\t\tdelayLine[i & delayBufferMask] += sample * curvedFade;\r\n\t\t\t\tprevWaveIntegral = nextWaveIntegral;\r\n\t\t\t\timpulsePhase += impulsePhaseDelta;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass EnvelopeComputer {\r\n\tpublic noteSecondsStart: number = 0.0;\r\n\tpublic noteSecondsEnd: number = 0.0;\r\n\tpublic noteTicksStart: number = 0.0;\r\n\tpublic noteTicksEnd: number = 0.0;\r\n\tpublic noteSizeStart: number = Config.noteSizeMax;\r\n\tpublic noteSizeEnd: number = Config.noteSizeMax;\r\n\tpublic prevNoteSize: number = Config.noteSizeMax;\r\n\tpublic nextNoteSize: number = Config.noteSizeMax;\r\n\tprivate _noteSizeFinal: number = Config.noteSizeMax;\r\n\tpublic prevNoteSecondsStart: number = 0.0;\r\n\tpublic prevNoteSecondsEnd: number = 0.0;\r\n\tpublic prevNoteTicksStart: number = 0.0;\r\n\tpublic prevNoteTicksEnd: number = 0.0;\r\n\tprivate _prevNoteSizeFinal: number = Config.noteSizeMax;\r\n\t\r\n\tpublic prevSlideStart: boolean = false;\r\n\tpublic prevSlideEnd: boolean = false;\r\n\tpublic nextSlideStart: boolean = false;\r\n\tpublic nextSlideEnd: boolean = false;\r\n\tpublic prevSlideRatioStart: number = 0.0;\r\n\tpublic prevSlideRatioEnd: number = 0.0;\r\n\tpublic nextSlideRatioStart: number = 0.0;\r\n\tpublic nextSlideRatioEnd: number = 0.0;\r\n\t\r\n\tpublic readonly envelopeStarts: number[] = [];\r\n\tpublic readonly envelopeEnds: number[] = [];\r\n\tprivate readonly _modifiedEnvelopeIndices: number[] = [];\r\n\tprivate _modifiedEnvelopeCount: number = 0;\r\n\tpublic lowpassCutoffDecayVolumeCompensation: number = 1.0;\r\n\t\r\n\tconstructor(/*private _perNote: boolean*/) {\r\n\t\t//const length: number = this._perNote ? EnvelopeComputeIndex.length : InstrumentAutomationIndex.length;\r\n\t\tconst length: number = EnvelopeComputeIndex.length;\r\n\t\tfor (let i: number = 0; i < length; i++) {\r\n\t\t\tthis.envelopeStarts[i] = 1.0;\r\n\t\t\tthis.envelopeEnds[i] = 1.0;\r\n\t\t}\r\n\t\t\r\n\t\tthis.reset();\r\n\t}\r\n\t\r\n\tpublic reset(): void {\r\n\t\tthis.noteSecondsEnd = 0.0;\r\n\t\tthis.noteTicksEnd = 0.0;\r\n\t\tthis._noteSizeFinal = Config.noteSizeMax;\r\n\t\tthis.prevNoteSecondsEnd = 0.0;\r\n\t\tthis.prevNoteTicksEnd = 0.0;\r\n\t\tthis._prevNoteSizeFinal = Config.noteSizeMax;\r\n\t\tthis._modifiedEnvelopeCount = 0;\r\n\t}\r\n\t\r\n\tpublic computeEnvelopes(instrument: Instrument, currentPart: number, tickTimeStart: number, secondsPerTick: number, tone: Tone | null): void {\r\n\t\tconst transition: Transition = instrument.getTransition();\r\n\t\tif (tone != null && tone.atNoteStart && !transition.continues && !tone.forceContinueAtStart) {\r\n\t\t\tthis.prevNoteSecondsEnd = this.noteSecondsEnd;\r\n\t\t\tthis.prevNoteTicksEnd = this.noteTicksEnd;\r\n\t\t\tthis._prevNoteSizeFinal = this._noteSizeFinal;\r\n\t\t\tthis.noteSecondsEnd = 0.0;\r\n\t\t\tthis.noteTicksEnd = 0.0;\r\n\t\t}\r\n\t\tif (tone != null) {\r\n\t\t\tif (tone.note != null) {\r\n\t\t\t\tthis._noteSizeFinal = tone.note.pins[tone.note.pins.length - 1].size;\r\n\t\t\t} else {\r\n\t\t\t\tthis._noteSizeFinal = Config.noteSizeMax;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tconst tickTimeEnd: number = tickTimeStart + 1.0;\r\n\t\tconst noteSecondsStart: number = this.noteSecondsEnd;\r\n\t\tconst noteSecondsEnd: number = noteSecondsStart + secondsPerTick;\r\n\t\tconst noteTicksStart: number = this.noteTicksEnd;\r\n\t\tconst noteTicksEnd: number = noteTicksStart + 1.0;\r\n\t\tconst prevNoteSecondsStart: number = this.prevNoteSecondsEnd;\r\n\t\tconst prevNoteSecondsEnd: number = prevNoteSecondsStart + secondsPerTick;\r\n\t\tconst prevNoteTicksStart: number = this.prevNoteTicksEnd;\r\n\t\tconst prevNoteTicksEnd: number = prevNoteTicksStart + 1.0;\r\n\t\t\r\n\t\tconst beatsPerTick: number = 1.0 / (Config.ticksPerPart * Config.partsPerBeat);\r\n\t\tconst beatTimeStart: number = beatsPerTick * tickTimeStart;\r\n\t\tconst beatTimeEnd:   number = beatsPerTick * tickTimeEnd;\r\n\t\t\r\n\t\tlet noteSizeStart: number = this._noteSizeFinal;\r\n\t\tlet noteSizeEnd: number = this._noteSizeFinal;\r\n\t\tlet prevNoteSize: number = this._prevNoteSizeFinal;\r\n\t\tlet nextNoteSize: number = 0;\r\n\t\tlet prevSlideStart: boolean = false;\r\n\t\tlet prevSlideEnd: boolean = false;\r\n\t\tlet nextSlideStart: boolean = false;\r\n\t\tlet nextSlideEnd: boolean = false;\r\n\t\tlet prevSlideRatioStart: number = 0.0;\r\n\t\tlet prevSlideRatioEnd: number = 0.0;\r\n\t\tlet nextSlideRatioStart: number = 0.0;\r\n\t\tlet nextSlideRatioEnd: number = 0.0;\r\n\t\tif (tone != null && tone.note != null && !tone.passedEndOfNote) {\r\n\t\t\tconst endPinIndex: number = tone.note.getEndPinIndex(currentPart);\r\n\t\t\tconst startPin: NotePin = tone.note.pins[endPinIndex-1];\r\n\t\t\tconst endPin:   NotePin = tone.note.pins[endPinIndex];\r\n\t\t\tconst startPinTick: number = (tone.note.start + startPin.time) * Config.ticksPerPart;\r\n\t\t\tconst endPinTick:   number = (tone.note.start + endPin.time)   * Config.ticksPerPart;\r\n\t\t\tconst ratioStart: number = (tickTimeStart - startPinTick) / (endPinTick - startPinTick);\r\n\t\t\tconst ratioEnd:   number = (tickTimeEnd   - startPinTick) / (endPinTick - startPinTick);\r\n\t\t\tnoteSizeStart = startPin.size + (endPin.size - startPin.size) * ratioStart;\r\n\t\t\tnoteSizeEnd   = startPin.size + (endPin.size - startPin.size) * ratioEnd;\r\n\t\t\t\r\n\t\t\tif (transition.slides) {\r\n\t\t\t\tconst noteStartTick: number = tone.noteStartPart * Config.ticksPerPart;\r\n\t\t\t\tconst noteEndTick:   number = tone.noteEndPart   * Config.ticksPerPart;\r\n\t\t\t\tconst noteLengthTicks: number = noteEndTick - noteStartTick;\r\n\t\t\t\tconst maximumSlideTicks: number = noteLengthTicks * 0.5;\r\n\t\t\t\tconst slideTicks: number = Math.min(maximumSlideTicks, transition.slideTicks);\r\n\t\t\t\tif (tone.prevNote != null && !tone.forceContinueAtStart) {\r\n\t\t\t\t\tif (tickTimeStart - noteStartTick < slideTicks) {\r\n\t\t\t\t\t\tprevSlideStart = true;\r\n\t\t\t\t\t\tprevSlideRatioStart = 0.5 * (1.0 - (tickTimeStart - noteStartTick) / slideTicks);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (tickTimeEnd - noteStartTick < slideTicks) {\r\n\t\t\t\t\t\tprevSlideEnd = true;\r\n\t\t\t\t\t\tprevSlideRatioEnd = 0.5 * (1.0 - (tickTimeEnd - noteStartTick) / slideTicks);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (tone.nextNote != null && !tone.forceContinueAtEnd) {\r\n\t\t\t\t\tnextNoteSize = tone.nextNote.pins[0].size\r\n\t\t\t\t\tif (noteEndTick - tickTimeStart < slideTicks) {\r\n\t\t\t\t\t\tnextSlideStart = true;\r\n\t\t\t\t\t\tnextSlideRatioStart = 0.5 * (1.0 - (noteEndTick - tickTimeStart) / slideTicks);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (noteEndTick - tickTimeEnd < slideTicks) {\r\n\t\t\t\t\t\tnextSlideEnd = true;\r\n\t\t\t\t\t\tnextSlideRatioEnd = 0.5 * (1.0 - (noteEndTick - tickTimeEnd) / slideTicks);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlet lowpassCutoffDecayVolumeCompensation: number = 1.0;\r\n\t\tlet usedNoteSize: boolean = false;\r\n\t\tfor (let envelopeIndex: number = 0; envelopeIndex <= instrument.envelopeCount; envelopeIndex++) {\r\n\t\t\tlet automationTarget: AutomationTarget;\r\n\t\t\tlet targetIndex: number;\r\n\t\t\tlet envelope: Envelope;\r\n\t\t\tif (envelopeIndex == instrument.envelopeCount) {\r\n\t\t\t\tif (usedNoteSize /*|| !this._perNote*/) break;\r\n\t\t\t\t// Special case: if no other envelopes used note size, default to applying it to note volume.\r\n\t\t\t\tautomationTarget = Config.instrumentAutomationTargets.dictionary[\"noteVolume\"];\r\n\t\t\t\ttargetIndex = 0;\r\n\t\t\t\tenvelope = Config.envelopes.dictionary[\"note size\"];\r\n\t\t\t} else {\r\n\t\t\t\tlet envelopeSettings: EnvelopeSettings = instrument.envelopes[envelopeIndex];\r\n\t\t\t\tautomationTarget = Config.instrumentAutomationTargets[envelopeSettings.target];\r\n\t\t\t\ttargetIndex = envelopeSettings.index;\r\n\t\t\t\tenvelope = Config.envelopes[envelopeSettings.envelope];\r\n\t\t\t\tif (envelope.type == EnvelopeType.noteSize) usedNoteSize = true;\r\n\t\t\t}\r\n\t\t\tif (/*automationTarget.perNote == this._perNote &&*/ automationTarget.computeIndex != null) {\r\n\t\t\t\tconst computeIndex: number = automationTarget.computeIndex + targetIndex;\r\n\t\t\t\tlet envelopeStart: number = EnvelopeComputer.computeEnvelope(envelope, noteSecondsStart, beatTimeStart, noteSizeStart);\r\n\t\t\t\tlet envelopeEnd:   number = EnvelopeComputer.computeEnvelope(envelope, noteSecondsEnd,   beatTimeEnd,   noteSizeEnd);\r\n\t\t\t\t\r\n\t\t\t\tif (prevSlideStart) {\r\n\t\t\t\t\tconst other: number = EnvelopeComputer.computeEnvelope(envelope, prevNoteSecondsStart, beatTimeStart, prevNoteSize);\r\n\t\t\t\t\tenvelopeStart += (other - envelopeStart) * prevSlideRatioStart;\r\n\t\t\t\t}\r\n\t\t\t\tif (prevSlideEnd) {\r\n\t\t\t\t\tconst other: number = EnvelopeComputer.computeEnvelope(envelope, prevNoteSecondsEnd, beatTimeEnd, prevNoteSize);\r\n\t\t\t\t\tenvelopeEnd += (other - envelopeEnd) * prevSlideRatioEnd;\r\n\t\t\t\t}\r\n\t\t\t\tif (nextSlideStart) {\r\n\t\t\t\t\tconst other: number = EnvelopeComputer.computeEnvelope(envelope, 0.0, beatTimeStart, nextNoteSize);\r\n\t\t\t\t\tenvelopeStart += (other - envelopeStart) * nextSlideRatioStart;\r\n\t\t\t\t}\r\n\t\t\t\tif (nextSlideEnd) {\r\n\t\t\t\t\tconst other: number = EnvelopeComputer.computeEnvelope(envelope, 0.0, beatTimeEnd, nextNoteSize);\r\n\t\t\t\t\tenvelopeEnd += (other - envelopeEnd) * nextSlideRatioEnd;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tthis.envelopeStarts[computeIndex] *= envelopeStart;\r\n\t\t\t\tthis.envelopeEnds[computeIndex]   *= envelopeEnd;\r\n\t\t\t\tthis._modifiedEnvelopeIndices[this._modifiedEnvelopeCount++] = computeIndex;\r\n\t\t\t\t\r\n\t\t\t\tif (automationTarget.isFilter) {\r\n\t\t\t\t\tconst filterSettings: FilterSettings = /*this._perNote ?*/ instrument.noteFilter /*: instrument.eqFilter*/;\r\n\t\t\t\t\tif (filterSettings.controlPointCount > targetIndex && filterSettings.controlPoints[targetIndex].type == FilterType.lowPass) {\r\n\t\t\t\t\t\tlowpassCutoffDecayVolumeCompensation = Math.max(lowpassCutoffDecayVolumeCompensation, EnvelopeComputer.getLowpassCutoffDecayVolumeCompensation(envelope));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tthis.noteSecondsStart = noteSecondsStart;\r\n\t\tthis.noteSecondsEnd = noteSecondsEnd;\r\n\t\tthis.noteTicksStart = noteTicksStart;\r\n\t\tthis.noteTicksEnd = noteTicksEnd;\r\n\t\tthis.prevNoteSecondsStart = prevNoteSecondsStart;\r\n\t\tthis.prevNoteSecondsEnd = prevNoteSecondsEnd;\r\n\t\tthis.prevNoteTicksStart = prevNoteTicksStart;\r\n\t\tthis.prevNoteTicksEnd = prevNoteTicksEnd;\r\n\t\tthis.prevNoteSize = prevNoteSize;\r\n\t\tthis.nextNoteSize = nextNoteSize;\r\n\t\tthis.noteSizeStart = noteSizeStart;\r\n\t\tthis.noteSizeEnd = noteSizeEnd;\r\n\t\tthis.prevSlideStart = prevSlideStart;\r\n\t\tthis.prevSlideEnd = prevSlideEnd;\r\n\t\tthis.nextSlideStart = nextSlideStart;\r\n\t\tthis.nextSlideEnd = nextSlideEnd;\r\n\t\tthis.prevSlideRatioStart = prevSlideRatioStart;\r\n\t\tthis.prevSlideRatioEnd = prevSlideRatioEnd;\r\n\t\tthis.nextSlideRatioStart = nextSlideRatioStart;\r\n\t\tthis.nextSlideRatioEnd = nextSlideRatioEnd;\r\n\t\tthis.lowpassCutoffDecayVolumeCompensation = lowpassCutoffDecayVolumeCompensation;\r\n\t}\r\n\t\r\n\tpublic clearEnvelopes(): void {\r\n\t\tfor (let envelopeIndex: number = 0; envelopeIndex < this._modifiedEnvelopeCount; envelopeIndex++) {\r\n\t\t\tconst computeIndex: number = this._modifiedEnvelopeIndices[envelopeIndex];\r\n\t\t\tthis.envelopeStarts[computeIndex] = 1.0;\r\n\t\t\tthis.envelopeEnds[computeIndex]   = 1.0;\r\n\t\t}\r\n\t\tthis._modifiedEnvelopeCount = 0;\r\n\t}\r\n\t\r\n\tpublic static computeEnvelope(envelope: Envelope, time: number, beats: number, noteSize: number): number {\r\n\t\tswitch(envelope.type) {\r\n\t\t\tcase EnvelopeType.noteSize: return Synth.noteSizeToVolumeMult(noteSize);\r\n\t\t\tcase EnvelopeType.none:     return 1.0;\r\n\t\t\tcase EnvelopeType.twang:    return 1.0 / (1.0 + time * envelope.speed);\r\n\t\t\tcase EnvelopeType.swell:    return 1.0 - 1.0 / (1.0 + time * envelope.speed);\r\n\t\t\tcase EnvelopeType.tremolo:  return 0.5 - Math.cos(beats * 2.0 * Math.PI * envelope.speed) * 0.5;\r\n\t\t\tcase EnvelopeType.tremolo2: return 0.75 - Math.cos(beats * 2.0 * Math.PI * envelope.speed) * 0.25;\r\n\t\t\tcase EnvelopeType.punch:    return Math.max(1.0, 2.0 - time * 10.0);\r\n\t\t\tcase EnvelopeType.flare:    const attack: number = 0.25 / Math.sqrt(envelope.speed); return time < attack ? time / attack : 1.0 / (1.0 + (time - attack) * envelope.speed);\r\n\t\t\tcase EnvelopeType.decay:    return Math.pow(2, -envelope.speed * time);\r\n\t\t\tdefault: throw new Error(\"Unrecognized operator envelope type.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static getLowpassCutoffDecayVolumeCompensation(envelope: Envelope): number {\r\n\t\t// This is a little hokey in the details, but I designed it a while ago and keep it \r\n\t\t// around for compatibility. This decides how much to increase the volume (or\r\n\t\t// expression) to compensate for a decaying lowpass cutoff to maintain perceived\r\n\t\t// volume overall.\r\n\t\tif (envelope.type == EnvelopeType.decay) return 1.25 + 0.025 * envelope.speed;\r\n\t\tif (envelope.type == EnvelopeType.twang) return 1.0  + 0.02  * envelope.speed;\r\n\t\treturn 1.0;\r\n\t}\r\n}\r\n\r\nclass Tone {\r\n\tpublic instrumentIndex: number;\r\n\tpublic readonly pitches: number[] = Array(Config.maxChordSize).fill(0);\r\n\tpublic pitchCount: number = 0;\r\n\tpublic chordSize: number = 0;\r\n\tpublic drumsetPitch: number | null = null;\r\n\tpublic note: Note | null = null;\r\n\tpublic prevNote: Note | null = null;\r\n\tpublic nextNote: Note | null = null;\r\n\tpublic prevNotePitchIndex: number = 0;\r\n\tpublic nextNotePitchIndex: number = 0;\r\n\tpublic freshlyAllocated: boolean = true;\r\n\tpublic atNoteStart: boolean = false;\r\n\tpublic isOnLastTick: boolean = false; // Whether the tone is finished fading out and ready to be freed.\r\n\tpublic passedEndOfNote: boolean = false;\r\n\tpublic forceContinueAtStart: boolean = false;\r\n\tpublic forceContinueAtEnd: boolean = false;\r\n\tpublic noteStartPart: number = 0;\r\n\tpublic noteEndPart: number = 0;\r\n\tpublic ticksSinceReleased: number = 0;\r\n\tpublic liveInputSamplesHeld: number = 0;\r\n\tpublic lastInterval: number = 0;\r\n\tpublic noiseSample: number = 0.0;\r\n\tpublic readonly phases: number[] = [];\r\n\tpublic readonly phaseDeltas: number[] = [];\r\n\tpublic readonly phaseDeltaScales: number[] = [];\r\n\tpublic expression: number = 0.0;\r\n\tpublic expressionDelta: number = 0.0;\r\n\tpublic readonly operatorExpressions: number[] = [];\r\n\tpublic readonly operatorExpressionDeltas: number[] = [];\r\n\tpublic readonly prevPitchExpressions: Array<number | null> = Array(Config.maxPitchOrOperatorCount).fill(null);\r\n\tpublic prevVibrato: number | null = null;\r\n\tpublic prevStringDecay: number | null = null;\r\n\tpublic pulseWidth: number = 0.0;\r\n\tpublic pulseWidthDelta: number = 0.0;\r\n\tpublic supersawDynamism: number = 0.0;\r\n\tpublic supersawDynamismDelta: number = 0.0;\r\n\tpublic supersawUnisonDetunes: number[] = []; // These can change over time, but slowly enough that I'm not including corresponding delta values within a tick run.\r\n\tpublic supersawShape: number = 0.0;\r\n\tpublic supersawShapeDelta: number = 0.0;\r\n\tpublic supersawDelayLength: number = 0.0;\r\n\tpublic supersawDelayLengthDelta: number = 0.0;\r\n\tpublic supersawDelayLine: Float32Array | null = null;\r\n\tpublic supersawDelayIndex: number = -1;\r\n\tpublic supersawPrevPhaseDelta: number | null = null;\r\n\tpublic readonly pickedStrings: PickedString[] = [];\r\n\t\r\n\tpublic readonly noteFilters: DynamicBiquadFilter[] = [];\r\n\tpublic noteFilterCount: number = 0;\r\n\tpublic initialNoteFilterInput1: number = 0.0;\r\n\tpublic initialNoteFilterInput2: number = 0.0;\r\n\t\r\n\tpublic specialIntervalExpressionMult: number = 1.0;\r\n\tpublic readonly feedbackOutputs: number[] = [];\r\n\tpublic feedbackMult: number = 0.0;\r\n\tpublic feedbackDelta: number = 0.0;\r\n\t\r\n\tpublic readonly envelopeComputer: EnvelopeComputer = new EnvelopeComputer(/*true*/);\r\n\t\r\n\tconstructor() {\r\n\t\tthis.reset();\r\n\t}\r\n\t\r\n\tpublic reset(): void {\r\n\t\tthis.noiseSample = 0.0;\r\n\t\tfor (let i: number = 0; i < Config.maxPitchOrOperatorCount; i++) {\r\n\t\t\tthis.phases[i] = 0.0;\r\n\t\t\tthis.feedbackOutputs[i] = 0.0;\r\n\t\t\tthis.prevPitchExpressions[i] = null;\r\n\t\t}\r\n\t\tfor (let i: number = 0; i < this.noteFilterCount; i++) {\r\n\t\t\tthis.noteFilters[i].resetOutput();\r\n\t\t}\r\n\t\tthis.noteFilterCount = 0;\r\n\t\tthis.initialNoteFilterInput1 = 0.0;\r\n\t\tthis.initialNoteFilterInput2 = 0.0;\r\n\t\tthis.liveInputSamplesHeld = 0;\r\n\t\tthis.supersawDelayIndex = -1;\r\n\t\tfor (const pickedString of this.pickedStrings) {\r\n\t\t\tpickedString.reset();\r\n\t\t}\r\n\t\tthis.envelopeComputer.reset();\r\n\t\tthis.prevVibrato = null;\r\n\t\tthis.prevStringDecay = null;\r\n\t\tthis.supersawPrevPhaseDelta = null;\r\n\t\tthis.drumsetPitch = null;\r\n\t}\r\n}\r\n\r\nclass InstrumentState {\r\n\tpublic awake: boolean = false; // Whether the instrument's effects-processing loop should continue.\r\n\tpublic computed: boolean = false; // Whether the effects-processing parameters are up-to-date for the current synth run.\r\n\tpublic tonesAddedInThisTick: boolean = false; // Whether any instrument tones are currently active.\r\n\tpublic flushingDelayLines: boolean = false; // If no tones were active recently, enter a mode where the delay lines are filled with zeros to reset them for later use.\r\n\tpublic deactivateAfterThisTick: boolean = false; // Whether the instrument is ready to be deactivated because the delay lines, if any, are fully zeroed.\r\n\tpublic attentuationProgress: number = 0.0; // How long since an active tone introduced an input signal to the delay lines, normalized from 0 to 1 based on how long to wait until the delay lines signal will have audibly dissapated.\r\n\tpublic flushedSamples: number = 0; // How many delay line samples have been flushed to zero.\r\n\tpublic readonly activeTones: Deque<Tone> = new Deque<Tone>();\r\n\tpublic readonly releasedTones: Deque<Tone> = new Deque<Tone>(); // Tones that are in the process of fading out after the corresponding notes ended.\r\n\tpublic readonly liveInputTones: Deque<Tone> = new Deque<Tone>(); // Tones that are initiated by a source external to the loaded song data.\r\n\t\r\n\tpublic type: InstrumentType = InstrumentType.chip;\r\n\tpublic synthesizer: Function | null = null;\r\n\tpublic wave: Float32Array | null = null;\r\n\tpublic noisePitchFilterMult: number = 1.0;\r\n\tpublic unison: Unison | null = null;\r\n\tpublic chord: Chord | null = null;\r\n\tpublic effects: number = 0;\r\n\t\r\n\tpublic eqFilterVolume: number = 1.0;\r\n\tpublic eqFilterVolumeDelta: number = 0.0;\r\n\tpublic mixVolume: number = 1.0;\r\n\tpublic mixVolumeDelta: number = 0.0;\r\n\tpublic delayInputMult: number = 0.0;\r\n\tpublic delayInputMultDelta: number = 0.0;\r\n\t\r\n\tpublic distortion: number = 0.0;\r\n\tpublic distortionDelta: number = 0.0;\r\n\tpublic distortionDrive: number = 0.0;\r\n\tpublic distortionDriveDelta: number = 0.0;\r\n\tpublic distortionFractionalInput1: number = 0.0;\r\n\tpublic distortionFractionalInput2: number = 0.0;\r\n\tpublic distortionFractionalInput3: number = 0.0;\r\n\tpublic distortionPrevInput: number = 0.0;\r\n\tpublic distortionNextOutput: number = 0.0;\r\n\t\r\n\tpublic bitcrusherPrevInput: number = 0.0;\r\n\tpublic bitcrusherCurrentOutput: number = 0.0;\r\n\tpublic bitcrusherPhase: number = 1.0;\r\n\tpublic bitcrusherPhaseDelta: number = 0.0;\r\n\tpublic bitcrusherPhaseDeltaScale: number = 1.0;\r\n\tpublic bitcrusherScale: number = 1.0;\r\n\tpublic bitcrusherScaleScale: number = 1.0;\r\n\tpublic bitcrusherFoldLevel: number = 1.0;\r\n\tpublic bitcrusherFoldLevelScale: number = 1.0;\r\n\t\r\n\tpublic readonly eqFilters: DynamicBiquadFilter[] = [];\r\n\tpublic eqFilterCount: number = 0;\r\n\tpublic initialEqFilterInput1: number = 0.0;\r\n\tpublic initialEqFilterInput2: number = 0.0;\r\n\t\r\n\tpublic panningDelayLine: Float32Array | null = null;\r\n\tpublic panningDelayPos: number = 0;\r\n\tpublic panningVolumeL: number = 0.0;\r\n\tpublic panningVolumeR: number = 0.0;\r\n\tpublic panningVolumeDeltaL: number = 0.0;\r\n\tpublic panningVolumeDeltaR: number = 0.0;\r\n\tpublic panningOffsetL: number = 0.0;\r\n\tpublic panningOffsetR: number = 0.0;\r\n\tpublic panningOffsetDeltaL: number = 0.0;\r\n\tpublic panningOffsetDeltaR: number = 0.0;\r\n\t\r\n\tpublic chorusDelayLineL: Float32Array | null = null;\r\n\tpublic chorusDelayLineR: Float32Array | null = null;\r\n\tpublic chorusDelayLineDirty: boolean = false;\r\n\tpublic chorusDelayPos: number = 0;\r\n\tpublic chorusPhase: number = 0;\r\n\tpublic chorusVoiceMult: number = 0;\r\n\tpublic chorusVoiceMultDelta: number = 0;\r\n\tpublic chorusCombinedMult: number = 0;\r\n\tpublic chorusCombinedMultDelta: number = 0;\r\n\t\r\n\tpublic echoDelayLineL: Float32Array | null = null;\r\n\tpublic echoDelayLineR: Float32Array | null = null;\r\n\tpublic echoDelayLineDirty: boolean = false;\r\n\tpublic echoDelayPos: number = 0;\r\n\tpublic echoDelayOffsetStart: number = 0;\r\n\tpublic echoDelayOffsetEnd: number | null = null;\r\n\tpublic echoDelayOffsetRatio: number = 0.0;\r\n\tpublic echoDelayOffsetRatioDelta: number = 0.0;\r\n\tpublic echoMult: number = 0.0;\r\n\tpublic echoMultDelta: number = 0.0;\r\n\tpublic echoShelfA1: number = 0.0;\r\n\tpublic echoShelfB0: number = 0.0;\r\n\tpublic echoShelfB1: number = 0.0;\r\n\tpublic echoShelfSampleL: number = 0.0;\r\n\tpublic echoShelfSampleR: number = 0.0;\r\n\tpublic echoShelfPrevInputL: number = 0.0;\r\n\tpublic echoShelfPrevInputR: number = 0.0;\r\n\t\r\n\tpublic reverbDelayLine: Float32Array | null = null;\r\n\tpublic reverbDelayLineDirty: boolean = false;\r\n\tpublic reverbDelayPos: number = 0;\r\n\tpublic reverbMult: number = 0.0;\r\n\tpublic reverbMultDelta: number = 0.0;\r\n\tpublic reverbShelfA1: number = 0.0;\r\n\tpublic reverbShelfB0: number = 0.0;\r\n\tpublic reverbShelfB1: number = 0.0;\r\n\tpublic reverbShelfSample0: number = 0.0;\r\n\tpublic reverbShelfSample1: number = 0.0;\r\n\tpublic reverbShelfSample2: number = 0.0;\r\n\tpublic reverbShelfSample3: number = 0.0;\r\n\tpublic reverbShelfPrevInput0: number = 0.0;\r\n\tpublic reverbShelfPrevInput1: number = 0.0;\r\n\tpublic reverbShelfPrevInput2: number = 0.0;\r\n\tpublic reverbShelfPrevInput3: number = 0.0;\r\n\t\r\n\t//public readonly envelopeComputer: EnvelopeComputer = new EnvelopeComputer(false);\r\n\t\r\n\tpublic readonly spectrumWave: SpectrumWaveState = new SpectrumWaveState();\r\n\tpublic readonly harmonicsWave: HarmonicsWaveState = new HarmonicsWaveState();\r\n\tpublic readonly drumsetSpectrumWaves: SpectrumWaveState[] = [];\r\n\t\r\n\tconstructor() {\r\n\t\tfor (let i: number = 0; i < Config.drumCount; i++) {\r\n\t\t\tthis.drumsetSpectrumWaves[i] = new SpectrumWaveState();\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic allocateNecessaryBuffers(synth: Synth, instrument: Instrument, samplesPerTick: number): void {\r\n\t\tif (effectsIncludePanning(instrument.effects)) {\r\n\t\t\tif (this.panningDelayLine == null || this.panningDelayLine.length < synth.panningDelayBufferSize) {\r\n\t\t\t\tthis.panningDelayLine = new Float32Array(synth.panningDelayBufferSize);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (effectsIncludeChorus(instrument.effects)) {\r\n\t\t\tif (this.chorusDelayLineL == null || this.chorusDelayLineL.length < synth.chorusDelayBufferSize) {\r\n\t\t\t\tthis.chorusDelayLineL = new Float32Array(synth.chorusDelayBufferSize);\r\n\t\t\t}\r\n\t\t\tif (this.chorusDelayLineR == null || this.chorusDelayLineR.length < synth.chorusDelayBufferSize) {\r\n\t\t\t\tthis.chorusDelayLineR = new Float32Array(synth.chorusDelayBufferSize);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (effectsIncludeEcho(instrument.effects)) {\r\n\t\t\t// account for tempo and delay automation changing delay length during a tick?\r\n\t\t\tconst safeEchoDelaySteps: number = Math.max(Config.echoDelayRange >> 1, (instrument.echoDelay + 1)); // The delay may be very short now, but if it increases later make sure we have enough sample history.\r\n\t\t\tconst baseEchoDelayBufferSize: number = Synth.fittingPowerOfTwo(safeEchoDelaySteps * Config.echoDelayStepTicks * samplesPerTick);\r\n\t\t\tconst safeEchoDelayBufferSize: number = baseEchoDelayBufferSize * 2; // If the tempo or delay changes and we suddenly need a longer delay, make sure that we have enough sample history to accomodate the longer delay.\r\n\t\t\t\r\n\t\t\tif (this.echoDelayLineL == null || this.echoDelayLineR == null) {\r\n\t\t\t\tthis.echoDelayLineL = new Float32Array(safeEchoDelayBufferSize);\r\n\t\t\t\tthis.echoDelayLineR = new Float32Array(safeEchoDelayBufferSize);\r\n\t\t\t} else if (this.echoDelayLineL.length < safeEchoDelayBufferSize || this.echoDelayLineR.length < safeEchoDelayBufferSize) {\r\n\t\t\t\t// The echo delay length may change whlie the song is playing if tempo changes,\r\n\t\t\t\t// so buffers may need to be reallocated, but we don't want to lose any echoes\r\n\t\t\t\t// so we need to copy the contents of the old buffer to the new one.\r\n\t\t\t\tconst newDelayLineL: Float32Array = new Float32Array(safeEchoDelayBufferSize);\r\n\t\t\t\tconst newDelayLineR: Float32Array = new Float32Array(safeEchoDelayBufferSize);\r\n\t\t\t\tconst oldMask: number = this.echoDelayLineL.length - 1;\r\n\t\t\t\t\r\n\t\t\t\tfor (let i = 0; i < this.echoDelayLineL.length; i++) {\r\n\t\t\t\t\tnewDelayLineL[i] = this.echoDelayLineL[(this.echoDelayPos + i) & oldMask];\r\n\t\t\t\t\tnewDelayLineR[i] = this.echoDelayLineL[(this.echoDelayPos + i) & oldMask];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tthis.echoDelayPos = this.echoDelayLineL.length;\r\n\t\t\t\tthis.echoDelayLineL = newDelayLineL;\r\n\t\t\t\tthis.echoDelayLineR = newDelayLineR;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (effectsIncludeReverb(instrument.effects)) {\r\n\t\t\t// TODO: Make reverb delay line sample rate agnostic. Maybe just double buffer size for 96KHz? Adjust attenuation and shelf cutoff appropriately?\r\n\t\t\tif (this.reverbDelayLine == null) {\r\n\t\t\t\tthis.reverbDelayLine = new Float32Array(Config.reverbDelayBufferSize);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic deactivate(): void {\r\n\t\tthis.bitcrusherPrevInput = 0.0;\r\n\t\tthis.bitcrusherCurrentOutput = 0.0;\r\n\t\tthis.bitcrusherPhase = 1.0;\r\n\t\tfor (let i: number = 0; i < this.eqFilterCount; i++) {\r\n\t\t\tthis.eqFilters[i].resetOutput();\r\n\t\t}\r\n\t\tthis.eqFilterCount = 0;\r\n\t\tthis.initialEqFilterInput1 = 0.0;\r\n\t\tthis.initialEqFilterInput2 = 0.0;\r\n\t\tthis.distortionFractionalInput1 = 0.0;\r\n\t\tthis.distortionFractionalInput2 = 0.0;\r\n\t\tthis.distortionFractionalInput3 = 0.0;\r\n\t\tthis.distortionPrevInput = 0.0;\r\n\t\tthis.distortionNextOutput = 0.0;\r\n\t\tthis.panningDelayPos = 0;\r\n\t\tif (this.panningDelayLine != null) for (let i: number = 0; i < this.panningDelayLine.length; i++) this.panningDelayLine[i] = 0.0;\r\n\t\tthis.echoDelayOffsetEnd = null;\r\n\t\tthis.echoShelfSampleL = 0.0;\r\n\t\tthis.echoShelfSampleR = 0.0;\r\n\t\tthis.echoShelfPrevInputL = 0.0;\r\n\t\tthis.echoShelfPrevInputR = 0.0;\r\n\t\tthis.reverbShelfSample0 = 0.0;\r\n\t\tthis.reverbShelfSample1 = 0.0;\r\n\t\tthis.reverbShelfSample2 = 0.0;\r\n\t\tthis.reverbShelfSample3 = 0.0;\r\n\t\tthis.reverbShelfPrevInput0 = 0.0;\r\n\t\tthis.reverbShelfPrevInput1 = 0.0;\r\n\t\tthis.reverbShelfPrevInput2 = 0.0;\r\n\t\tthis.reverbShelfPrevInput3 = 0.0;\r\n\t\t\r\n\t\tthis.awake = false;\r\n\t\tthis.flushingDelayLines = false;\r\n\t\tthis.deactivateAfterThisTick = false;\r\n\t\tthis.attentuationProgress = 0.0;\r\n\t\tthis.flushedSamples = 0;\r\n\t}\r\n\t\r\n\tpublic resetAllEffects(): void {\r\n\t\tthis.deactivate();\r\n\t\t\r\n\t\tif (this.chorusDelayLineDirty) {\r\n\t\t\tfor (let i: number = 0; i < this.chorusDelayLineL!.length; i++) this.chorusDelayLineL![i] = 0.0;\r\n\t\t\tfor (let i: number = 0; i < this.chorusDelayLineR!.length; i++) this.chorusDelayLineR![i] = 0.0;\r\n\t\t}\r\n\t\tif (this.echoDelayLineDirty) {\r\n\t\t\tfor (let i: number = 0; i < this.echoDelayLineL!.length; i++) this.echoDelayLineL![i] = 0.0;\r\n\t\t\tfor (let i: number = 0; i < this.echoDelayLineR!.length; i++) this.echoDelayLineR![i] = 0.0;\r\n\t\t}\r\n\t\tif (this.reverbDelayLineDirty) {\r\n\t\t\tfor (let i: number = 0; i < this.reverbDelayLine!.length; i++) this.reverbDelayLine![i] = 0.0;\r\n\t\t}\r\n\t\t\r\n\t\tthis.chorusPhase = 0.0;\r\n\t}\r\n\t\r\n\tpublic compute(synth: Synth, instrument: Instrument, samplesPerTick: number, roundedSamplesPerTick: number, tone: Tone | null): void {\r\n\t\tthis.computed = true;\r\n\t\t\r\n\t\tthis.type = instrument.type;\r\n\t\tthis.synthesizer = Synth.getInstrumentSynthFunction(instrument);\r\n\t\tthis.unison = Config.unisons[instrument.unison];\r\n\t\tthis.chord = instrument.getChord();\r\n\t\tthis.noisePitchFilterMult = Config.chipNoises[instrument.chipNoise].pitchFilterMult;\r\n\t\t\r\n\t\t// Force effects to be disabled if the corresponding slider is at zero (and automation isn't involved).\r\n\t\tlet effects: number = instrument.effects;\r\n\t\tif (instrument.distortion  == 0)        effects &= ~(1 << EffectType.distortion);\r\n\t\tif (instrument.pan == Config.panCenter) effects &= ~(1 << EffectType.panning);\r\n\t\tif (instrument.chorus      == 0)        effects &= ~(1 << EffectType.chorus);\r\n\t\tif (instrument.echoSustain == 0)        effects &= ~(1 << EffectType.echo);\r\n\t\tif (instrument.reverb      == 0)        effects &= ~(1 << EffectType.reverb);\r\n\t\tthis.effects = effects;\r\n\t\t\r\n\t\tthis.allocateNecessaryBuffers(synth, instrument, samplesPerTick);\r\n\t\t\r\n\t\tconst samplesPerSecond: number = synth.samplesPerSecond;\r\n\t\t\r\n\t\tthis.updateWaves(instrument, samplesPerSecond);\r\n\t\t\r\n\t\t//const ticksIntoBar: number = synth.getTicksIntoBar();\r\n\t\t//const tickTimeStart: number = ticksIntoBar;\r\n\t\t//const tickTimeEnd:   number = ticksIntoBar + 1.0;\r\n\t\t//const secondsPerTick: number = samplesPerTick / synth.samplesPerSecond;\r\n\t\t//const currentPart: number = synth.getCurrentPart();\r\n\t\t//this.envelopeComputer.computeEnvelopes(instrument, currentPart, tickTimeStart, secondsPerTick, tone);\r\n\t\t//const envelopeStarts: number[] = this.envelopeComputer.envelopeStarts;\r\n\t\t//const envelopeEnds: number[] = this.envelopeComputer.envelopeEnds;\r\n\t\t\r\n\t\tconst usesDistortion: boolean = effectsIncludeDistortion(effects);\r\n\t\tconst usesBitcrusher: boolean = effectsIncludeBitcrusher(effects);\r\n\t\tconst usesPanning:    boolean = effectsIncludePanning(effects);\r\n\t\tconst usesChorus:     boolean = effectsIncludeChorus(effects);\r\n\t\tconst usesEcho:       boolean = effectsIncludeEcho(effects);\r\n\t\tconst usesReverb:     boolean = effectsIncludeReverb(effects);\r\n\t\t\r\n\t\tif (usesDistortion) {\r\n\t\t\tconst distortionSliderStart: number = Math.min(1.0, /*envelopeStarts[InstrumentAutomationIndex.distortion] **/ instrument.distortion / (Config.distortionRange - 1));\r\n\t\t\tconst distortionSliderEnd:   number = Math.min(1.0, /*envelopeEnds[  InstrumentAutomationIndex.distortion] **/ instrument.distortion / (Config.distortionRange - 1));\r\n\t\t\tconst distortionStart: number = Math.pow(1.0 - 0.895 * (Math.pow(20.0, distortionSliderStart) - 1.0) / 19.0, 2.0);\r\n\t\t\tconst distortionEnd:   number = Math.pow(1.0 - 0.895 * (Math.pow(20.0, distortionSliderEnd  ) - 1.0) / 19.0, 2.0);\r\n\t\t\tconst distortionDriveStart: number = (1.0 + 2.0 * distortionSliderStart) / Config.distortionBaseVolume;\r\n\t\t\tconst distortionDriveEnd:   number = (1.0 + 2.0 * distortionSliderEnd)   / Config.distortionBaseVolume;\r\n\t\t\tthis.distortion = distortionStart;\r\n\t\t\tthis.distortionDelta = (distortionEnd - distortionStart) / roundedSamplesPerTick;\r\n\t\t\tthis.distortionDrive = distortionDriveStart;\r\n\t\t\tthis.distortionDriveDelta = (distortionDriveEnd - distortionDriveStart) / roundedSamplesPerTick;\r\n\t\t}\r\n\t\t\r\n\t\tif (usesBitcrusher) {\r\n\t\t\tconst freqSettingStart: number = instrument.bitcrusherFreq /** Math.sqrt(envelopeStarts[InstrumentAutomationIndex.bitcrusherFrequency])*/;\r\n\t\t\tconst freqSettingEnd:   number = instrument.bitcrusherFreq /** Math.sqrt(envelopeEnds[  InstrumentAutomationIndex.bitcrusherFrequency])*/;\r\n\t\t\tconst quantizationSettingStart: number = instrument.bitcrusherQuantization /** Math.sqrt(envelopeStarts[InstrumentAutomationIndex.bitcrusherQuantization])*/;\r\n\t\t\tconst quantizationSettingEnd:   number = instrument.bitcrusherQuantization /** Math.sqrt(envelopeEnds[  InstrumentAutomationIndex.bitcrusherQuantization])*/;\r\n\t\t\t\r\n\t\t\tconst basePitch: number = Config.keys[synth.song!.key].basePitch; // TODO: What if there's a key change mid-song?\r\n\t\t\tconst freqStart: number = Instrument.frequencyFromPitch(basePitch + 60) * Math.pow(2.0, (Config.bitcrusherFreqRange - 1 - freqSettingStart) * Config.bitcrusherOctaveStep);\r\n\t\t\tconst freqEnd:   number = Instrument.frequencyFromPitch(basePitch + 60) * Math.pow(2.0, (Config.bitcrusherFreqRange - 1 - freqSettingEnd)   * Config.bitcrusherOctaveStep);\r\n\t\t\tconst phaseDeltaStart: number = Math.min(1.0, freqStart / samplesPerSecond);\r\n\t\t\tconst phaseDeltaEnd:   number = Math.min(1.0, freqEnd   / samplesPerSecond);\r\n\t\t\tthis.bitcrusherPhaseDelta = phaseDeltaStart;\r\n\t\t\tthis.bitcrusherPhaseDeltaScale = Math.pow(phaseDeltaEnd / phaseDeltaStart, 1.0 / roundedSamplesPerTick);\r\n\t\t\t\r\n\t\t\tconst scaleStart: number = 2.0 * Config.bitcrusherBaseVolume * Math.pow(2.0, 1.0 - Math.pow(2.0, (Config.bitcrusherQuantizationRange - 1 - quantizationSettingStart) * 0.5));\r\n\t\t\tconst scaleEnd:   number = 2.0 * Config.bitcrusherBaseVolume * Math.pow(2.0, 1.0 - Math.pow(2.0, (Config.bitcrusherQuantizationRange - 1 - quantizationSettingEnd)   * 0.5));\r\n\t\t\tthis.bitcrusherScale = scaleStart;\r\n\t\t\tthis.bitcrusherScaleScale = Math.pow(scaleEnd / scaleStart, 1.0 / roundedSamplesPerTick);\r\n\t\t\t\r\n\t\t\tconst foldLevelStart: number = 2.0 * Config.bitcrusherBaseVolume * Math.pow(1.5, Config.bitcrusherQuantizationRange - 1 - quantizationSettingStart);\r\n\t\t\tconst foldLevelEnd:   number = 2.0 * Config.bitcrusherBaseVolume * Math.pow(1.5, Config.bitcrusherQuantizationRange - 1 - quantizationSettingEnd);\r\n\t\t\tthis.bitcrusherFoldLevel = foldLevelStart;\r\n\t\t\tthis.bitcrusherFoldLevelScale = Math.pow(foldLevelEnd / foldLevelStart, 1.0 / roundedSamplesPerTick);\r\n\t\t}\r\n\t\t\r\n\t\tlet eqFilterVolume: number = 1.0; //this.envelopeComputer.lowpassCutoffDecayVolumeCompensation;\r\n\t\tconst eqFilterSettings: FilterSettings = instrument.eqFilter;\r\n\t\t//const eqAllFreqsEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.eqFilterAllFreqs];\r\n\t\t//const eqAllFreqsEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.eqFilterAllFreqs];\r\n\t\tfor (let i: number = 0; i < eqFilterSettings.controlPointCount; i++) {\r\n\t\t\t//const eqFreqEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.eqFilterFreq0 + i];\r\n\t\t\t//const eqFreqEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.eqFilterFreq0 + i];\r\n\t\t\t//const eqPeakEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.eqFilterGain0 + i];\r\n\t\t\t//const eqPeakEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.eqFilterGain0 + i];\r\n\t\t\tconst point: FilterControlPoint = eqFilterSettings.controlPoints[i];\r\n\t\t\tpoint.toCoefficients(Synth.tempFilterStartCoefficients, samplesPerSecond, /*eqAllFreqsEnvelopeStart * eqFreqEnvelopeStart*/ 1.0, /*eqPeakEnvelopeStart*/ 1.0);\r\n\t\t\tpoint.toCoefficients(Synth.tempFilterEndCoefficients,   samplesPerSecond, /*eqAllFreqsEnvelopeEnd   * eqFreqEnvelopeEnd*/   1.0, /*eqPeakEnvelopeEnd*/   1.0);\r\n\t\t\tif (this.eqFilters.length <= i) this.eqFilters[i] = new DynamicBiquadFilter();\r\n\t\t\tthis.eqFilters[i].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / roundedSamplesPerTick, point.type == FilterType.lowPass);\r\n\t\t\teqFilterVolume *= point.getVolumeCompensationMult();\r\n\t\t}\r\n\t\tthis.eqFilterCount = eqFilterSettings.controlPointCount;\r\n\t\teqFilterVolume = Math.min(3.0, eqFilterVolume);\r\n\t\t\r\n\t\tconst mainInstrumentVolume: number = Synth.instrumentVolumeToVolumeMult(instrument.volume);\r\n\t\tthis.mixVolume = mainInstrumentVolume /** envelopeStarts[InstrumentAutomationIndex.mixVolume]*/;\r\n\t\tconst mixVolumeEnd  = mainInstrumentVolume /** envelopeEnds[  InstrumentAutomationIndex.mixVolume]*/;\r\n\t\tthis.mixVolumeDelta = (mixVolumeEnd - this.mixVolume) / roundedSamplesPerTick;\r\n\t\t\r\n\t\tlet eqFilterVolumeStart: number = eqFilterVolume;\r\n\t\tlet eqFilterVolumeEnd: number = eqFilterVolume;\r\n\t\tlet delayInputMultStart: number = 1.0;\r\n\t\tlet delayInputMultEnd: number = 1.0;\r\n\t\t\r\n\t\tif (usesPanning) {\r\n\t\t\t//const panEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.panning] * 2.0 - 1.0;\r\n\t\t\t//const panEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.panning] * 2.0 - 1.0;\r\n\t\t\tconst pan: number = (instrument.pan - Config.panCenter) / Config.panCenter;\r\n\t\t\tconst panStart: number = Math.max(-1.0, Math.min(1.0, pan /** panEnvelopeStart*/));\r\n\t\t\tconst panEnd:   number = Math.max(-1.0, Math.min(1.0, pan /** panEnvelopeEnd  */));\r\n\t\t\tconst volumeStartL: number = Math.cos((1 + panStart) * Math.PI * 0.25) * 1.414;\r\n\t\t\tconst volumeStartR: number = Math.cos((1 - panStart) * Math.PI * 0.25) * 1.414;\r\n\t\t\tconst volumeEndL:   number = Math.cos((1 + panEnd)   * Math.PI * 0.25) * 1.414;\r\n\t\t\tconst volumeEndR:   number = Math.cos((1 - panEnd)   * Math.PI * 0.25) * 1.414;\r\n\t\t\tconst maxDelaySamples: number = samplesPerSecond * Config.panDelaySecondsMax;\r\n\t\t\tconst delayStart: number = panStart * maxDelaySamples;\r\n\t\t\tconst delayEnd:   number = panEnd   * maxDelaySamples;\r\n\t\t\tconst delayStartL: number = Math.max(0.0,  delayStart);\r\n\t\t\tconst delayStartR: number = Math.max(0.0, -delayStart);\r\n\t\t\tconst delayEndL:   number = Math.max(0.0,  delayEnd);\r\n\t\t\tconst delayEndR:   number = Math.max(0.0, -delayEnd);\r\n\t\t\t\r\n\t\t\tthis.panningVolumeL = volumeStartL;\r\n\t\t\tthis.panningVolumeR = volumeStartR;\r\n\t\t\tthis.panningVolumeDeltaL = (volumeEndL - volumeStartL) / roundedSamplesPerTick;\r\n\t\t\tthis.panningVolumeDeltaR = (volumeEndR - volumeStartR) / roundedSamplesPerTick;\r\n\t\t\tthis.panningOffsetL = this.panningDelayPos - delayStartL + synth.panningDelayBufferSize;\r\n\t\t\tthis.panningOffsetR = this.panningDelayPos - delayStartR + synth.panningDelayBufferSize;\r\n\t\t\tthis.panningOffsetDeltaL = (delayEndL - delayStartL) / roundedSamplesPerTick;\r\n\t\t\tthis.panningOffsetDeltaR = (delayEndR - delayStartR) / roundedSamplesPerTick;\r\n\t\t}\r\n\t\t\r\n\t\tif (usesChorus) {\r\n\t\t\t//const chorusEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.chorus];\r\n\t\t\t//const chorusEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.chorus];\r\n\t\t\tlet chorusStart: number = Math.min(1.0, /*chorusEnvelopeStart **/ instrument.chorus / (Config.chorusRange - 1));\r\n\t\t\tlet chorusEnd:   number = Math.min(1.0, /*chorusEnvelopeEnd   **/ instrument.chorus / (Config.chorusRange - 1));\r\n\t\t\tchorusStart = chorusStart * 0.6 + (Math.pow(chorusStart, 6.0)) * 0.4;\r\n\t\t\tchorusEnd   = chorusEnd   * 0.6 + (Math.pow(chorusEnd,   6.0)) * 0.4;\r\n\t\t\tconst chorusCombinedMultStart = 1.0 / Math.sqrt(3.0 * chorusStart * chorusStart + 1.0);\r\n\t\t\tconst chorusCombinedMultEnd = 1.0 / Math.sqrt(3.0 * chorusEnd * chorusEnd + 1.0);\r\n\t\t\tthis.chorusVoiceMult = chorusStart;\r\n\t\t\tthis.chorusVoiceMultDelta = (chorusEnd - chorusStart) / roundedSamplesPerTick;\r\n\t\t\tthis.chorusCombinedMult = chorusCombinedMultStart;\r\n\t\t\tthis.chorusCombinedMultDelta = (chorusCombinedMultEnd - chorusCombinedMultStart) / roundedSamplesPerTick;\r\n\t\t}\r\n\t\t\r\n\t\tlet maxEchoMult = 0.0;\r\n\t\tlet averageEchoDelaySeconds: number = 0.0;\r\n\t\tif (usesEcho) {\r\n\t\t\t//const echoSustainEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.echoSustain];\r\n\t\t\t//const echoSustainEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.echoSustain];\r\n\t\t\tconst echoMultStart: number = Math.min(1.0, Math.pow(/*echoSustainEnvelopeStart **/ instrument.echoSustain / Config.echoSustainRange, 1.1)) * 0.9;\r\n\t\t\tconst echoMultEnd:   number = Math.min(1.0, Math.pow(/*echoSustainEnvelopeEnd   **/ instrument.echoSustain / Config.echoSustainRange, 1.1)) * 0.9;\r\n\t\t\tthis.echoMult = echoMultStart;\r\n\t\t\tthis.echoMultDelta = (echoMultEnd - echoMultStart) / roundedSamplesPerTick;\r\n\t\t\tmaxEchoMult = Math.max(echoMultStart, echoMultEnd);\r\n\t\t\t\r\n\t\t\t// TODO: After computing a tick's settings once for multiple run lengths (which is\r\n\t\t\t// good for audio worklet threads), compute the echo delay envelopes at tick (or\r\n\t\t\t// part) boundaries to interpolate between two delay taps.\r\n\t\t\t//const echoDelayEnvelopeStart:   number = envelopeStarts[InstrumentAutomationIndex.echoDelay];\r\n\t\t\t//const echoDelayEnvelopeEnd:     number = envelopeEnds[  InstrumentAutomationIndex.echoDelay];\r\n\t\t\tconst echoDelayOffset: number = Math.round((instrument.echoDelay + 1) * Config.echoDelayStepTicks * samplesPerTick);\r\n\t\t\tif (this.echoDelayOffsetEnd != null) {\r\n\t\t\t\tthis.echoDelayOffsetStart = this.echoDelayOffsetEnd;\r\n\t\t\t} else {\r\n\t\t\t\tthis.echoDelayOffsetStart = echoDelayOffset;\r\n\t\t\t}\r\n\t\t\tthis.echoDelayOffsetEnd = echoDelayOffset;\r\n\t\t\taverageEchoDelaySeconds = (this.echoDelayOffsetStart + this.echoDelayOffsetEnd) * 0.5 / samplesPerSecond;\r\n\t\t\t\r\n\t\t\tthis.echoDelayOffsetRatio = 0.0;\r\n\t\t\tthis.echoDelayOffsetRatioDelta = 1.0 / roundedSamplesPerTick;\r\n\t\t\t\r\n\t\t\tconst shelfRadians: number = 2.0 * Math.PI * Config.echoShelfHz / synth.samplesPerSecond;\r\n\t\t\tSynth.tempFilterStartCoefficients.highShelf1stOrder(shelfRadians, Config.echoShelfGain);\r\n\t\t\tthis.echoShelfA1 = Synth.tempFilterStartCoefficients.a[1];\r\n\t\t\tthis.echoShelfB0 = Synth.tempFilterStartCoefficients.b[0];\r\n\t\t\tthis.echoShelfB1 = Synth.tempFilterStartCoefficients.b[1];\r\n\t\t}\r\n\t\t\r\n\t\tlet maxReverbMult = 0.0;\r\n\t\tif (usesReverb) {\r\n\t\t\t//const reverbEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.reverb];\r\n\t\t\t//const reverbEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.reverb];\r\n\t\t\tconst reverbStart: number = Math.min(1.0, Math.pow(/*reverbEnvelopeStart **/ instrument.reverb / Config.reverbRange, 0.667)) * 0.425;\r\n\t\t\tconst reverbEnd:   number = Math.min(1.0, Math.pow(/*reverbEnvelopeEnd   **/ instrument.reverb / Config.reverbRange, 0.667)) * 0.425;\r\n\t\t\tthis.reverbMult = reverbStart;\r\n\t\t\tthis.reverbMultDelta = (reverbEnd - reverbStart) / roundedSamplesPerTick;\r\n\t\t\tmaxReverbMult = Math.max(reverbStart, reverbEnd);\r\n\t\t\t\r\n\t\t\tconst shelfRadians: number = 2.0 * Math.PI * Config.reverbShelfHz / synth.samplesPerSecond;\r\n\t\t\tSynth.tempFilterStartCoefficients.highShelf1stOrder(shelfRadians, Config.reverbShelfGain);\r\n\t\t\tthis.reverbShelfA1 = Synth.tempFilterStartCoefficients.a[1];\r\n\t\t\tthis.reverbShelfB0 = Synth.tempFilterStartCoefficients.b[0];\r\n\t\t\tthis.reverbShelfB1 = Synth.tempFilterStartCoefficients.b[1];\r\n\t\t}\r\n\t\t\r\n\t\tif (this.tonesAddedInThisTick) {\r\n\t\t\tthis.attentuationProgress = 0.0;\r\n\t\t\tthis.flushedSamples = 0;\r\n\t\t\tthis.flushingDelayLines = false;\r\n\t\t} else if (!this.flushingDelayLines) {\r\n\t\t\t// If this instrument isn't playing tones anymore, the volume can fade out by the\r\n\t\t\t// end of the first tick. It's possible for filters and the panning delay line to\r\n\t\t\t// continue past the end of the tone but they should have mostly dissipated by the\r\n\t\t\t// end of the tick anyway.\r\n\t\t\tif (this.attentuationProgress == 0.0) {\r\n\t\t\t\teqFilterVolumeEnd = 0.0;\r\n\t\t\t} else {\r\n\t\t\t\teqFilterVolumeStart = 0.0;\r\n\t\t\t\teqFilterVolumeEnd = 0.0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst attenuationThreshold: number = 1.0 / 256.0; // when the delay line signal has attenuated this much, it should be inaudible and should be flushed to zero.\r\n\t\t\tconst halfLifeMult: number = -Math.log2(attenuationThreshold);\r\n\t\t\tlet delayDuration: number = 0.0;\r\n\t\t\t\r\n\t\t\tif (usesChorus) {\r\n\t\t\t\tdelayDuration += Config.chorusMaxDelay;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesEcho) {\r\n\t\t\t\tconst attenuationPerSecond: number = Math.pow(maxEchoMult, 1.0 / averageEchoDelaySeconds);\r\n\t\t\t\tconst halfLife: number = -1.0 / Math.log2(attenuationPerSecond);\r\n\t\t\t\tconst echoDuration: number = halfLife * halfLifeMult;\r\n\t\t\t\tdelayDuration += echoDuration;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesReverb) {\r\n\t\t\t\tconst averageMult: number = maxReverbMult * 2.0;\r\n\t\t\t\tconst averageReverbDelaySeconds: number = (Config.reverbDelayBufferSize / 4.0) / samplesPerSecond;\r\n\t\t\t\tconst attenuationPerSecond: number = Math.pow(averageMult, 1.0 / averageReverbDelaySeconds);\r\n\t\t\t\tconst halfLife: number = -1.0 / Math.log2(attenuationPerSecond);\r\n\t\t\t\tconst reverbDuration: number = halfLife * halfLifeMult;\r\n\t\t\t\tdelayDuration += reverbDuration;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst secondsInTick: number = samplesPerTick / samplesPerSecond;\r\n\t\t\tconst progressInTick: number = secondsInTick / delayDuration;\r\n\t\t\tconst progressAtEndOfTick: number = this.attentuationProgress + progressInTick;\r\n\t\t\tif (progressAtEndOfTick >= 1.0) {\r\n\t\t\t\tdelayInputMultEnd = 0.0;\r\n\t\t\t}\r\n\t\t\tthis.attentuationProgress = progressAtEndOfTick;\r\n\t\t\tif (this.attentuationProgress >= 1.0) {\r\n\t\t\t\tthis.flushingDelayLines = true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Flushing delay lines to zero since the signal has mostly dissipated.\r\n\t\t\teqFilterVolumeStart = 0.0;\r\n\t\t\teqFilterVolumeEnd = 0.0;\r\n\t\t\tdelayInputMultStart = 0.0;\r\n\t\t\tdelayInputMultEnd = 0.0;\r\n\t\t\t\r\n\t\t\tlet totalDelaySamples: number = 0;\r\n\t\t\tif (usesChorus) totalDelaySamples += synth.chorusDelayBufferSize;\r\n\t\t\tif (usesEcho) totalDelaySamples += this.echoDelayLineL!.length;\r\n\t\t\tif (usesReverb) totalDelaySamples += Config.reverbDelayBufferSize;\r\n\t\t\t\r\n\t\t\tthis.flushedSamples += roundedSamplesPerTick;\r\n\t\t\tif (this.flushedSamples >= totalDelaySamples) {\r\n\t\t\t\tthis.deactivateAfterThisTick = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tthis.eqFilterVolume = eqFilterVolumeStart;\r\n\t\tthis.eqFilterVolumeDelta = (eqFilterVolumeEnd - eqFilterVolumeStart) / roundedSamplesPerTick;\r\n\t\tthis.delayInputMult = delayInputMultStart;\r\n\t\tthis.delayInputMultDelta = (delayInputMultEnd - delayInputMultStart) / roundedSamplesPerTick;\r\n\t}\r\n\t\r\n\tpublic updateWaves(instrument: Instrument, samplesPerSecond: number): void {\r\n\t\tif (instrument.type == InstrumentType.chip) {\r\n\t\t\tthis.wave = Config.chipWaves[instrument.chipWave].samples;\r\n\t\t} else if (instrument.type == InstrumentType.noise) {\r\n\t\t\tthis.wave = getDrumWave(instrument.chipNoise, inverseRealFourierTransform, scaleElementsByFactor);\r\n\t\t} else if (instrument.type == InstrumentType.harmonics) {\r\n\t\t\tthis.wave = this.harmonicsWave.getCustomWave(instrument.harmonicsWave, instrument.type);\r\n\t\t} else if (instrument.type == InstrumentType.pickedString) {\r\n\t\t\tthis.wave = this.harmonicsWave.getCustomWave(instrument.harmonicsWave, instrument.type);\r\n\t\t} else if (instrument.type == InstrumentType.spectrum) {\r\n\t\t\tthis.wave = this.spectrumWave.getCustomWave(instrument.spectrumWave, 8);\r\n\t\t} else if (instrument.type == InstrumentType.drumset) {\r\n\t\t\tfor (let i: number = 0; i < Config.drumCount; i++) {\r\n\t\t\t\tthis.drumsetSpectrumWaves[i].getCustomWave(instrument.drumsetSpectrumWaves[i], InstrumentState._drumsetIndexToSpectrumOctave(i));\r\n\t\t\t}\r\n\t\t\tthis.wave = null;\r\n\t\t} else {\r\n\t\t\tthis.wave = null;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic getDrumsetWave(pitch: number): Float32Array {\r\n\t\tif (this.type == InstrumentType.drumset) {\r\n\t\t\treturn this.drumsetSpectrumWaves[pitch].wave!;\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Unhandled instrument type in getDrumsetWave\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static drumsetIndexReferenceDelta(index: number): number {\r\n\t\treturn Instrument.frequencyFromPitch(Config.spectrumBasePitch + index * 6) / 44100;\r\n\t}\r\n\t\r\n\tprivate static _drumsetIndexToSpectrumOctave(index: number): number {\r\n\t\treturn 15 + Math.log2(InstrumentState.drumsetIndexReferenceDelta(index));\r\n\t}\r\n}\r\n\r\nclass ChannelState {\r\n\tpublic readonly instruments: InstrumentState[] = [];\r\n\tpublic muted: boolean = false;\r\n\tpublic singleSeamlessInstrument: number | null = null; // Seamless tones from a pattern with a single instrument can be transferred to a different single seamless instrument in the next pattern.\r\n}\r\n\r\nexport class Synth {\r\n\r\n\tprivate syncSongState(): void {\r\n\t\tconst channelCount: number = this.song!.getChannelCount();\r\n\t\tfor (let i: number = this.channels.length; i < channelCount; i++) {\r\n\t\t\tthis.channels[i] = new ChannelState();\r\n\t\t}\r\n\t\tthis.channels.length = channelCount;\r\n\t\tfor (let i: number = 0; i < channelCount; i++) {\r\n\t\t\tconst channel: Channel = this.song!.channels[i];\r\n\t\t\tconst channelState: ChannelState = this.channels[i];\r\n\t\t\tfor (let j: number = channelState.instruments.length; j < channel.instruments.length; j++) {\r\n\t\t\t\tchannelState.instruments[j] = new InstrumentState();\r\n\t\t\t}\r\n\t\t\tchannelState.instruments.length = channel.instruments.length;\r\n\t\t\t\r\n\t\t\tif (channelState.muted != channel.muted) {\r\n\t\t\t\tchannelState.muted = channel.muted;\r\n\t\t\t\tif (channelState.muted) {\r\n\t\t\t\t\tfor (const instrumentState of channelState.instruments) {\r\n\t\t\t\t\t\tinstrumentState.resetAllEffects();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate warmUpSynthesizer(song: Song | null): void {\r\n\t\tif (song != null) {\r\n\t\t\tthis.syncSongState();\r\n\t\t\tconst samplesPerTick: number = this.getSamplesPerTick();\r\n\t\t\tfor (let j: number = 0; j < song.getChannelCount(); j++) {\r\n\t\t\t\tfor (let i: number = 0; i < song.channels[j].instruments.length; i++) {\r\n\t\t\t\t\tconst instrument: Instrument = song.channels[j].instruments[i];\r\n\t\t\t\t\tconst instrumentState: InstrumentState = this.channels[j].instruments[i];\r\n\t\t\t\t\tSynth.getInstrumentSynthFunction(instrument);\r\n\t\t\t\t\tinstrumentState.updateWaves(instrument, this.samplesPerSecond);\r\n\t\t\t\t\tinstrumentState.allocateNecessaryBuffers(this, instrument, samplesPerTick);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t/*\r\n\t\t// JummBox needed to run synth functions for at least one sample (for JIT purposes)\r\n\t\t// before starting audio callbacks to avoid skipping the initial output.\r\n\t\tvar dummyArray = new Float32Array(1);\r\n\t\tthis.synthesize(dummyArray, dummyArray, 1, true);\r\n\t\t*/\r\n\t}\r\n\t\r\n\tprivate static operatorAmplitudeCurve(amplitude: number): number {\r\n\t\treturn (Math.pow(16.0, amplitude / 15.0) - 1.0) / 15.0;\r\n\t}\r\n\t\r\n\tpublic samplesPerSecond: number = 44100;\r\n\tpublic panningDelayBufferSize: number;\r\n\tpublic panningDelayBufferMask: number;\r\n\tpublic chorusDelayBufferSize: number;\r\n\tpublic chorusDelayBufferMask: number;\r\n\t// TODO: reverb\r\n\t\r\n\tpublic song: Song | null = null;\r\n\tpublic preferLowerLatency: boolean = false; // enable when recording performances from keyboard or MIDI. Takes effect next time you activate audio.\r\n\tpublic anticipatePoorPerformance: boolean = false; // enable on mobile devices to reduce audio stutter glitches. Takes effect next time you activate audio.\r\n\tpublic liveInputDuration: number = 0;\r\n\tpublic liveInputStarted: boolean = false;\r\n\tpublic liveInputPitches: number[] = [];\r\n\tpublic liveInputChannel: number = 0;\r\n\tpublic liveInputInstruments: number[] = [];\r\n\tpublic loopRepeatCount: number = -1;\r\n\tpublic volume: number = 1.0;\r\n\tpublic enableMetronome: boolean = false;\r\n\tpublic countInMetronome: boolean = false;\r\n\t\r\n\tprivate playheadInternal: number = 0.0;\r\n\tprivate bar: number = 0;\r\n\tprivate prevBar: number | null = null;\r\n\tprivate nextBar: number | null = null;\r\n\tprivate beat: number = 0;\r\n\tprivate part: number = 0;\r\n\tprivate tick: number = 0;\r\n\tpublic isAtStartOfTick: boolean = true;\r\n\tpublic tickSampleCountdown: number = 0;\r\n\tprivate isPlayingSong: boolean = false;\r\n\tprivate isRecording: boolean = false;\r\n\tprivate liveInputEndTime: number = 0.0;\r\n\tprivate browserAutomaticallyClearsAudioBuffer: boolean = true; // Assume true until proven otherwise. Older Chrome does not clear the buffer so it needs to be cleared manually.\r\n\t\r\n\tpublic static readonly tempFilterStartCoefficients: FilterCoefficients = new FilterCoefficients();\r\n\tpublic static readonly tempFilterEndCoefficients: FilterCoefficients = new FilterCoefficients();\r\n\tprivate tempDrumSetControlPoint: FilterControlPoint = new FilterControlPoint();\r\n\tpublic tempFrequencyResponse: FrequencyResponse = new FrequencyResponse();\r\n\t\r\n\tprivate static readonly fmSynthFunctionCache: Dictionary<Function> = {};\r\n\tprivate static readonly effectsFunctionCache: Function[] = Array(1 << 7).fill(undefined); // keep in sync with the number of post-process effects.\r\n\tprivate static readonly pickedStringFunctionCache: Function[] = Array(3).fill(undefined); // keep in sync with the number of unison voices.\r\n\t\r\n\tprivate readonly channels: ChannelState[] = [];\r\n\tprivate readonly tonePool: Deque<Tone> = new Deque<Tone>();\r\n\tprivate readonly tempMatchedPitchTones: Array<Tone | null> = Array(Config.maxChordSize).fill(null);\r\n\t\r\n\tprivate startedMetronome: boolean = false;\r\n\tprivate metronomeSamplesRemaining: number = -1;\r\n\tprivate metronomeAmplitude: number = 0.0;\r\n\tprivate metronomePrevAmplitude: number = 0.0;\r\n\tprivate metronomeFilter: number = 0.0;\r\n\tprivate limit: number = 0.0;\r\n\t\r\n\tprivate tempMonoInstrumentSampleBuffer: Float32Array | null = null;\r\n\t\r\n\tprivate audioCtx: any | null = null;\r\n\tprivate scriptNode: any | null = null;\r\n\t\r\n\tpublic get playing(): boolean {\r\n\t\treturn this.isPlayingSong;\r\n\t}\r\n\t\r\n\tpublic get recording(): boolean {\r\n\t\treturn this.isRecording;\r\n\t}\r\n\t\r\n\tpublic get playhead(): number {\r\n\t\treturn this.playheadInternal;\r\n\t}\r\n\t\r\n\tpublic set playhead(value: number) {\r\n\t\tif (this.song != null) {\r\n\t\t\tthis.playheadInternal = Math.max(0, Math.min(this.song.barCount, value));\r\n\t\t\tlet remainder: number = this.playheadInternal;\r\n\t\t\tthis.bar = Math.floor(remainder);\r\n\t\t\tremainder = this.song.beatsPerBar * (remainder - this.bar);\r\n\t\t\tthis.beat = Math.floor(remainder);\r\n\t\t\tremainder = Config.partsPerBeat * (remainder - this.beat);\r\n\t\t\tthis.part = Math.floor(remainder);\r\n\t\t\tremainder = Config.ticksPerPart * (remainder - this.part);\r\n\t\t\tthis.tick = Math.floor(remainder);\r\n\t\t\tthis.tickSampleCountdown = 0;\r\n\t\t\tthis.isAtStartOfTick = true;\r\n\t\t\tthis.prevBar = null;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic getSamplesPerBar(): number {\r\n\t\tif (this.song == null) throw new Error();\r\n\t\treturn this.getSamplesPerTick() * Config.ticksPerPart * Config.partsPerBeat * this.song.beatsPerBar;\r\n\t}\r\n\t\r\n\tpublic getTicksIntoBar(): number {\r\n\t\treturn (this.beat * Config.partsPerBeat + this.part) * Config.ticksPerPart + this.tick;\r\n\t}\r\n\tpublic getCurrentPart(): number {\r\n\t\treturn (this.beat * Config.partsPerBeat + this.part);\r\n\t}\r\n\t\r\n\tpublic getTotalBars(enableIntro: boolean, enableOutro: boolean): number {\r\n\t\tif (this.song == null) throw new Error();\r\n\t\tlet bars: number = this.song.loopLength * (this.loopRepeatCount + 1);\r\n\t\tif (enableIntro) bars += this.song.loopStart;\r\n\t\tif (enableOutro) bars += this.song.barCount - (this.song.loopStart + this.song.loopLength);\r\n\t\treturn bars;\r\n\t}\r\n\t\r\n\tconstructor(song: Song | string | null = null) {\r\n\t\tthis.computeDelayBufferSizes();\r\n\t\tif (song != null) this.setSong(song);\r\n\t}\r\n\t\r\n\tpublic setSong(song: Song | string): void {\r\n\t\tif (typeof(song) == \"string\") {\r\n\t\t\tthis.song = new Song(song);\r\n\t\t} else if (song instanceof Song) {\r\n\t\t\tthis.song = song;\r\n\t\t}\r\n\t\tthis.prevBar = null;\r\n\t}\r\n\t\r\n\tprivate computeDelayBufferSizes(): void {\r\n\t\tthis.panningDelayBufferSize = Synth.fittingPowerOfTwo(this.samplesPerSecond * Config.panDelaySecondsMax);\r\n\t\tthis.panningDelayBufferMask = this.panningDelayBufferSize - 1;\r\n\t\tthis.chorusDelayBufferSize = Synth.fittingPowerOfTwo(this.samplesPerSecond * Config.chorusMaxDelay);\r\n\t\tthis.chorusDelayBufferMask = this.chorusDelayBufferSize - 1;\r\n\t}\r\n\t\r\n\tprivate activateAudio(): void {\r\n\t\tconst bufferSize: number = this.anticipatePoorPerformance ? (this.preferLowerLatency ? 2048 : 4096) : (this.preferLowerLatency ? 512 : 2048);\r\n\t\tif (this.audioCtx == null || this.scriptNode == null || this.scriptNode.bufferSize != bufferSize) {\r\n\t\t\tif (this.scriptNode != null) this.deactivateAudio();\r\n\t\t\tconst latencyHint: string = this.anticipatePoorPerformance ? (this.preferLowerLatency ? \"balanced\" : \"playback\") : (this.preferLowerLatency ? \"interactive\" : \"balanced\");\r\n\t\t\tthis.audioCtx = this.audioCtx || new (window.AudioContext || window.webkitAudioContext)({latencyHint: latencyHint});\r\n\t\t\tthis.samplesPerSecond = this.audioCtx.sampleRate;\r\n\t\t\tthis.scriptNode = this.audioCtx.createScriptProcessor ? this.audioCtx.createScriptProcessor(bufferSize, 0, 2) : this.audioCtx.createJavaScriptNode(bufferSize, 0, 2); // bufferSize samples per callback buffer, 0 input channels, 2 output channels (left/right)\r\n\t\t\tthis.scriptNode.onaudioprocess = this.audioProcessCallback;\r\n\t\t\tthis.scriptNode.channelCountMode = 'explicit';\r\n\t\t\tthis.scriptNode.channelInterpretation = 'speakers';\r\n\t\t\tthis.scriptNode.connect(this.audioCtx.destination);\r\n\t\t\t\r\n\t\t\tthis.computeDelayBufferSizes();\r\n\t\t}\r\n\t\tthis.audioCtx.resume();\r\n\t}\r\n\t\r\n\tprivate deactivateAudio(): void {\r\n\t\tif (this.audioCtx != null && this.scriptNode != null) {\r\n\t\t\tthis.scriptNode.disconnect(this.audioCtx.destination);\r\n\t\t\tthis.scriptNode = null;\r\n\t\t\tif (this.audioCtx.close) this.audioCtx.close(); // firefox is missing this function?\r\n\t\t\tthis.audioCtx = null;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic maintainLiveInput(): void {\r\n\t\tthis.activateAudio();\r\n\t\tthis.liveInputEndTime = performance.now() + 10000.0;\r\n\t}\r\n\t\r\n\tpublic play(): void {\r\n\t\tif (this.isPlayingSong) return;\r\n\t\tthis.isPlayingSong = true;\r\n\t\tthis.warmUpSynthesizer(this.song);\r\n\t\tthis.activateAudio();\r\n\t}\r\n\t\r\n\tpublic pause(): void {\r\n\t\tif (!this.isPlayingSong) return;\r\n\t\tthis.isPlayingSong = false;\r\n\t\tthis.isRecording = false;\r\n\t}\r\n\t\r\n\tpublic startRecording(): void {\r\n\t\tthis.preferLowerLatency = true;\r\n\t\tthis.isRecording = true;\r\n\t\tthis.play();\r\n\t}\r\n\t\r\n\tpublic snapToStart(): void {\r\n\t\tthis.bar = 0;\r\n\t\tthis.snapToBar();\r\n\t}\r\n\t\r\n\tpublic goToBar(bar: number): void {\r\n\t\tthis.bar = bar;\r\n\t\tthis.playheadInternal = this.bar;\r\n\t\tthis.prevBar = null;\r\n\t}\r\n\t\r\n\tpublic snapToBar(): void {\r\n\t\tthis.playheadInternal = this.bar;\r\n\t\tthis.beat = 0;\r\n\t\tthis.part = 0;\r\n\t\tthis.tick = 0;\r\n\t\tthis.tickSampleCountdown = 0;\r\n\t\tthis.isAtStartOfTick = true;\r\n\t\tthis.prevBar = null;\r\n\t}\r\n\t\r\n\tpublic resetEffects(): void {\r\n\t\tthis.limit = 0.0;\r\n\t\tthis.freeAllTones();\r\n\t\tif (this.song != null) {\r\n\t\t\tfor (const channelState of this.channels) {\r\n\t\t\t\tfor (const instrumentState of channelState.instruments) {\r\n\t\t\t\t\tinstrumentState.resetAllEffects();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic jumpIntoLoop(): void {\r\n\t\tif (!this.song) return;\r\n\t\tif (this.bar < this.song.loopStart || this.bar >= this.song.loopStart + this.song.loopLength) {\r\n\t\t\tconst oldBar: number = this.bar;\r\n\t\t\tthis.bar = this.song.loopStart;\r\n\t\t\tthis.playheadInternal += this.bar - oldBar;\r\n\t\t\tthis.prevBar = null;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic goToNextBar(): void {\r\n\t\tif (!this.song) return;\r\n\t\tthis.prevBar = this.bar;\r\n\t\tconst oldBar: number = this.bar;\r\n\t\tthis.bar++;\r\n\t\tif (this.bar >= this.song.barCount) {\r\n\t\t\tthis.bar = 0;\r\n\t\t}\r\n\t\tthis.playheadInternal += this.bar - oldBar;\r\n\t}\r\n\t\r\n\tpublic goToPrevBar(): void {\r\n\t\tif (!this.song) return;\r\n\t\tthis.prevBar = null;\r\n\t\tconst oldBar: number = this.bar;\r\n\t\tthis.bar--;\r\n\t\tif (this.bar < 0 || this.bar >= this.song.barCount) {\r\n\t\t\tthis.bar = this.song.barCount - 1;\r\n\t\t}\r\n\t\tthis.playheadInternal += this.bar - oldBar;\r\n\t}\r\n\t\r\n\tprivate getNextBar(): number {\r\n\t\tlet nextBar: number = this.bar + 1;\r\n\t\tif (this.isRecording) {\r\n\t\t\tif (nextBar >= this.song!.barCount) {\r\n\t\t\t\tnextBar = this.song!.barCount - 1;\r\n\t\t\t}\r\n\t\t} else if (this.loopRepeatCount != 0 && nextBar == this.song!.loopStart + this.song!.loopLength) {\r\n\t\t\tnextBar = this.song!.loopStart;\r\n\t\t}\r\n\t\treturn nextBar;\r\n\t}\r\n\t\r\n\tprivate audioProcessCallback = (audioProcessingEvent: any): void => {\r\n\t\tconst outputBuffer = audioProcessingEvent.outputBuffer;\r\n\t\tconst outputDataL: Float32Array = outputBuffer.getChannelData(0);\r\n\t\tconst outputDataR: Float32Array = outputBuffer.getChannelData(1);\r\n\t\t\r\n\t\tif (this.browserAutomaticallyClearsAudioBuffer && (outputDataL[0] != 0.0 || outputDataR[0] != 0.0 || outputDataL[outputBuffer.length-1] != 0.0 || outputDataR[outputBuffer.length-1] != 0.0)) {\r\n\t\t\t// If the buffer is ever initially nonzero, then this must be an older browser that doesn't automatically clear the audio buffer.\r\n\t\t\tthis.browserAutomaticallyClearsAudioBuffer = false;\r\n\t\t}\r\n\t\tif (!this.browserAutomaticallyClearsAudioBuffer) {\r\n\t\t\t// If this browser does not clear the buffer automatically, do so manually before continuing.\r\n\t\t\tconst length: number = outputBuffer.length;\r\n\t\t\tfor (let i: number = 0; i < length; i++) {\r\n\t\t\t\toutputDataL[i] = 0.0;\r\n\t\t\t\toutputDataR[i] = 0.0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (!this.isPlayingSong && performance.now() >= this.liveInputEndTime) {\r\n\t\t\tthis.deactivateAudio();\r\n\t\t} else {\r\n\t\t\tthis.synthesize(outputDataL, outputDataR, outputBuffer.length, this.isPlayingSong);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic synthesize(outputDataL: Float32Array, outputDataR: Float32Array, outputBufferLength: number, playSong: boolean = true): void {\r\n\t\tif (this.song == null) {\r\n\t\t\tfor (let i: number = 0; i < outputBufferLength; i++) {\r\n\t\t\t\toutputDataL[i] = 0.0;\r\n\t\t\t\toutputDataR[i] = 0.0;\r\n\t\t\t}\r\n\t\t\tthis.deactivateAudio();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tconst song: Song = this.song;\r\n\t\tconst samplesPerTick: number = this.getSamplesPerTick();\r\n\t\tlet ended: boolean = false;\r\n\t\t\r\n\t\t// Check the bounds of the playhead:\r\n\t\tif (this.tickSampleCountdown <= 0 || this.tickSampleCountdown > samplesPerTick) {\r\n\t\t\tthis.tickSampleCountdown = samplesPerTick;\r\n\t\t\tthis.isAtStartOfTick = true;\r\n\t\t}\r\n\t\tif (playSong) {\r\n\t\t\tif (this.beat >= song.beatsPerBar) {\r\n\t\t\t\tthis.beat = 0;\r\n\t\t\t\tthis.part = 0;\r\n\t\t\t\tthis.tick = 0;\r\n\t\t\t\tthis.tickSampleCountdown = samplesPerTick;\r\n\t\t\t\tthis.isAtStartOfTick = true;\r\n\t\t\t\t\r\n\t\t\t\tthis.prevBar = this.bar;\r\n\t\t\t\tthis.bar = this.getNextBar();\r\n\t\t\t\tif (this.bar <= this.prevBar && this.loopRepeatCount > 0) this.loopRepeatCount--;\r\n\t\t\t}\r\n\t\t\tif (this.bar >= song.barCount) {\r\n\t\t\t\tthis.bar = 0;\r\n\t\t\t\tif (this.loopRepeatCount != -1) {\r\n\t\t\t\t\tended = true;\r\n\t\t\t\t\tthis.pause();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t//const synthStartTime: number = performance.now();\r\n\t\t\r\n\t\tthis.syncSongState();\r\n\t\t\r\n\t\tif (this.tempMonoInstrumentSampleBuffer == null || this.tempMonoInstrumentSampleBuffer.length < outputBufferLength) {\r\n\t\t\tthis.tempMonoInstrumentSampleBuffer = new Float32Array(outputBufferLength);\r\n\t\t}\r\n\t\t\r\n\t\t// Post processing parameters:\r\n\t\tconst volume: number = +this.volume;\r\n\t\tconst limitDecay: number = 1.0 - Math.pow(0.5, 4.0 / this.samplesPerSecond);\r\n\t\tconst limitRise: number = 1.0 - Math.pow(0.5, 4000.0 / this.samplesPerSecond);\r\n\t\tlet limit: number = +this.limit;\r\n\t\t\r\n\t\tlet bufferIndex: number = 0;\r\n\t\twhile (bufferIndex < outputBufferLength && !ended) {\r\n\t\t\t\r\n\t\t\tthis.nextBar = this.getNextBar();\r\n\t\t\tif (this.nextBar >= song.barCount) this.nextBar = null;\r\n\t\t\t\r\n\t\t\tconst samplesLeftInBuffer: number = outputBufferLength - bufferIndex;\r\n\t\t\tconst samplesLeftInTick: number = Math.ceil(this.tickSampleCountdown);\r\n\t\t\tconst runLength: number = Math.min(samplesLeftInTick, samplesLeftInBuffer);\r\n\t\t\tconst runEnd: number = bufferIndex + runLength;\r\n\t\t\tfor (let channelIndex: number = 0; channelIndex < song.getChannelCount(); channelIndex++) {\r\n\t\t\t\tconst channel: Channel = song.channels[channelIndex];\r\n\t\t\t\tconst channelState: ChannelState = this.channels[channelIndex];\r\n\t\t\t\t\r\n\t\t\t\tif (this.isAtStartOfTick) {\r\n\t\t\t\t\tthis.determineCurrentActiveTones(song, channelIndex, samplesPerTick, playSong && !this.countInMetronome);\r\n\t\t\t\t\tthis.determineLiveInputTones(song, channelIndex, samplesPerTick);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfor (let instrumentIndex: number = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {\r\n\t\t\t\t\tconst instrument: Instrument = channel.instruments[instrumentIndex];\r\n\t\t\t\t\tconst instrumentState: InstrumentState = channelState.instruments[instrumentIndex];\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (this.isAtStartOfTick) {\r\n\t\t\t\t\t\tlet tonesPlayedInThisInstrument: number = instrumentState.activeTones.count() + instrumentState.liveInputTones.count();\r\n\t\t\t\t\t\tfor (let i: number = 0; i < instrumentState.releasedTones.count(); i++) {\r\n\t\t\t\t\t\t\tconst tone: Tone = instrumentState.releasedTones.get(i);\r\n\t\t\t\t\t\t\tif (tone.ticksSinceReleased >= Math.abs(instrument.getFadeOutTicks())) {\r\n\t\t\t\t\t\t\t\tthis.freeReleasedTone(instrumentState, i);\r\n\t\t\t\t\t\t\t\ti--;\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconst shouldFadeOutFast: boolean = (tonesPlayedInThisInstrument >= Config.maximumTonesPerChannel);\r\n\t\t\t\t\t\t\tthis.computeTone(song, channelIndex, samplesPerTick, tone, true, shouldFadeOutFast);\r\n\t\t\t\t\t\t\ttonesPlayedInThisInstrument++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (instrumentState.awake) {\r\n\t\t\t\t\t\t\tif (!instrumentState.computed) {\r\n\t\t\t\t\t\t\t\tinstrumentState.compute(this, instrument, samplesPerTick, Math.ceil(samplesPerTick), null);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tinstrumentState.computed = false;\r\n\t\t\t\t\t\t\t//instrumentState.envelopeComputer.clearEnvelopes();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (let i: number = 0; i < instrumentState.activeTones.count(); i++) {\r\n\t\t\t\t\t\tconst tone: Tone = instrumentState.activeTones.get(i);\r\n\t\t\t\t\t\tthis.playTone(channelIndex, bufferIndex, runLength, tone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (let i: number = 0; i < instrumentState.liveInputTones.count(); i++) {\r\n\t\t\t\t\t\tconst tone: Tone = instrumentState.liveInputTones.get(i);\r\n\t\t\t\t\t\tthis.playTone(channelIndex, bufferIndex, runLength, tone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (let i: number = 0; i < instrumentState.releasedTones.count(); i++) {\r\n\t\t\t\t\t\tconst tone: Tone = instrumentState.releasedTones.get(i);\r\n\t\t\t\t\t\tthis.playTone(channelIndex, bufferIndex, runLength, tone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (instrumentState.awake) {\r\n\t\t\t\t\t\tSynth.effectsSynth(this, outputDataL, outputDataR, bufferIndex, runLength, instrumentState);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (this.enableMetronome || this.countInMetronome) {\r\n\t\t\t\tif (this.part == 0) {\r\n\t\t\t\t\tif (!this.startedMetronome) {\r\n\t\t\t\t\t\tconst midBeat: boolean = (song.beatsPerBar > 4 && (song.beatsPerBar % 2 == 0) && this.beat == song.beatsPerBar / 2);\r\n\t\t\t\t\t\tconst periods:   number = (this.beat == 0) ? 8 : midBeat ? 6 : 4;\r\n\t\t\t\t\t\tconst hz:        number = (this.beat == 0) ? 1600 : midBeat ? 1200 : 800;\r\n\t\t\t\t\t\tconst amplitude: number = (this.beat == 0) ? 0.06 : midBeat ? 0.05 : 0.04;\r\n\t\t\t\t\t\tconst samplesPerPeriod: number = this.samplesPerSecond / hz;\r\n\t\t\t\t\t\tconst radiansPerSample: number = Math.PI * 2.0 / samplesPerPeriod;\r\n\t\t\t\t\t\tthis.metronomeSamplesRemaining = Math.floor(samplesPerPeriod * periods);\r\n\t\t\t\t\t\tthis.metronomeFilter = 2.0 * Math.cos(radiansPerSample);\r\n\t\t\t\t\t\tthis.metronomeAmplitude = amplitude * Math.sin(radiansPerSample);\r\n\t\t\t\t\t\tthis.metronomePrevAmplitude = 0.0;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.startedMetronome = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.metronomeSamplesRemaining > 0) {\r\n\t\t\t\t\t\tconst stopIndex: number = Math.min(runEnd, bufferIndex + this.metronomeSamplesRemaining);\r\n\t\t\t\t\t\tthis.metronomeSamplesRemaining -= stopIndex - bufferIndex;\r\n\t\t\t\t\t\tfor (let i: number = bufferIndex; i < stopIndex; i++) {\r\n\t\t\t\t\t\t\toutputDataL[i] += this.metronomeAmplitude;\r\n\t\t\t\t\t\t\toutputDataR[i] += this.metronomeAmplitude;\r\n\t\t\t\t\t\t\tconst tempAmplitude: number = this.metronomeFilter * this.metronomeAmplitude - this.metronomePrevAmplitude;\r\n\t\t\t\t\t\t\tthis.metronomePrevAmplitude = this.metronomeAmplitude;\r\n\t\t\t\t\t\t\tthis.metronomeAmplitude = tempAmplitude;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.startedMetronome = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Post processing:\r\n\t\t\tfor (let i: number = bufferIndex; i < runEnd; i++) {\r\n\t\t\t\t// A compressor/limiter.\r\n\t\t\t\tconst sampleL = outputDataL[i];\r\n\t\t\t\tconst sampleR = outputDataR[i];\r\n\t\t\t\tconst abs: number = Math.max(Math.abs(sampleL), Math.abs(sampleR));\r\n\t\t\t\tlimit += (abs - limit) * (limit < abs ? limitRise : limitDecay * (1.0 + limit));\r\n\t\t\t\tconst limitedVolume = volume / (limit >= 1 ? limit * 1.05 : limit * 0.8 + 0.25);\r\n\t\t\t\toutputDataL[i] = sampleL * limitedVolume;\r\n\t\t\t\toutputDataR[i] = sampleR * limitedVolume;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tbufferIndex += runLength;\r\n\t\t\t\r\n\t\t\tthis.isAtStartOfTick = false;\r\n\t\t\tthis.tickSampleCountdown -= runLength;\r\n\t\t\tif (this.tickSampleCountdown <= 0) {\r\n\t\t\t\tthis.isAtStartOfTick = true;\r\n\t\t\t\t\r\n\t\t\t\t// Track how long tones have been released, and free ones that are marked as ending.\r\n\t\t\t\t// Also reset awake InstrumentStates that didn't have any Tones during this tick.\r\n\t\t\t\tfor (const channelState of this.channels) {\r\n\t\t\t\t\tfor (const instrumentState of channelState.instruments) {\r\n\t\t\t\t\t\tfor (let i: number = 0; i < instrumentState.releasedTones.count(); i++) {\r\n\t\t\t\t\t\t\tconst tone: Tone = instrumentState.releasedTones.get(i);\r\n\t\t\t\t\t\t\tif (tone.isOnLastTick) {\r\n\t\t\t\t\t\t\t\tthis.freeReleasedTone(instrumentState, i);\r\n\t\t\t\t\t\t\t\ti--;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\ttone.ticksSinceReleased++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (instrumentState.deactivateAfterThisTick) {\r\n\t\t\t\t\t\t\tinstrumentState.deactivate();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tinstrumentState.tonesAddedInThisTick = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tthis.tick++;\r\n\t\t\t\tthis.tickSampleCountdown += samplesPerTick;\r\n\t\t\t\tif (this.tick == Config.ticksPerPart) {\r\n\t\t\t\t\tthis.tick = 0;\r\n\t\t\t\t\tthis.part++;\r\n\t\t\t\t\tthis.liveInputDuration--;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (this.part == Config.partsPerBeat) {\r\n\t\t\t\t\t\tthis.part = 0;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (playSong) {\r\n\t\t\t\t\t\t\tthis.beat++;\r\n\t\t\t\t\t\t\tif (this.beat == song.beatsPerBar) {\r\n\t\t\t\t\t\t\t\t// bar changed, reset for next bar:\r\n\t\t\t\t\t\t\t\tthis.beat = 0;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (this.countInMetronome) {\r\n\t\t\t\t\t\t\t\t\tthis.countInMetronome = false;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tthis.prevBar = this.bar;\r\n\t\t\t\t\t\t\t\t\tthis.bar = this.getNextBar();\r\n\t\t\t\t\t\t\t\t\tif (this.bar <= this.prevBar && this.loopRepeatCount > 0) this.loopRepeatCount--;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif (this.bar >= song.barCount) {\r\n\t\t\t\t\t\t\t\t\t\tthis.bar = 0;\r\n\t\t\t\t\t\t\t\t\t\tif (this.loopRepeatCount != -1) {\r\n\t\t\t\t\t\t\t\t\t\t\tended = true;\r\n\t\t\t\t\t\t\t\t\t\t\tthis.resetEffects();\r\n\t\t\t\t\t\t\t\t\t\t\tthis.pause();\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Avoid persistent denormal or NaN values.\r\n\t\tif (!Number.isFinite(limit) || Math.abs(limit) < epsilon) limit = 0.0;\r\n\t\tthis.limit = limit;\r\n\t\t\r\n\t\tif (playSong && !this.countInMetronome) {\r\n\t\t\tthis.playheadInternal = (((this.tick + 1.0 - this.tickSampleCountdown / samplesPerTick) / 2.0 + this.part) / Config.partsPerBeat + this.beat) / song.beatsPerBar + this.bar;\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\tconst synthDuration: number = performance.now() - synthStartTime;\r\n\t\t// Performance measurements:\r\n\t\tsamplesAccumulated += outputBufferLength;\r\n\t\tsamplePerformance += synthDuration;\r\n\t\t\r\n\t\tif (samplesAccumulated >= 44100 * 4) {\r\n\t\t\tconst secondsGenerated = samplesAccumulated / 44100;\r\n\t\t\tconst secondsRequired = samplePerformance / 1000;\r\n\t\t\tconst ratio = secondsRequired / secondsGenerated;\r\n\t\t\tconsole.log(ratio);\r\n\t\t\tsamplePerformance = 0;\r\n\t\t\tsamplesAccumulated = 0;\r\n\t\t}\r\n\t\t*/\r\n\t}\r\n\t\r\n\tprivate freeTone(tone: Tone): void {\r\n\t\tthis.tonePool.pushBack(tone);\r\n\t}\r\n\t\r\n\tprivate newTone(): Tone {\r\n\t\tif (this.tonePool.count() > 0) {\r\n\t\t\tconst tone: Tone = this.tonePool.popBack();\r\n\t\t\ttone.freshlyAllocated = true;\r\n\t\t\treturn tone;\r\n\t\t}\r\n\t\treturn new Tone();\r\n\t}\r\n\t\r\n\tprivate releaseTone(instrumentState: InstrumentState, tone: Tone): void {\r\n\t\tinstrumentState.releasedTones.pushFront(tone);\r\n\t\ttone.atNoteStart = false;\r\n\t\ttone.passedEndOfNote = true;\r\n\t}\r\n\t\r\n\tprivate freeReleasedTone(instrumentState: InstrumentState, toneIndex: number): void {\r\n\t\tthis.freeTone(instrumentState.releasedTones.get(toneIndex));\r\n\t\tinstrumentState.releasedTones.remove(toneIndex);\r\n\t}\r\n\t\r\n\tpublic freeAllTones(): void {\r\n\t\tfor (const channelState of this.channels) {\r\n\t\t\tfor (const instrumentState of channelState.instruments) {\r\n\t\t\t\twhile (instrumentState.activeTones.count()    > 0) this.freeTone(instrumentState.activeTones.popBack());\r\n\t\t\t\twhile (instrumentState.releasedTones.count()  > 0) this.freeTone(instrumentState.releasedTones.popBack());\r\n\t\t\t\twhile (instrumentState.liveInputTones.count() > 0) this.freeTone(instrumentState.liveInputTones.popBack());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate determineLiveInputTones(song: Song, channelIndex: number, samplesPerTick: number): void {\r\n\t\tconst channel: Channel = song.channels[channelIndex];\r\n\t\tconst channelState: ChannelState = this.channels[channelIndex];\r\n\t\tconst pitches: number[] = this.liveInputPitches;\r\n\t\t\r\n\t\tfor (let instrumentIndex: number = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {\r\n\t\t\tconst instrumentState: InstrumentState = channelState.instruments[instrumentIndex];\r\n\t\t\tconst toneList: Deque<Tone> = instrumentState.liveInputTones;\r\n\t\t\tlet toneCount: number = 0;\r\n\t\t\tif (this.liveInputDuration > 0 && channelIndex == this.liveInputChannel && pitches.length > 0 && this.liveInputInstruments.indexOf(instrumentIndex) != -1) {\r\n\t\t\t\tconst instrument: Instrument = channel.instruments[instrumentIndex];\r\n\t\t\t\t\r\n\t\t\t\tif (instrument.getChord().singleTone) {\r\n\t\t\t\t\tlet tone: Tone;\r\n\t\t\t\t\tif (toneList.count() <= toneCount) {\r\n\t\t\t\t\t\ttone = this.newTone();\r\n\t\t\t\t\t\ttoneList.pushBack(tone);\r\n\t\t\t\t\t} else if (!instrument.getTransition().isSeamless && this.liveInputStarted) {\r\n\t\t\t\t\t\tthis.releaseTone(instrumentState, toneList.get(toneCount));\r\n\t\t\t\t\t\ttone = this.newTone();\r\n\t\t\t\t\t\ttoneList.set(toneCount, tone);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttone = toneList.get(toneCount);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoneCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (let i: number = 0; i < pitches.length; i++) {\r\n\t\t\t\t\t\ttone.pitches[i] = pitches[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttone.pitchCount = pitches.length;\r\n\t\t\t\t\ttone.chordSize = 1;\r\n\t\t\t\t\ttone.instrumentIndex = instrumentIndex;\r\n\t\t\t\t\ttone.note = tone.prevNote = tone.nextNote = null;\r\n\t\t\t\t\ttone.atNoteStart = this.liveInputStarted;\r\n\t\t\t\t\ttone.forceContinueAtStart = false;\r\n\t\t\t\t\ttone.forceContinueAtEnd = false;\r\n\t\t\t\t\tthis.computeTone(song, channelIndex, samplesPerTick, tone, false, false);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//const transition: Transition = instrument.getTransition();\r\n\t\t\t\t\t\r\n\t\t\t\t\tthis.moveTonesIntoOrderedTempMatchedList(toneList, pitches);\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (let i: number = 0; i < pitches.length; i++) {\r\n\t\t\t\t\t\t//const strumOffsetParts: number = i * instrument.getChord().strumParts;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet tone: Tone;\r\n\t\t\t\t\t\tif (this.tempMatchedPitchTones[toneCount] != null) {\r\n\t\t\t\t\t\t\ttone = this.tempMatchedPitchTones[toneCount]!;\r\n\t\t\t\t\t\t\tthis.tempMatchedPitchTones[toneCount] = null;\r\n\t\t\t\t\t\t\tif (tone.pitchCount != 1 || tone.pitches[0] != pitches[i]) {\r\n\t\t\t\t\t\t\t\tthis.releaseTone(instrumentState, tone);\r\n\t\t\t\t\t\t\t\ttone = this.newTone();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttoneList.pushBack(tone);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttone = this.newTone();\r\n\t\t\t\t\t\t\ttoneList.pushBack(tone);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoneCount++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\ttone.pitches[0] = pitches[i];\r\n\t\t\t\t\t\ttone.pitchCount = 1;\r\n\t\t\t\t\t\ttone.chordSize = pitches.length;\r\n\t\t\t\t\t\ttone.instrumentIndex = instrumentIndex;\r\n\t\t\t\t\t\ttone.note = tone.prevNote = tone.nextNote = null;\r\n\t\t\t\t\t\ttone.atNoteStart = this.liveInputStarted;\r\n\t\t\t\t\t\ttone.forceContinueAtStart = false;\r\n\t\t\t\t\t\ttone.forceContinueAtEnd = false;\r\n\t\t\t\t\t\tthis.computeTone(song, channelIndex, samplesPerTick, tone, false, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\twhile (toneList.count() > toneCount) {\r\n\t\t\t\tthis.releaseTone(instrumentState, toneList.popBack());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.clearTempMatchedPitchTones(toneCount, instrumentState);\r\n\t\t}\r\n\t\t\r\n\t\tthis.liveInputStarted = false;\r\n\t}\r\n\t\r\n\t// Returns the chord type of the instrument in the adjacent pattern if it is compatible for a\r\n\t// seamless transition across patterns, otherwise returns null.\r\n\tprivate adjacentPatternHasCompatibleInstrumentTransition(song: Song, channel: Channel, pattern: Pattern, otherPattern: Pattern, instrumentIndex: number, transition: Transition, chord: Chord, note: Note, otherNote: Note, forceContinue: boolean): Chord | null {\r\n\t\tif (song.patternInstruments && otherPattern.instruments.indexOf(instrumentIndex) == -1) {\r\n\t\t\t// The adjacent pattern does not contain the same instrument as the current pattern.\r\n\t\t\t\r\n\t\t\tif (pattern.instruments.length > 1 || otherPattern.instruments.length > 1) {\r\n\t\t\t\t// The current or adjacent pattern contains more than one instrument, don't bother\r\n\t\t\t\t// trying to connect them.\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t// Otherwise, the two patterns each contain one instrument, but not the same instrument.\r\n\t\t\t// Try to connect them.\r\n\t\t\tconst otherInstrument: Instrument = channel.instruments[otherPattern.instruments[0]];\r\n\t\t\t\r\n\t\t\tif (forceContinue) {\r\n\t\t\t\t// Even non-seamless instruments can be connected across patterns if forced.\r\n\t\t\t\treturn otherInstrument.getChord();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Otherwise, check that both instruments are seamless across patterns.\r\n\t\t\tconst otherTransition: Transition = otherInstrument.getTransition();\r\n\t\t\tif (transition.includeAdjacentPatterns && otherTransition.includeAdjacentPatterns && otherTransition.slides == transition.slides) {\r\n\t\t\t\treturn otherInstrument.getChord();\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// If both patterns contain the same instrument, check that it is seamless across patterns.\r\n\t\t\treturn (forceContinue || transition.includeAdjacentPatterns) ? chord : null;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static adjacentNotesHaveMatchingPitches(firstNote: Note, secondNote: Note): boolean {\r\n\t\tif (firstNote.pitches.length != secondNote.pitches.length) return false;\r\n\t\tconst firstNoteInterval: number = firstNote.pins[firstNote.pins.length - 1].interval;\r\n\t\tfor (const pitch of firstNote.pitches) {\r\n\t\t\tif (secondNote.pitches.indexOf(pitch + firstNoteInterval) == -1) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprivate moveTonesIntoOrderedTempMatchedList(toneList: Deque<Tone>, notePitches: number[]): void {\r\n\t\t// The tones are about to seamlessly transition to a new note. The pitches\r\n\t\t// from the old note may or may not match any of the pitches in the new\r\n\t\t// note, and not necessarily in order, but if any do match, they'll sound\r\n\t\t// better if those tones continue to have the same pitch. Attempt to find\r\n\t\t// the right spot for each old tone in the new chord if possible.\r\n\t\t\r\n\t\tfor (let i: number = 0; i < toneList.count(); i++) {\r\n\t\t\tconst tone: Tone = toneList.get(i);\r\n\t\t\tconst pitch: number = tone.pitches[0] + tone.lastInterval;\r\n\t\t\tfor (let j: number = 0; j < notePitches.length; j++) {\r\n\t\t\t\tif (notePitches[j] == pitch) {\r\n\t\t\t\t\tthis.tempMatchedPitchTones[j] = tone;\r\n\t\t\t\t\ttoneList.remove(i);\r\n\t\t\t\t\ti--;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Any tones that didn't get matched should just fill in the gaps.\r\n\t\twhile (toneList.count() > 0) {\r\n\t\t\tconst tone: Tone = toneList.popFront();\r\n\t\t\tfor (let j: number = 0; j < this.tempMatchedPitchTones.length; j++) {\r\n\t\t\t\tif (this.tempMatchedPitchTones[j] == null) {\r\n\t\t\t\t\tthis.tempMatchedPitchTones[j] = tone;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate determineCurrentActiveTones(song: Song, channelIndex: number, samplesPerTick: number, playSong: boolean): void {\r\n\t\tconst channel: Channel = song.channels[channelIndex];\r\n\t\tconst channelState: ChannelState = this.channels[channelIndex];\r\n\t\tconst pattern: Pattern | null = song.getPattern(channelIndex, this.bar);\r\n\t\tconst currentPart: number = this.getCurrentPart();\r\n\t\tconst currentTick: number = this.tick + Config.ticksPerPart * currentPart;\r\n\t\tlet note: Note | null = null;\r\n\t\tlet prevNote: Note | null = null;\r\n\t\tlet nextNote: Note | null = null;\r\n\t\t\r\n\t\tif (playSong && pattern != null && !channel.muted && (!this.isRecording || this.liveInputChannel != channelIndex)) {\r\n\t\t\tfor (let i: number = 0; i < pattern.notes.length; i++) {\r\n\t\t\t\tif (pattern.notes[i].end <= currentPart) {\r\n\t\t\t\t\tprevNote = pattern.notes[i];\r\n\t\t\t\t} else if (pattern.notes[i].start <= currentPart && pattern.notes[i].end > currentPart) {\r\n\t\t\t\t\tnote = pattern.notes[i];\r\n\t\t\t\t} else if (pattern.notes[i].start > currentPart) {\r\n\t\t\t\t\tnextNote = pattern.notes[i];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (note != null) {\r\n\t\t\t\tif (prevNote != null && prevNote.end != note.start) prevNote = null;\r\n\t\t\t\tif (nextNote != null && nextNote.start != note.end) nextNote = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Seamless tones from a pattern with a single instrument can be transferred to a different single seamless instrument in the next pattern.\r\n\t\tif (pattern != null && (!song.layeredInstruments || channel.instruments.length == 1 || (song.patternInstruments && pattern.instruments.length == 1))) {\r\n\t\t\tconst newInstrumentIndex: number = song.patternInstruments ? pattern.instruments[0] : 0;\r\n\t\t\tif (channelState.singleSeamlessInstrument != null && channelState.singleSeamlessInstrument != newInstrumentIndex && channelState.singleSeamlessInstrument < channelState.instruments.length) {\r\n\t\t\t\tconst sourceInstrumentState: InstrumentState = channelState.instruments[channelState.singleSeamlessInstrument];\r\n\t\t\t\tconst destInstrumentState: InstrumentState = channelState.instruments[newInstrumentIndex];\r\n\t\t\t\twhile (sourceInstrumentState.activeTones.count() > 0) {\r\n\t\t\t\t\tdestInstrumentState.activeTones.pushFront(sourceInstrumentState.activeTones.popBack());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tchannelState.singleSeamlessInstrument = newInstrumentIndex;\r\n\t\t} else {\r\n\t\t\tchannelState.singleSeamlessInstrument = null;\r\n\t\t}\r\n\t\t\r\n\t\tfor (let instrumentIndex: number = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {\r\n\t\t\tconst instrumentState: InstrumentState = channelState.instruments[instrumentIndex];\r\n\t\t\tconst toneList: Deque<Tone> = instrumentState.activeTones;\r\n\t\t\tlet toneCount: number = 0;\r\n\t\t\tif ((note != null) && (!song.patternInstruments || (pattern!.instruments.indexOf(instrumentIndex) != -1))) {\r\n\t\t\t\tconst instrument: Instrument = channel.instruments[instrumentIndex];\r\n\t\t\t\tlet prevNoteForThisInstrument: Note | null = prevNote;\r\n\t\t\t\tlet nextNoteForThisInstrument: Note | null = nextNote;\r\n\t\t\t\t\r\n\t\t\t\tconst partsPerBar: Number = Config.partsPerBeat * song.beatsPerBar;\r\n\t\t\t\tconst transition: Transition = instrument.getTransition();\r\n\t\t\t\tconst chord: Chord = instrument.getChord();\r\n\t\t\t\tlet forceContinueAtStart: boolean = false;\r\n\t\t\t\tlet forceContinueAtEnd: boolean = false;\r\n\t\t\t\tlet tonesInPrevNote: number = 0;\r\n\t\t\t\tlet tonesInNextNote: number = 0;\r\n\t\t\t\tif (note.start == 0) {\r\n\t\t\t\t\t// If the beginning of the note coincides with the beginning of the pattern,\r\n\t\t\t\t\t// look for an adjacent note at the end of the previous pattern.\r\n\t\t\t\t\tlet prevPattern: Pattern | null = (this.prevBar == null) ? null : song.getPattern(channelIndex, this.prevBar);\r\n\t\t\t\t\tif (prevPattern != null) {\r\n\t\t\t\t\t\tconst lastNote: Note | null = (prevPattern.notes.length <= 0) ? null : prevPattern.notes[prevPattern.notes.length - 1];\r\n\t\t\t\t\t\tif (lastNote != null && lastNote.end == partsPerBar) {\r\n\t\t\t\t\t\t\tconst patternForcesContinueAtStart: boolean = note.continuesLastPattern && Synth.adjacentNotesHaveMatchingPitches(lastNote, note);\r\n\t\t\t\t\t\t\tconst chordOfCompatibleInstrument: Chord | null = this.adjacentPatternHasCompatibleInstrumentTransition(song, channel, pattern!, prevPattern, instrumentIndex, transition, chord, note, lastNote, patternForcesContinueAtStart);\r\n\t\t\t\t\t\t\tif (chordOfCompatibleInstrument != null) {\r\n\t\t\t\t\t\t\t\tprevNoteForThisInstrument = lastNote;\r\n\t\t\t\t\t\t\t\ttonesInPrevNote = chordOfCompatibleInstrument.singleTone ? 1 : prevNoteForThisInstrument.pitches.length\r\n\t\t\t\t\t\t\t\tforceContinueAtStart = patternForcesContinueAtStart;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (prevNoteForThisInstrument != null) {\r\n\t\t\t\t\ttonesInPrevNote = chord.singleTone ? 1 : prevNoteForThisInstrument.pitches.length\r\n\t\t\t\t}\r\n\t\t\t\tif (note.end == partsPerBar) {\r\n\t\t\t\t\t// If the end of the note coincides with the end of the pattern, look for an\r\n\t\t\t\t\t// adjacent note at the beginning of the next pattern.\r\n\t\t\t\t\tlet nextPattern: Pattern | null = (this.nextBar == null) ? null : song.getPattern(channelIndex, this.nextBar);\r\n\t\t\t\t\tif (nextPattern != null) {\r\n\t\t\t\t\t\tconst firstNote: Note | null = (nextPattern.notes.length <= 0) ? null : nextPattern.notes[0];\r\n\t\t\t\t\t\tif (firstNote != null && firstNote.start == 0) {\r\n\t\t\t\t\t\t\tconst nextPatternForcesContinueAtStart: boolean = firstNote.continuesLastPattern && Synth.adjacentNotesHaveMatchingPitches(note, firstNote);\r\n\t\t\t\t\t\t\tconst chordOfCompatibleInstrument: Chord | null = this.adjacentPatternHasCompatibleInstrumentTransition(song, channel, pattern!, nextPattern, instrumentIndex, transition, chord, note, firstNote, nextPatternForcesContinueAtStart);\r\n\t\t\t\t\t\t\tif (chordOfCompatibleInstrument != null) {\r\n\t\t\t\t\t\t\t\tnextNoteForThisInstrument = firstNote;\r\n\t\t\t\t\t\t\t\ttonesInNextNote = chordOfCompatibleInstrument.singleTone ? 1 : nextNoteForThisInstrument.pitches.length\r\n\t\t\t\t\t\t\t\tforceContinueAtEnd = nextPatternForcesContinueAtStart;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (nextNoteForThisInstrument != null) {\r\n\t\t\t\t\ttonesInNextNote = chord.singleTone ? 1 : nextNoteForThisInstrument.pitches.length\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (chord.singleTone) {\r\n\t\t\t\t\tconst atNoteStart: boolean = (Config.ticksPerPart * note.start == currentTick);\r\n\t\t\t\t\tlet tone: Tone;\r\n\t\t\t\t\tif (toneList.count() <= toneCount) {\r\n\t\t\t\t\t\ttone = this.newTone();\r\n\t\t\t\t\t\ttoneList.pushBack(tone);\r\n\t\t\t\t\t} else if (atNoteStart && ((!transition.isSeamless && !forceContinueAtStart) || prevNoteForThisInstrument == null)) {\r\n\t\t\t\t\t\tconst oldTone: Tone = toneList.get(toneCount);\r\n\t\t\t\t\t\tif (oldTone.isOnLastTick) {\r\n\t\t\t\t\t\t\tthis.freeTone(oldTone);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.releaseTone(instrumentState, oldTone);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttone = this.newTone();\r\n\t\t\t\t\t\ttoneList.set(toneCount, tone);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttone = toneList.get(toneCount);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoneCount++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (let i: number = 0; i < note.pitches.length; i++) {\r\n\t\t\t\t\t\ttone.pitches[i] = note.pitches[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttone.pitchCount = note.pitches.length;\r\n\t\t\t\t\ttone.chordSize = 1;\r\n\t\t\t\t\ttone.instrumentIndex = instrumentIndex;\r\n\t\t\t\t\ttone.note = note;\r\n\t\t\t\t\ttone.noteStartPart = note.start;\r\n\t\t\t\t\ttone.noteEndPart = note.end;\r\n\t\t\t\t\ttone.prevNote = prevNoteForThisInstrument;\r\n\t\t\t\t\ttone.nextNote = nextNoteForThisInstrument;\r\n\t\t\t\t\ttone.prevNotePitchIndex = 0;\r\n\t\t\t\t\ttone.nextNotePitchIndex = 0;\r\n\t\t\t\t\ttone.atNoteStart = atNoteStart;\r\n\t\t\t\t\ttone.passedEndOfNote = false;\r\n\t\t\t\t\ttone.forceContinueAtStart = forceContinueAtStart;\r\n\t\t\t\t\ttone.forceContinueAtEnd = forceContinueAtEnd;\r\n\t\t\t\t\tthis.computeTone(song, channelIndex, samplesPerTick, tone, false, false);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst transition: Transition = instrument.getTransition();\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (((transition.isSeamless && !transition.slides && chord.strumParts == 0) || forceContinueAtStart) && (Config.ticksPerPart * note.start == currentTick) && prevNoteForThisInstrument != null) {\r\n\t\t\t\t\t\tthis.moveTonesIntoOrderedTempMatchedList(toneList, note.pitches);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tlet strumOffsetParts: number = 0;\r\n\t\t\t\t\tfor (let i: number = 0; i < note.pitches.length; i++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet prevNoteForThisTone: Note | null = (tonesInPrevNote > i) ? prevNoteForThisInstrument : null;\r\n\t\t\t\t\t\tlet noteForThisTone: Note = note;\r\n\t\t\t\t\t\tlet nextNoteForThisTone: Note | null = (tonesInNextNote > i) ? nextNoteForThisInstrument : null;\r\n\t\t\t\t\t\tlet noteStartPart: number = noteForThisTone.start + strumOffsetParts;\r\n\t\t\t\t\t\tlet passedEndOfNote: boolean = false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Strumming may mean that a note's actual start time may be after the\r\n\t\t\t\t\t\t// note's displayed start time. If the note start hasn't been reached yet,\r\n\t\t\t\t\t\t// carry over the previous tone if available and seamless, otherwise skip\r\n\t\t\t\t\t\t// the new tone until it is ready to start.\r\n\t\t\t\t\t\tif (noteStartPart > currentPart) {\r\n\t\t\t\t\t\t\tif (toneList.count() > i && (transition.isSeamless || forceContinueAtStart) && prevNoteForThisTone != null) {\r\n\t\t\t\t\t\t\t\t// Continue the previous note's chord until the current one takes over.\r\n\t\t\t\t\t\t\t\tnextNoteForThisTone = noteForThisTone;\r\n\t\t\t\t\t\t\t\tnoteForThisTone = prevNoteForThisTone;\r\n\t\t\t\t\t\t\t\tprevNoteForThisTone = null;\r\n\t\t\t\t\t\t\t\tnoteStartPart = noteForThisTone.start + strumOffsetParts;\r\n\t\t\t\t\t\t\t\tpassedEndOfNote = true;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// This and the rest of the tones in the chord shouldn't start yet.\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet noteEndPart: number = noteForThisTone.end;\r\n\t\t\t\t\t\tif ((transition.isSeamless || forceContinueAtStart) && nextNoteForThisTone != null) {\r\n\t\t\t\t\t\t\tnoteEndPart = Math.min(Config.partsPerBeat * this.song!.beatsPerBar, noteEndPart + strumOffsetParts);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ((!transition.continues && !forceContinueAtStart) || prevNoteForThisTone == null) {\r\n\t\t\t\t\t\t\tstrumOffsetParts += chord.strumParts;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tconst atNoteStart: boolean = (Config.ticksPerPart * noteStartPart == currentTick);\r\n\t\t\t\t\t\tlet tone: Tone;\r\n\t\t\t\t\t\tif (this.tempMatchedPitchTones[toneCount] != null) {\r\n\t\t\t\t\t\t\ttone = this.tempMatchedPitchTones[toneCount]!;\r\n\t\t\t\t\t\t\tthis.tempMatchedPitchTones[toneCount] = null;\r\n\t\t\t\t\t\t\ttoneList.pushBack(tone);\r\n\t\t\t\t\t\t} else if (toneList.count() <= toneCount) {\r\n\t\t\t\t\t\t\ttone = this.newTone();\r\n\t\t\t\t\t\t\ttoneList.pushBack(tone);\r\n\t\t\t\t\t\t} else if (atNoteStart && ((!transition.isSeamless && !forceContinueAtStart) || prevNoteForThisTone == null)) {\r\n\t\t\t\t\t\t\tconst oldTone: Tone = toneList.get(toneCount);\r\n\t\t\t\t\t\t\tif (oldTone.isOnLastTick) {\r\n\t\t\t\t\t\t\t\tthis.freeTone(oldTone);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.releaseTone(instrumentState, oldTone);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttone = this.newTone();\r\n\t\t\t\t\t\t\ttoneList.set(toneCount, tone);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttone = toneList.get(toneCount);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoneCount++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\ttone.pitches[0] = noteForThisTone.pitches[i];\r\n\t\t\t\t\t\ttone.pitchCount = 1;\r\n\t\t\t\t\t\ttone.chordSize = noteForThisTone.pitches.length;\r\n\t\t\t\t\t\ttone.instrumentIndex = instrumentIndex;\r\n\t\t\t\t\t\ttone.note = noteForThisTone;\r\n\t\t\t\t\t\ttone.noteStartPart = noteStartPart;\r\n\t\t\t\t\t\ttone.noteEndPart = noteEndPart;\r\n\t\t\t\t\t\ttone.prevNote = prevNoteForThisTone;\r\n\t\t\t\t\t\ttone.nextNote = nextNoteForThisTone;\r\n\t\t\t\t\t\ttone.prevNotePitchIndex = i;\r\n\t\t\t\t\t\ttone.nextNotePitchIndex = i;\r\n\t\t\t\t\t\ttone.atNoteStart = atNoteStart;\r\n\t\t\t\t\t\ttone.passedEndOfNote = passedEndOfNote;\r\n\t\t\t\t\t\ttone.forceContinueAtStart = forceContinueAtStart && prevNoteForThisTone != null;\r\n\t\t\t\t\t\ttone.forceContinueAtEnd = forceContinueAtEnd && nextNoteForThisTone != null;\r\n\t\t\t\t\t\tthis.computeTone(song, channelIndex, samplesPerTick, tone, false, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Automatically free or release seamless tones if there's no new note to take over.\r\n\t\t\twhile (toneList.count() > toneCount) {\r\n\t\t\t\tconst tone: Tone = toneList.popBack();\r\n\t\t\t\tconst channel: Channel = song.channels[channelIndex];\r\n\t\t\t\tif (tone.instrumentIndex < channel.instruments.length && !tone.isOnLastTick) {\r\n\t\t\t\t\tconst instrumentState: InstrumentState = channelState.instruments[tone.instrumentIndex];\r\n\t\t\t\t\tthis.releaseTone(instrumentState, tone);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.freeTone(tone);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.clearTempMatchedPitchTones(toneCount, instrumentState);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate clearTempMatchedPitchTones(toneCount: number, instrumentState: InstrumentState): void {\r\n\t\tfor (let i: number = toneCount; i < this.tempMatchedPitchTones.length; i++) {\r\n\t\t\tconst oldTone: Tone | null = this.tempMatchedPitchTones[i];\r\n\t\t\tif (oldTone != null) {\r\n\t\t\t\tif (oldTone.isOnLastTick) {\r\n\t\t\t\t\tthis.freeTone(oldTone);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.releaseTone(instrumentState, oldTone);\r\n\t\t\t\t}\r\n\t\t\t\tthis.tempMatchedPitchTones[i] = null;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate playTone(channelIndex: number, bufferIndex: number, runLength: number, tone: Tone): void {\r\n\t\tconst channelState: ChannelState = this.channels[channelIndex];\r\n\t\tconst instrumentState: InstrumentState = channelState.instruments[tone.instrumentIndex];\r\n\t\t\r\n\t\tinstrumentState.synthesizer!(this, bufferIndex, runLength, tone, instrumentState);\r\n\t\ttone.envelopeComputer.clearEnvelopes();\r\n\t}\r\n\t\r\n\tprivate static computeChordExpression(chordSize: number): number {\r\n\t\treturn 1.0 / ((chordSize - 1) * 0.25 + 1.0);\r\n\t}\r\n\t\r\n\tprivate computeTone(song: Song, channelIndex: number, samplesPerTick: number, tone: Tone, released: boolean, shouldFadeOutFast: boolean): void {\r\n\t\tconst roundedSamplesPerTick: number = Math.ceil(samplesPerTick);\r\n\t\tconst channel: Channel = song.channels[channelIndex];\r\n\t\tconst channelState: ChannelState = this.channels[channelIndex];\r\n\t\tconst instrument: Instrument = channel.instruments[tone.instrumentIndex];\r\n\t\tconst instrumentState: InstrumentState = channelState.instruments[tone.instrumentIndex];\r\n\t\tinstrumentState.awake = true;\r\n\t\tinstrumentState.tonesAddedInThisTick = true;\r\n\t\tif (!instrumentState.computed) {\r\n\t\t\tinstrumentState.compute(this, instrument, samplesPerTick, roundedSamplesPerTick, tone);\r\n\t\t}\r\n\t\tconst isNoiseChannel: boolean = song.getChannelIsNoise(channelIndex);\r\n\t\tconst transition: Transition = instrument.getTransition();\r\n\t\tconst chord: Chord = instrument.getChord();\r\n\t\tconst chordExpression: number = chord.singleTone ? 1.0 : Synth.computeChordExpression(tone.chordSize);\r\n\t\tconst intervalScale: number = isNoiseChannel ? Config.noiseInterval : 1;\r\n\t\tconst secondsPerPart: number = Config.ticksPerPart * samplesPerTick / this.samplesPerSecond;\r\n\t\tconst sampleTime: number = 1.0 / this.samplesPerSecond;\r\n\t\tconst beatsPerPart: number = 1.0 / Config.partsPerBeat;\r\n\t\tconst ticksIntoBar: number = this.getTicksIntoBar();\r\n\t\tconst partTimeStart: number = (ticksIntoBar      ) / Config.ticksPerPart;\r\n\t\tconst partTimeEnd: number   = (ticksIntoBar + 1.0) / Config.ticksPerPart;\r\n\t\tconst currentPart: number = this.getCurrentPart();\r\n\t\t\r\n\t\tlet specialIntervalMult: number = 1.0;\r\n\t\ttone.specialIntervalExpressionMult = 1.0;\r\n\t\t\r\n\t\tlet toneIsOnLastTick: boolean = shouldFadeOutFast;\r\n\t\tlet intervalStart: number = 0.0;\r\n\t\tlet intervalEnd: number = 0.0;\r\n\t\tlet fadeExpressionStart: number = 1.0;\r\n\t\tlet fadeExpressionEnd: number = 1.0;\r\n\t\tlet chordExpressionStart: number = chordExpression;\r\n\t\tlet chordExpressionEnd:   number = chordExpression;\r\n\t\t\r\n\t\tlet expressionReferencePitch: number = 16; // A low \"E\" as a MIDI pitch.\r\n\t\tlet basePitch: number = Config.keys[song.key].basePitch;\r\n\t\tlet baseExpression: number = 1.0;\r\n\t\tlet pitchDamping: number = 48;\r\n\t\tif (instrument.type == InstrumentType.spectrum) {\r\n\t\t\tbaseExpression = Config.spectrumBaseExpression;\r\n\t\t\tif (isNoiseChannel) {\r\n\t\t\t\tbasePitch = Config.spectrumBasePitch;\r\n\t\t\t\tbaseExpression *= 2.0; // Note: spectrum is louder for drum channels than pitch channels!\r\n\t\t\t}\r\n\t\t\texpressionReferencePitch = Config.spectrumBasePitch;\r\n\t\t\tpitchDamping = 28;\r\n\t\t} else if (instrument.type == InstrumentType.drumset) {\r\n\t\t\tbasePitch = Config.spectrumBasePitch;\r\n\t\t\tbaseExpression = Config.drumsetBaseExpression;\r\n\t\t\texpressionReferencePitch = basePitch;\r\n\t\t} else if (instrument.type == InstrumentType.noise) {\r\n\t\t\tbasePitch = Config.chipNoises[instrument.chipNoise].basePitch;\r\n\t\t\tbaseExpression = Config.noiseBaseExpression;\r\n\t\t\texpressionReferencePitch = basePitch;\r\n\t\t\tpitchDamping = Config.chipNoises[instrument.chipNoise].isSoft ? 24.0 : 60.0;\r\n\t\t} else if (instrument.type == InstrumentType.fm) {\r\n\t\t\tbaseExpression = Config.fmBaseExpression;\r\n\t\t} else if (instrument.type == InstrumentType.chip) {\r\n\t\t\tbaseExpression = Config.chipBaseExpression;\r\n\t\t} else if (instrument.type == InstrumentType.harmonics) {\r\n\t\t\tbaseExpression = Config.harmonicsBaseExpression;\r\n\t\t} else if (instrument.type == InstrumentType.pwm) {\r\n\t\t\tbaseExpression = Config.pwmBaseExpression;\r\n\t\t} else if (instrument.type == InstrumentType.supersaw) {\r\n\t\t\tbaseExpression = Config.supersawBaseExpression;\r\n\t\t} else if (instrument.type == InstrumentType.pickedString) {\r\n\t\t\tbaseExpression = Config.pickedStringBaseExpression;\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Unknown instrument type in computeTone.\");\r\n\t\t}\r\n\t\t\r\n\t\tif ((tone.atNoteStart && !transition.isSeamless && !tone.forceContinueAtStart) || tone.freshlyAllocated) {\r\n\t\t\ttone.reset();\r\n\t\t}\r\n\t\ttone.freshlyAllocated = false;\r\n\t\t\r\n\t\tfor (let i: number = 0; i < Config.maxPitchOrOperatorCount; i++) {\r\n\t\t\ttone.phaseDeltas[i] = 0.0;\r\n\t\t\ttone.phaseDeltaScales[i] = 0.0;\r\n\t\t\ttone.operatorExpressions[i]      = 0.0;\r\n\t\t\ttone.operatorExpressionDeltas[i] = 0.0;\r\n\t\t}\r\n\t\ttone.expression = 0.0;\r\n\t\ttone.expressionDelta = 0.0;\r\n\r\n\t\tif (released) {\r\n\t\t\tconst startTicksSinceReleased: number = tone.ticksSinceReleased;\r\n\t\t\tconst endTicksSinceReleased:   number = tone.ticksSinceReleased + 1.0;\r\n\t\t\tintervalStart = intervalEnd = tone.lastInterval;\r\n\t\t\tconst fadeOutTicks: number = Math.abs(instrument.getFadeOutTicks());\r\n\t\t\tfadeExpressionStart = Synth.noteSizeToVolumeMult((1.0 - startTicksSinceReleased / fadeOutTicks) * Config.noteSizeMax);\r\n\t\t\tfadeExpressionEnd   = Synth.noteSizeToVolumeMult((1.0 - endTicksSinceReleased / fadeOutTicks) * Config.noteSizeMax);\r\n\t\t\t\r\n\t\t\tif (shouldFadeOutFast) {\r\n\t\t\t\tfadeExpressionEnd = 0.0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (tone.ticksSinceReleased + 1 >= fadeOutTicks) toneIsOnLastTick = true;\r\n\t\t} else if (tone.note == null) {\r\n\t\t\tfadeExpressionStart = fadeExpressionEnd = 1.0;\r\n\t\t\ttone.lastInterval = 0;\r\n\t\t\ttone.ticksSinceReleased = 0;\r\n\t\t\ttone.liveInputSamplesHeld += roundedSamplesPerTick;\r\n\t\t} else {\r\n\t\t\tconst note: Note = tone.note;\r\n\t\t\tconst nextNote: Note | null = tone.nextNote;\r\n\r\n\t\t\tconst noteStartPart: number = tone.noteStartPart;\r\n\t\t\tconst noteEndPart: number = tone.noteEndPart;\r\n\t\t\t\r\n\t\t\tconst endPinIndex: number = note.getEndPinIndex(currentPart);\r\n\t\t\tconst startPin: NotePin = note.pins[endPinIndex-1];\r\n\t\t\tconst endPin: NotePin = note.pins[endPinIndex];\r\n\t\t\tconst noteStartTick: number = noteStartPart * Config.ticksPerPart;\r\n\t\t\tconst noteEndTick:   number = noteEndPart   * Config.ticksPerPart;\r\n\t\t\tconst pinStart: number  = (note.start + startPin.time) * Config.ticksPerPart;\r\n\t\t\tconst pinEnd:   number  = (note.start +   endPin.time) * Config.ticksPerPart;\r\n\t\t\t\r\n\t\t\ttone.ticksSinceReleased = 0;\r\n\t\t\t\r\n\t\t\tconst tickTimeStart: number = currentPart * Config.ticksPerPart + this.tick;\r\n\t\t\tconst tickTimeEnd:   number = tickTimeStart + 1.0;\r\n\t\t\tconst noteTicksPassedTickStart: number = tickTimeStart - noteStartTick;\r\n\t\t\tconst noteTicksPassedTickEnd:   number = tickTimeEnd - noteStartTick;\r\n\t\t\tconst pinRatioStart: number = Math.min(1.0, (tickTimeStart - pinStart) / (pinEnd - pinStart));\r\n\t\t\tconst pinRatioEnd:   number = Math.min(1.0, (tickTimeEnd   - pinStart) / (pinEnd - pinStart));\r\n\t\t\tfadeExpressionStart = 1.0;\r\n\t\t\tfadeExpressionEnd   = 1.0;\r\n\t\t\tintervalStart = startPin.interval + (endPin.interval - startPin.interval) * pinRatioStart;\r\n\t\t\tintervalEnd   = startPin.interval + (endPin.interval - startPin.interval) * pinRatioEnd;\r\n\t\t\ttone.lastInterval = intervalEnd;\r\n\t\t\t\r\n\t\t\tif ((!transition.isSeamless && !tone.forceContinueAtEnd) || nextNote == null) {\r\n\t\t\t\tconst fadeOutTicks: number = -instrument.getFadeOutTicks();\r\n\t\t\t\tif (fadeOutTicks > 0.0) {\r\n\t\t\t\t\t// If the tone should fade out before the end of the note, do so here.\r\n\t\t\t\t\tconst noteLengthTicks: number = noteEndTick - noteStartTick;\r\n\t\t\t\t\tfadeExpressionStart *= Math.min(1.0, (noteLengthTicks - noteTicksPassedTickStart) / fadeOutTicks);\r\n\t\t\t\t\tfadeExpressionEnd   *= Math.min(1.0, (noteLengthTicks - noteTicksPassedTickEnd) / fadeOutTicks);\r\n\t\t\t\t\tif (tickTimeEnd >= noteStartTick + noteLengthTicks) toneIsOnLastTick = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\ttone.isOnLastTick = toneIsOnLastTick;\r\n\t\t\r\n\t\t// Compute envelopes *after* resetting the tone, otherwise the envelope computer gets reset too!\r\n\t\tconst envelopeComputer: EnvelopeComputer = tone.envelopeComputer;\r\n\t\tenvelopeComputer.computeEnvelopes(instrument, currentPart, Config.ticksPerPart * partTimeStart, samplesPerTick / this.samplesPerSecond, tone);\r\n\t\tconst envelopeStarts: number[] = tone.envelopeComputer.envelopeStarts;\r\n\t\tconst envelopeEnds: number[] = tone.envelopeComputer.envelopeEnds;\r\n\t\t\r\n\t\tif (tone.note != null && transition.slides) {\r\n\t\t\t// Slide interval and chordExpression at the start and/or end of the note if necessary.\r\n\t\t\tconst prevNote: Note | null = tone.prevNote;\r\n\t\t\tconst nextNote: Note | null = tone.nextNote;\r\n\t\t\tif (prevNote != null) {\r\n\t\t\t\tconst intervalDiff: number = prevNote.pitches[tone.prevNotePitchIndex] + prevNote.pins[prevNote.pins.length-1].interval - tone.pitches[0];\r\n\t\t\t\tif (envelopeComputer.prevSlideStart) intervalStart += intervalDiff * envelopeComputer.prevSlideRatioStart;\r\n\t\t\t\tif (envelopeComputer.prevSlideEnd)   intervalEnd   += intervalDiff * envelopeComputer.prevSlideRatioEnd;\r\n\t\t\t\tif (!chord.singleTone) {\r\n\t\t\t\t\tconst chordSizeDiff: number = prevNote.pitches.length - tone.chordSize;\r\n\t\t\t\t\tif (envelopeComputer.prevSlideStart) chordExpressionStart = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.prevSlideRatioStart);\r\n\t\t\t\t\tif (envelopeComputer.prevSlideEnd)   chordExpressionEnd   = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.prevSlideRatioEnd);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (nextNote != null) {\r\n\t\t\t\tconst intervalDiff: number = nextNote.pitches[tone.nextNotePitchIndex] - (tone.pitches[0] + tone.note.pins[tone.note.pins.length-1].interval);\r\n\t\t\t\tif (envelopeComputer.nextSlideStart) intervalStart += intervalDiff * envelopeComputer.nextSlideRatioStart;\r\n\t\t\t\tif (envelopeComputer.nextSlideEnd)   intervalEnd   += intervalDiff * envelopeComputer.nextSlideRatioEnd;\r\n\t\t\t\tif (!chord.singleTone) {\r\n\t\t\t\t\tconst chordSizeDiff: number = nextNote.pitches.length - tone.chordSize;\r\n\t\t\t\t\tif (envelopeComputer.nextSlideStart) chordExpressionStart = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.nextSlideRatioStart);\r\n\t\t\t\t\tif (envelopeComputer.nextSlideEnd)   chordExpressionEnd   = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.nextSlideRatioEnd);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (effectsIncludePitchShift(instrument.effects)) {\r\n\t\t\tconst pitchShift: number = Config.justIntonationSemitones[instrument.pitchShift] / intervalScale;\r\n\t\t\tconst envelopeStart: number = envelopeStarts[EnvelopeComputeIndex.pitchShift];\r\n\t\t\tconst envelopeEnd:   number = envelopeEnds[  EnvelopeComputeIndex.pitchShift];\r\n\t\t\tintervalStart += pitchShift * envelopeStart;\r\n\t\t\tintervalEnd   += pitchShift * envelopeEnd;\r\n\t\t}\r\n\t\tif (effectsIncludeDetune(instrument.effects)) {\r\n\t\t\tconst envelopeStart: number = envelopeStarts[EnvelopeComputeIndex.detune];\r\n\t\t\tconst envelopeEnd:   number = envelopeEnds[  EnvelopeComputeIndex.detune];\r\n\t\t\tintervalStart += Synth.detuneToCents((instrument.detune - Config.detuneCenter) * envelopeStart) * Config.pitchesPerOctave / (12.0 * 100.0);\r\n\t\t\tintervalEnd   += Synth.detuneToCents((instrument.detune - Config.detuneCenter) * envelopeEnd  ) * Config.pitchesPerOctave / (12.0 * 100.0);\r\n\t\t}\r\n\t\t\r\n\t\tif (effectsIncludeVibrato(instrument.effects)) {\r\n\t\t\tconst delayTicks: number = Config.vibratos[instrument.vibrato].delayTicks;\r\n\t\t\tconst vibratoAmplitude: number = Config.vibratos[instrument.vibrato].amplitude;\r\n\t\t\t\r\n\t\t\t// To maintain pitch continuity, (mostly for picked string which retriggers impulse\r\n\t\t\t// otherwise) remember the vibrato at the end of this run and reuse it at the start\r\n\t\t\t// of the next run if available.\r\n\t\t\tlet vibratoStart: number;\r\n\t\t\tif (tone.prevVibrato != null) {\r\n\t\t\t\tvibratoStart = tone.prevVibrato;\r\n\t\t\t} else {\r\n\t\t\t\tlet lfoStart: number = Synth.getLFOAmplitude(instrument, secondsPerPart * partTimeStart);\r\n\t\t\t\tconst vibratoDepthEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.vibratoDepth];\r\n\t\t\t\tvibratoStart = vibratoAmplitude * lfoStart * vibratoDepthEnvelopeStart;\r\n\t\t\t\tif (delayTicks > 0.0) {\r\n\t\t\t\t\tconst ticksUntilVibratoStart: number = delayTicks - envelopeComputer.noteTicksStart;\r\n\t\t\t\t\tvibratoStart *= Math.max(0.0, Math.min(1.0, 1.0 - ticksUntilVibratoStart / 2.0));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlet lfoEnd:   number = Synth.getLFOAmplitude(instrument, secondsPerPart * partTimeEnd);\r\n\t\t\tconst vibratoDepthEnvelopeEnd:   number = envelopeEnds[  EnvelopeComputeIndex.vibratoDepth];\r\n\t\t\tlet vibratoEnd:   number = vibratoAmplitude * lfoEnd   * vibratoDepthEnvelopeEnd;\r\n\t\t\tif (delayTicks > 0.0) {\r\n\t\t\t\tconst ticksUntilVibratoEnd:   number = delayTicks - envelopeComputer.noteTicksEnd;\r\n\t\t\t\tvibratoEnd   *= Math.max(0.0, Math.min(1.0, 1.0 - ticksUntilVibratoEnd   / 2.0));\r\n\t\t\t}\r\n\t\t\ttone.prevVibrato = vibratoEnd;\r\n\t\t\t\r\n\t\t\tintervalStart += vibratoStart;\r\n\t\t\tintervalEnd   += vibratoEnd;\r\n\t\t}\r\n\t\t\r\n\t\tif ((!transition.isSeamless && !tone.forceContinueAtStart) || tone.prevNote == null) {\r\n\t\t\t// Fade in the beginning of the note.\r\n\t\t\tconst fadeInSeconds: number = instrument.getFadeInSeconds();\r\n\t\t\tif (fadeInSeconds > 0.0) {\r\n\t\t\t\tfadeExpressionStart *= Math.min(1.0, envelopeComputer.noteSecondsStart / fadeInSeconds);\r\n\t\t\t\tfadeExpressionEnd   *= Math.min(1.0, envelopeComputer.noteSecondsEnd   / fadeInSeconds);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (instrument.type == InstrumentType.drumset && tone.drumsetPitch == null) {\r\n\t\t\t// It's possible that the note will change while the user is editing it,\r\n\t\t\t// but the tone's pitches don't get updated because the tone has already\r\n\t\t\t// ended and is fading out. To avoid an array index out of bounds error, clamp the pitch.\r\n\t\t\ttone.drumsetPitch = tone.pitches[0];\r\n\t\t\tif (tone.note != null) tone.drumsetPitch += tone.note.pickMainInterval();\r\n\t\t\ttone.drumsetPitch = Math.max(0, Math.min(Config.drumCount - 1, tone.drumsetPitch));\r\n\t\t}\r\n\t\t\r\n\t\tlet noteFilterExpression: number = envelopeComputer.lowpassCutoffDecayVolumeCompensation;\r\n\t\tif (!effectsIncludeNoteFilter(instrument.effects)) {\r\n\t\t\ttone.noteFilterCount = 0;\r\n\t\t} else {\r\n\t\t\tconst noteFilterSettings: FilterSettings = instrument.noteFilter;\r\n\t\t\t\r\n\t\t\tconst noteAllFreqsEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.noteFilterAllFreqs];\r\n\t\t\tconst noteAllFreqsEnvelopeEnd:   number = envelopeEnds[  EnvelopeComputeIndex.noteFilterAllFreqs];\r\n\t\t\tfor (let i: number = 0; i < noteFilterSettings.controlPointCount; i++) {\r\n\t\t\t\tconst noteFreqEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.noteFilterFreq0 + i];\r\n\t\t\t\tconst noteFreqEnvelopeEnd:   number = envelopeEnds[  EnvelopeComputeIndex.noteFilterFreq0 + i];\r\n\t\t\t\tconst notePeakEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.noteFilterGain0 + i];\r\n\t\t\t\tconst notePeakEnvelopeEnd:   number = envelopeEnds[  EnvelopeComputeIndex.noteFilterGain0 + i];\r\n\t\t\t\tconst point: FilterControlPoint = noteFilterSettings.controlPoints[i];\r\n\t\t\t\tpoint.toCoefficients(Synth.tempFilterStartCoefficients, this.samplesPerSecond, noteAllFreqsEnvelopeStart * noteFreqEnvelopeStart, notePeakEnvelopeStart);\r\n\t\t\t\tpoint.toCoefficients(Synth.tempFilterEndCoefficients,   this.samplesPerSecond, noteAllFreqsEnvelopeEnd   * noteFreqEnvelopeEnd,   notePeakEnvelopeEnd);\r\n\t\t\t\tif (tone.noteFilters.length <= i) tone.noteFilters[i] = new DynamicBiquadFilter();\r\n\t\t\t\ttone.noteFilters[i].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / roundedSamplesPerTick, point.type == FilterType.lowPass);\r\n\t\t\t\tnoteFilterExpression *= point.getVolumeCompensationMult();\r\n\t\t\t}\r\n\t\t\ttone.noteFilterCount = noteFilterSettings.controlPointCount;\r\n\t\t}\r\n\t\t\r\n\t\tif (instrument.type == InstrumentType.drumset) {\r\n\t\t\tconst drumsetFilterEnvelope: Envelope = instrument.getDrumsetEnvelope(tone.drumsetPitch!);\r\n\t\t\t// If the drumset lowpass cutoff decays, compensate by increasing expression.\r\n\t\t\tnoteFilterExpression *= EnvelopeComputer.getLowpassCutoffDecayVolumeCompensation(drumsetFilterEnvelope)\r\n\t\t\t\r\n\t\t\t// Drumset filters use the same envelope timing as the rest of the envelopes, but do not include support for slide transitions.\r\n\t\t\tlet drumsetFilterEnvelopeStart: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.noteSecondsStart, beatsPerPart * partTimeStart, envelopeComputer.noteSizeStart);\r\n\t\t\tlet drumsetFilterEnvelopeEnd:   number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.noteSecondsEnd,   beatsPerPart * partTimeEnd,   envelopeComputer.noteSizeEnd);\r\n\t\t\t\r\n\t\t\t// Apply slide interpolation to drumset envelope.\r\n\t\t\tif (envelopeComputer.prevSlideStart) {\r\n\t\t\t\tconst other: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.prevNoteSecondsStart, beatsPerPart * partTimeStart, envelopeComputer.prevNoteSize);\r\n\t\t\t\tdrumsetFilterEnvelopeStart += (other - drumsetFilterEnvelopeStart) * envelopeComputer.prevSlideRatioStart;\r\n\t\t\t}\r\n\t\t\tif (envelopeComputer.prevSlideEnd) {\r\n\t\t\t\tconst other: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.prevNoteSecondsEnd, beatsPerPart * partTimeEnd, envelopeComputer.prevNoteSize);\r\n\t\t\t\tdrumsetFilterEnvelopeEnd += (other - drumsetFilterEnvelopeEnd) * envelopeComputer.prevSlideRatioEnd;\r\n\t\t\t}\r\n\t\t\tif (envelopeComputer.nextSlideStart) {\r\n\t\t\t\tconst other: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, 0.0, beatsPerPart * partTimeStart, envelopeComputer.nextNoteSize);\r\n\t\t\t\tdrumsetFilterEnvelopeStart += (other - drumsetFilterEnvelopeStart) * envelopeComputer.nextSlideRatioStart;\r\n\t\t\t}\r\n\t\t\tif (envelopeComputer.nextSlideEnd) {\r\n\t\t\t\tconst other: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, 0.0, beatsPerPart * partTimeEnd, envelopeComputer.nextNoteSize);\r\n\t\t\t\tdrumsetFilterEnvelopeEnd += (other - drumsetFilterEnvelopeEnd) * envelopeComputer.nextSlideRatioEnd;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst point: FilterControlPoint = this.tempDrumSetControlPoint;\r\n\t\t\tpoint.type = FilterType.lowPass;\r\n\t\t\tpoint.gain = FilterControlPoint.getRoundedSettingValueFromLinearGain(0.5);\r\n\t\t\tpoint.freq = FilterControlPoint.getRoundedSettingValueFromHz(8000.0);\r\n\t\t\t// Drumset envelopes are warped to better imitate the legacy simplified 2nd order lowpass at ~48000Hz that I used to use.\r\n\t\t\tpoint.toCoefficients(Synth.tempFilterStartCoefficients, this.samplesPerSecond, drumsetFilterEnvelopeStart * (1.0 + drumsetFilterEnvelopeStart), 1.0);\r\n\t\t\tpoint.toCoefficients(Synth.tempFilterEndCoefficients, this.samplesPerSecond, drumsetFilterEnvelopeEnd * (1.0 + drumsetFilterEnvelopeEnd), 1.0);\r\n\t\t\tif (tone.noteFilters.length == tone.noteFilterCount) tone.noteFilters[tone.noteFilterCount] = new DynamicBiquadFilter();\r\n\t\t\ttone.noteFilters[tone.noteFilterCount].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / roundedSamplesPerTick, true);\r\n\t\t\ttone.noteFilterCount++;\r\n\t\t}\r\n\t\t\r\n\t\tnoteFilterExpression = Math.min(3.0, noteFilterExpression);\r\n\t\t\r\n\t\tif (instrument.type == InstrumentType.fm) {\r\n\t\t\t// phase modulation!\r\n\t\t\t\r\n\t\t\tlet sineExpressionBoost: number = 1.0;\r\n\t\t\tlet totalCarrierExpression: number = 0.0;\r\n\r\n\t\t\tlet arpeggioInterval: number = 0;\r\n\t\t\tconst arpeggiates: boolean = chord.arpeggiates;\r\n\t\t\tif (tone.pitchCount > 1 && arpeggiates) {\r\n\t\t\t\tconst arpeggio: number = Math.floor((this.tick + this.part * Config.ticksPerPart) / Config.rhythms[song.rhythm].ticksPerArpeggio);\r\n\t\t\t\tarpeggioInterval = tone.pitches[getArpeggioPitchIndex(tone.pitchCount, song.rhythm, arpeggio)] - tone.pitches[0];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst carrierCount: number = Config.algorithms[instrument.algorithm].carrierCount;\r\n\t\t\tfor (let i: number = 0; i < Config.operatorCount; i++) {\r\n\t\t\t\tconst associatedCarrierIndex: number = Config.algorithms[instrument.algorithm].associatedCarrier[i] - 1;\r\n\t\t\t\tconst pitch: number = tone.pitches[arpeggiates ? 0 : ((i < tone.pitchCount) ? i : ((associatedCarrierIndex < tone.pitchCount) ? associatedCarrierIndex : 0))];\r\n\t\t\t\tconst freqMult = Config.operatorFrequencies[instrument.operators[i].frequency].mult;\r\n\t\t\t\tconst interval = Config.operatorCarrierInterval[associatedCarrierIndex] + arpeggioInterval;\r\n\t\t\t\tconst pitchStart: number = basePitch + (pitch + intervalStart) * intervalScale + interval;\r\n\t\t\t\tconst pitchEnd: number = basePitch + (pitch + intervalEnd) * intervalScale + interval;\r\n\t\t\t\tconst baseFreqStart: number = Instrument.frequencyFromPitch(pitchStart);\r\n\t\t\t\tconst baseFreqEnd:   number = Instrument.frequencyFromPitch(pitchEnd);\r\n\t\t\t\tconst hzOffset: number = Config.operatorFrequencies[instrument.operators[i].frequency].hzOffset;\r\n\t\t\t\tconst targetFreqStart: number = freqMult * baseFreqStart + hzOffset;\r\n\t\t\t\tconst targetFreqEnd:   number = freqMult * baseFreqEnd   + hzOffset;\r\n\t\t\t\t\r\n\t\t\t\tconst freqEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.operatorFrequency0 + i];\r\n\t\t\t\tconst freqEnvelopeEnd:   number = envelopeEnds[  EnvelopeComputeIndex.operatorFrequency0 + i];\r\n\t\t\t\tlet freqStart: number;\r\n\t\t\t\tlet freqEnd:   number;\r\n\t\t\t\tif (freqEnvelopeStart != 1.0 || freqEnvelopeEnd != 1.0) {\r\n\t\t\t\t\tfreqStart = Math.pow(2.0, Math.log2(targetFreqStart / baseFreqStart) * freqEnvelopeStart) * baseFreqStart;\r\n\t\t\t\t\tfreqEnd   = Math.pow(2.0, Math.log2(targetFreqEnd   / baseFreqEnd)   * freqEnvelopeEnd)   * baseFreqEnd;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfreqStart = targetFreqStart;\r\n\t\t\t\t\tfreqEnd   = targetFreqEnd;\r\n\t\t\t\t}\r\n\t\t\t\ttone.phaseDeltas[i] = freqStart * sampleTime;\r\n\t\t\t\ttone.phaseDeltaScales[i] = Math.pow(freqEnd / freqStart, 1.0 / roundedSamplesPerTick);\r\n\t\t\t\t\r\n\t\t\t\tconst amplitudeCurve: number = Synth.operatorAmplitudeCurve(instrument.operators[i].amplitude);\r\n\t\t\t\tconst amplitudeMult: number = amplitudeCurve * Config.operatorFrequencies[instrument.operators[i].frequency].amplitudeSign;\r\n\t\t\t\tlet expressionStart: number = amplitudeMult;\r\n\t\t\t\tlet expressionEnd: number = amplitudeMult;\r\n\t\t\t\tif (i < carrierCount) {\r\n\t\t\t\t\t// carrier\r\n\t\t\t\t\tlet pitchExpressionStart: number;\r\n\t\t\t\t\tif (tone.prevPitchExpressions[i] != null) {\r\n\t\t\t\t\t\tpitchExpressionStart = tone.prevPitchExpressions[i]!;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpitchExpressionStart = Math.pow(2.0, -(pitchStart - expressionReferencePitch) / pitchDamping);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst pitchExpressionEnd: number   = Math.pow(2.0, -(pitchEnd   - expressionReferencePitch) / pitchDamping);\r\n\t\t\t\t\ttone.prevPitchExpressions[i] = pitchExpressionEnd;\r\n\t\t\t\t\texpressionStart *= pitchExpressionStart;\r\n\t\t\t\t\texpressionEnd   *= pitchExpressionEnd;\r\n\t\t\t\t\t\r\n\t\t\t\t\ttotalCarrierExpression += amplitudeCurve;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// modulator\r\n\t\t\t\t\texpressionStart *= Config.sineWaveLength * 1.5;\r\n\t\t\t\t\texpressionEnd   *= Config.sineWaveLength * 1.5;\r\n\t\t\t\t\t\r\n\t\t\t\t\tsineExpressionBoost *= 1.0 - Math.min(1.0, instrument.operators[i].amplitude / 15);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\texpressionStart *= envelopeStarts[EnvelopeComputeIndex.operatorAmplitude0 + i];\r\n\t\t\t\texpressionEnd   *= envelopeEnds[  EnvelopeComputeIndex.operatorAmplitude0 + i];\r\n\t\t\t\t\r\n\t\t\t\ttone.operatorExpressions[i] = expressionStart;\r\n\t\t\t\ttone.operatorExpressionDeltas[i] = (expressionEnd - expressionStart) / roundedSamplesPerTick;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsineExpressionBoost *= (Math.pow(2.0, (2.0 - 1.4 * instrument.feedbackAmplitude / 15.0)) - 1.0) / 3.0;\r\n\t\t\tsineExpressionBoost *= 1.0 - Math.min(1.0, Math.max(0.0, totalCarrierExpression - 1) / 2.0);\r\n\t\t\tsineExpressionBoost = 1.0 + sineExpressionBoost * 3.0;\r\n\t\t\tconst expressionStart: number = baseExpression * sineExpressionBoost * noteFilterExpression * fadeExpressionStart * chordExpressionStart * envelopeStarts[EnvelopeComputeIndex.noteVolume];\r\n\t\t\tconst expressionEnd:   number = baseExpression * sineExpressionBoost * noteFilterExpression * fadeExpressionEnd * chordExpressionEnd * envelopeEnds[  EnvelopeComputeIndex.noteVolume];\r\n\t\t\ttone.expression = expressionStart;\r\n\t\t\ttone.expressionDelta = (expressionEnd - expressionStart) / roundedSamplesPerTick;\r\n\t\t\t\r\n\t\t\tconst feedbackAmplitude: number = Config.sineWaveLength * 0.3 * instrument.feedbackAmplitude / 15.0;\r\n\t\t\tlet feedbackStart: number = feedbackAmplitude * envelopeStarts[EnvelopeComputeIndex.feedbackAmplitude];\r\n\t\t\tlet feedbackEnd:   number = feedbackAmplitude * envelopeEnds[  EnvelopeComputeIndex.feedbackAmplitude];\r\n\t\t\ttone.feedbackMult = feedbackStart;\r\n\t\t\ttone.feedbackDelta = (feedbackEnd - feedbackStart) / roundedSamplesPerTick;\r\n\t\t} else {\r\n\t\t\tconst freqEndRatio: number = Math.pow(2.0, (intervalEnd - intervalStart) * intervalScale / 12.0);\r\n\t\t\tconst basePhaseDeltaScale: number = Math.pow(freqEndRatio, 1.0 / roundedSamplesPerTick);\r\n\t\t\t\r\n\t\t\tlet pitch: number = tone.pitches[0];\r\n\t\t\tif (tone.pitchCount > 1 && (chord.arpeggiates || chord.customInterval)) {\r\n\t\t\t\tconst arpeggio: number = Math.floor((this.tick + this.part * Config.ticksPerPart) / Config.rhythms[song.rhythm].ticksPerArpeggio);\r\n\t\t\t\tif (chord.customInterval) {\r\n\t\t\t\t\tconst intervalOffset: number = tone.pitches[1 + getArpeggioPitchIndex(tone.pitchCount - 1, song.rhythm, arpeggio)] - tone.pitches[0];\r\n\t\t\t\t\tspecialIntervalMult = Math.pow(2.0, intervalOffset / 12.0);\r\n\t\t\t\t\ttone.specialIntervalExpressionMult = Math.pow(2.0, -intervalOffset / pitchDamping);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpitch = tone.pitches[getArpeggioPitchIndex(tone.pitchCount, song.rhythm, arpeggio)];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst startPitch: number = basePitch + (pitch + intervalStart) * intervalScale;\r\n\t\t\tconst endPitch:   number = basePitch + (pitch + intervalEnd)   * intervalScale;\r\n\t\t\tlet pitchExpressionStart: number;\r\n\t\t\t// TODO: use the second element of prevPitchExpressions for the unison voice, compute a separate expression delta for it.\r\n\t\t\tif (tone.prevPitchExpressions[0] != null) {\r\n\t\t\t\tpitchExpressionStart = tone.prevPitchExpressions[0]!;\r\n\t\t\t} else {\r\n\t\t\t\tpitchExpressionStart = Math.pow(2.0, -(startPitch - expressionReferencePitch) / pitchDamping);\r\n\t\t\t}\r\n\t\t\tconst pitchExpressionEnd:   number = Math.pow(2.0,   -(endPitch - expressionReferencePitch) / pitchDamping);\r\n\t\t\ttone.prevPitchExpressions[0] = pitchExpressionEnd;\r\n\t\t\tlet settingsExpressionMult: number = baseExpression * noteFilterExpression;\r\n\t\t\t\r\n\t\t\tif (instrument.type == InstrumentType.noise) {\r\n\t\t\t\tsettingsExpressionMult *= Config.chipNoises[instrument.chipNoise].expression;\r\n\t\t\t}\r\n\t\t\tif (instrument.type == InstrumentType.chip) {\r\n\t\t\t\tsettingsExpressionMult *= Config.chipWaves[instrument.chipWave].expression;\r\n\t\t\t}\r\n\t\t\tif (instrument.type == InstrumentType.pwm) {\r\n\t\t\t\tconst basePulseWidth: number = getPulseWidthRatio(instrument.pulseWidth);\r\n\t\t\t\tconst pulseWidthStart: number = basePulseWidth * envelopeStarts[EnvelopeComputeIndex.pulseWidth];\r\n\t\t\t\tconst pulseWidthEnd:   number = basePulseWidth * envelopeEnds[  EnvelopeComputeIndex.pulseWidth];\r\n\t\t\t\ttone.pulseWidth = pulseWidthStart;\r\n\t\t\t\ttone.pulseWidthDelta = (pulseWidthEnd - pulseWidthStart) / roundedSamplesPerTick;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (instrument.type == InstrumentType.pickedString) {\r\n\t\t\t\t// Increase expression to compensate for string decay.\r\n\t\t\t\tsettingsExpressionMult *= Math.pow(2.0, 0.7 * (1.0 - instrument.stringSustain / (Config.stringSustainRange - 1)));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst startFreq: number = Instrument.frequencyFromPitch(startPitch);\r\n\t\t\tif (instrument.type == InstrumentType.chip || instrument.type == InstrumentType.harmonics || instrument.type == InstrumentType.pickedString) {\r\n\t\t\t\t// These instruments have two waves at different frequencies for the unison feature.\r\n\t\t\t\tconst unison: Unison = Config.unisons[instrument.unison];\r\n\t\t\t\tconst voiceCountExpression: number = (instrument.type == InstrumentType.pickedString) ? 1 : unison.voices / 2.0;\r\n\t\t\t\tsettingsExpressionMult *= unison.expression * voiceCountExpression;\r\n\t\t\t\tconst unisonEnvelopeStart = envelopeStarts[EnvelopeComputeIndex.unison];\r\n\t\t\t\tconst unisonEnvelopeEnd   = envelopeEnds[  EnvelopeComputeIndex.unison];\r\n\t\t\t\tconst unisonAStart: number = Math.pow(2.0, (unison.offset + unison.spread) * unisonEnvelopeStart / 12.0);\r\n\t\t\t\tconst unisonAEnd:   number = Math.pow(2.0, (unison.offset + unison.spread) * unisonEnvelopeEnd   / 12.0);\r\n\t\t\t\tconst unisonBStart: number = Math.pow(2.0, (unison.offset - unison.spread) * unisonEnvelopeStart / 12.0) * specialIntervalMult;\r\n\t\t\t\tconst unisonBEnd:   number = Math.pow(2.0, (unison.offset - unison.spread) * unisonEnvelopeEnd   / 12.0) * specialIntervalMult;\r\n\t\t\t\ttone.phaseDeltas[0] = startFreq * sampleTime * unisonAStart;\r\n\t\t\t\ttone.phaseDeltas[1] = startFreq * sampleTime * unisonBStart;\r\n\t\t\t\ttone.phaseDeltaScales[0] = basePhaseDeltaScale * Math.pow(unisonAEnd / unisonAStart, 1.0 / roundedSamplesPerTick);\r\n\t\t\t\ttone.phaseDeltaScales[1] = basePhaseDeltaScale * Math.pow(unisonBEnd / unisonBStart, 1.0 / roundedSamplesPerTick);\r\n\t\t\t} else {\r\n\t\t\t\ttone.phaseDeltas[0] = startFreq * sampleTime;\r\n\t\t\t\ttone.phaseDeltaScales[0] = basePhaseDeltaScale;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// TODO: make expressionStart and expressionEnd variables earlier and modify those\r\n\t\t\t// instead of these supersawExpression variables.\r\n\t\t\tlet supersawExpressionStart: number = 1.0;\r\n\t\t\tlet supersawExpressionEnd: number = 1.0;\r\n\t\t\tif (instrument.type == InstrumentType.supersaw) {\r\n\t\t\t\tconst minFirstVoiceAmplitude: number = 1.0 / Math.sqrt(Config.supersawVoiceCount);\r\n\t\t\t\tconst baseDynamismSlider: number = instrument.supersawDynamism / Config.supersawDynamismMax;\r\n\t\t\t\tconst curvedDynamismStart: number = 1.0 - Math.pow(Math.max(0.0, 1.0 - baseDynamismSlider * envelopeStarts[EnvelopeComputeIndex.supersawDynamism]), 0.2);\r\n\t\t\t\tconst curvedDynamismEnd:   number = 1.0 - Math.pow(Math.max(0.0, 1.0 - baseDynamismSlider * envelopeEnds[  EnvelopeComputeIndex.supersawDynamism]), 0.2);\r\n\t\t\t\tconst firstVoiceAmplitudeStart: number = Math.pow(2.0, Math.log2(minFirstVoiceAmplitude) * curvedDynamismStart);\r\n\t\t\t\tconst firstVoiceAmplitudeEnd:   number = Math.pow(2.0, Math.log2(minFirstVoiceAmplitude) * curvedDynamismEnd);\r\n\t\t\t\t// TODO: automation\r\n\t\t\t\tconst dynamismStart: number = Math.sqrt((1.0 / Math.pow(firstVoiceAmplitudeStart, 2.0) - 1.0) / (Config.supersawVoiceCount - 1.0));\r\n\t\t\t\tconst dynamismEnd:   number = Math.sqrt((1.0 / Math.pow(firstVoiceAmplitudeEnd, 2.0) - 1.0) / (Config.supersawVoiceCount - 1.0));\r\n\t\t\t\ttone.supersawDynamism = dynamismStart;\r\n\t\t\t\ttone.supersawDynamismDelta = (dynamismEnd - dynamismStart) / roundedSamplesPerTick;\r\n\t\t\t\t\r\n\t\t\t\tconst initializeSupersaw: boolean = (tone.supersawDelayIndex == -1);\r\n\t\t\t\tif (initializeSupersaw) {\r\n\t\t\t\t\t// Goal: generate sawtooth phases such that the combined initial amplitude\r\n\t\t\t\t\t// cancel out to minimize pop. Algorithm: generate sorted phases, iterate over\r\n\t\t\t\t\t// their sawtooth drop points to find a combined zero crossing, then offset the\r\n\t\t\t\t\t// phases so they start there.\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Generate random phases in ascending order by adding positive randomly\r\n\t\t\t\t\t// sized gaps between adjacent phases. For a proper distribution of random\r\n\t\t\t\t\t// events, the gaps sizes should be an \"exponential distribution\", which is\r\n\t\t\t\t\t// just: -Math.log(Math.random()). At the end, normalize the phases to a 0-1\r\n\t\t\t\t\t// range by dividing by the final value of the accumulator.\r\n\t\t\t\t\tlet accumulator: number = 0.0;\r\n\t\t\t\t\tfor (let i: number = 0; i < Config.supersawVoiceCount; i++) {\r\n\t\t\t\t\t\ttone.phases[i] = accumulator;\r\n\t\t\t\t\t\taccumulator += -Math.log(Math.random());\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst amplitudeSum: number = 1.0 + (Config.supersawVoiceCount - 1.0) * dynamismStart;\r\n\t\t\t\t\tconst slope: number = amplitudeSum;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Find the initial amplitude of the sum of sawtooths with the normalized\r\n\t\t\t\t\t// set of phases.\r\n\t\t\t\t\tlet sample: number = 0.0;\r\n\t\t\t\t\tfor (let i: number = 0; i < Config.supersawVoiceCount; i++) {\r\n\t\t\t\t\t\tconst amplitude: number = (i == 0) ? 1.0 : dynamismStart;\r\n\t\t\t\t\t\tconst normalizedPhase: number = tone.phases[i] / accumulator;\r\n\t\t\t\t\t\ttone.phases[i] = normalizedPhase;\r\n\t\t\t\t\t\tsample += (normalizedPhase - 0.5) * amplitude;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Find the phase of the zero crossing of the sum of the sawtooths. You can\r\n\t\t\t\t\t// use a constant slope and the distance between sawtooth drops to determine if\r\n\t\t\t\t\t// the zero crossing occurs between them. Note that a small phase means that\r\n\t\t\t\t\t// the corresponding drop for that wave is far away, and a big phase means the\r\n\t\t\t\t\t// drop is nearby, so to iterate forward through the drops we iterate backward\r\n\t\t\t\t\t// through the phases.\r\n\t\t\t\t\tlet zeroCrossingPhase: number = 1.0;\r\n\t\t\t\t\tlet prevDrop: number = 0.0;\r\n\t\t\t\t\tfor (let i: number = Config.supersawVoiceCount - 1; i >= 0; i--) {\r\n\t\t\t\t\t\tconst nextDrop: number = 1.0 - tone.phases[i];\r\n\t\t\t\t\t\tconst phaseDelta: number = nextDrop - prevDrop;\r\n\t\t\t\t\t\tif (sample < 0.0) {\r\n\t\t\t\t\t\t\tconst distanceToZeroCrossing: number = -sample / slope;\r\n\t\t\t\t\t\t\tif (distanceToZeroCrossing < phaseDelta) {\r\n\t\t\t\t\t\t\t\tzeroCrossingPhase = prevDrop + distanceToZeroCrossing;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst amplitude: number = (i == 0) ? 1.0 : dynamismStart;\r\n\t\t\t\t\t\tsample += phaseDelta * slope - amplitude;\r\n\t\t\t\t\t\tprevDrop = nextDrop;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (let i: number = 0; i < Config.supersawVoiceCount; i++) {\r\n\t\t\t\t\t\ttone.phases[i] += zeroCrossingPhase;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Randomize the (initially sorted) order of the phases (aside from the\r\n\t\t\t\t\t// first one) so that they don't correlate to the detunes that are also\r\n\t\t\t\t\t// based on index.\r\n\t\t\t\t\tfor (let i: number = 1; i < Config.supersawVoiceCount - 1; i++) {\r\n\t\t\t\t\t\tconst swappedIndex: number = i + Math.floor(Math.random() * (Config.supersawVoiceCount - i));\r\n\t\t\t\t\t\tconst temp: number = tone.phases[i];\r\n\t\t\t\t\t\ttone.phases[i] = tone.phases[swappedIndex];\r\n\t\t\t\t\t\ttone.phases[swappedIndex] = temp;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tconst baseSpreadSlider: number = instrument.supersawSpread / Config.supersawSpreadMax;\r\n\t\t\t\t// TODO: automation\r\n\t\t\t\tconst spreadSliderStart: number = baseSpreadSlider * envelopeStarts[EnvelopeComputeIndex.supersawSpread];\r\n\t\t\t\tconst spreadSliderEnd:   number = baseSpreadSlider * envelopeEnds[  EnvelopeComputeIndex.supersawSpread];\r\n\t\t\t\t// Just use the average detune for the current tick in the below loop.\r\n\t\t\t\tconst averageSpreadSlider: number = (spreadSliderStart + spreadSliderEnd) * 0.5;\r\n\t\t\t\tconst curvedSpread: number = Math.pow(1.0 - Math.sqrt(Math.max(0.0, 1.0 - averageSpreadSlider)), 1.75);\r\n\t\t\t\tfor (let i = 0; i < Config.supersawVoiceCount; i++) {\r\n\t\t\t\t\t// Spread out the detunes around the center;\r\n\t\t\t\t\tconst offset: number = (i == 0) ? 0.0 : Math.pow((((i + 1) >> 1) - 0.5 + 0.025 * ((i & 2) - 1)) / (Config.supersawVoiceCount >> 1), 1.1) * ((i & 1) * 2 - 1);\r\n\t\t\t\t\ttone.supersawUnisonDetunes[i] = Math.pow(2.0, curvedSpread * offset / 12.0);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tconst baseShape: number = instrument.supersawShape / Config.supersawShapeMax;\r\n\t\t\t\t// TODO: automation\r\n\t\t\t\tconst shapeStart: number = baseShape * envelopeStarts[EnvelopeComputeIndex.supersawShape];\r\n\t\t\t\tconst shapeEnd:   number = baseShape * envelopeEnds[  EnvelopeComputeIndex.supersawShape];\r\n\t\t\t\ttone.supersawShape = shapeStart;\r\n\t\t\t\ttone.supersawShapeDelta = (shapeEnd - shapeStart) / roundedSamplesPerTick;\r\n\t\t\t\t\r\n\t\t\t\tconst basePulseWidth: number = getPulseWidthRatio(instrument.pulseWidth);\r\n\t\t\t\t// TODO: automation\r\n\t\t\t\tconst pulseWidthStart: number = basePulseWidth * envelopeStarts[EnvelopeComputeIndex.pulseWidth];\r\n\t\t\t\tconst pulseWidthEnd:   number = basePulseWidth * envelopeEnds[  EnvelopeComputeIndex.pulseWidth];\r\n\t\t\t\tconst phaseDeltaStart: number = (tone.supersawPrevPhaseDelta != null) ? tone.supersawPrevPhaseDelta : startFreq * sampleTime;\r\n\t\t\t\tconst phaseDeltaEnd: number = startFreq * sampleTime * freqEndRatio;\r\n\t\t\t\ttone.supersawPrevPhaseDelta = phaseDeltaEnd;\r\n\t\t\t\tconst delayLengthStart = pulseWidthStart / phaseDeltaStart;\r\n\t\t\t\tconst delayLengthEnd = pulseWidthEnd / phaseDeltaEnd;\r\n\t\t\t\ttone.supersawDelayLength = delayLengthStart;\r\n\t\t\t\ttone.supersawDelayLengthDelta = (delayLengthEnd - delayLengthStart) / roundedSamplesPerTick;\r\n\t\t\t\tconst minBufferLength: number = Math.ceil(Math.max(delayLengthStart, delayLengthEnd)) + 2;\r\n\t\t\t\t\r\n\t\t\t\tif (tone.supersawDelayLine == null || tone.supersawDelayLine.length <= minBufferLength) {\r\n\t\t\t\t\t// The delay line buffer will get reused for other tones so might as well\r\n\t\t\t\t\t// start off with a buffer size that is big enough for most notes.\r\n\t\t\t\t\tconst likelyMaximumLength: number = Math.ceil(0.5 * this.samplesPerSecond / Instrument.frequencyFromPitch(24));\r\n\t\t\t\t\tconst newDelayLine: Float32Array = new Float32Array(Synth.fittingPowerOfTwo(Math.max(likelyMaximumLength, minBufferLength)));\r\n\t\t\t\t\tif (!initializeSupersaw && tone.supersawDelayLine != null) {\r\n\t\t\t\t\t\t// If the tone has already started but the buffer needs to be reallocated,\r\n\t\t\t\t\t\t// transfer the old data to the new buffer.\r\n\t\t\t\t\t\tconst oldDelayBufferMask: number = (tone.supersawDelayLine.length - 1) >> 0;\r\n\t\t\t\t\t\tconst startCopyingFromIndex: number = tone.supersawDelayIndex;\r\n\t\t\t\t\t\tfor (let i: number = 0; i < tone.supersawDelayLine.length; i++) {\r\n\t\t\t\t\t\t\tnewDelayLine[i] = tone.supersawDelayLine[(startCopyingFromIndex + i) & oldDelayBufferMask];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttone.supersawDelayLine = newDelayLine;\r\n\t\t\t\t\ttone.supersawDelayIndex = tone.supersawDelayLine.length;\r\n\t\t\t\t} else if (initializeSupersaw) {\r\n\t\t\t\t\ttone.supersawDelayLine.fill(0.0);\r\n\t\t\t\t\ttone.supersawDelayIndex = tone.supersawDelayLine.length;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tconst pulseExpressionRatio: number = Config.pwmBaseExpression / Config.supersawBaseExpression;\r\n\t\t\t\tsupersawExpressionStart *= (1.0 + (pulseExpressionRatio - 1.0) * shapeStart) / Math.sqrt(1.0 + (Config.supersawVoiceCount - 1.0) * dynamismStart * dynamismStart);\r\n\t\t\t\tsupersawExpressionEnd *= (1.0 + (pulseExpressionRatio - 1.0) * shapeEnd) / Math.sqrt(1.0 + (Config.supersawVoiceCount - 1.0) * dynamismEnd * dynamismEnd);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst expressionStart: number = settingsExpressionMult * fadeExpressionStart * chordExpressionStart * pitchExpressionStart * envelopeStarts[EnvelopeComputeIndex.noteVolume] * supersawExpressionStart;\r\n\t\t\tconst expressionEnd:   number = settingsExpressionMult * fadeExpressionEnd   * chordExpressionEnd   * pitchExpressionEnd   * envelopeEnds[  EnvelopeComputeIndex.noteVolume] * supersawExpressionEnd;\r\n\t\t\ttone.expression = expressionStart;\r\n\t\t\ttone.expressionDelta = (expressionEnd - expressionStart) / roundedSamplesPerTick;\r\n\t\t\t\r\n\t\t\tif (instrument.type == InstrumentType.pickedString) {\r\n\t\t\t\tlet stringDecayStart: number;\r\n\t\t\t\tif (tone.prevStringDecay != null) {\r\n\t\t\t\t\tstringDecayStart = tone.prevStringDecay;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst sustainEnvelopeStart: number = tone.envelopeComputer.envelopeStarts[EnvelopeComputeIndex.stringSustain];\r\n\t\t\t\t\tstringDecayStart = 1.0 - Math.min(1.0, sustainEnvelopeStart * instrument.stringSustain / (Config.stringSustainRange - 1));\r\n\t\t\t\t}\r\n\t\t\t\tconst sustainEnvelopeEnd: number = tone.envelopeComputer.envelopeEnds[  EnvelopeComputeIndex.stringSustain];\r\n\t\t\t\tlet stringDecayEnd: number = 1.0 - Math.min(1.0, sustainEnvelopeEnd   * instrument.stringSustain / (Config.stringSustainRange - 1));\r\n\t\t\t\ttone.prevStringDecay = stringDecayEnd;\r\n\t\t\t\t\r\n\t\t\t\tconst unison: Unison = Config.unisons[instrument.unison];\r\n\t\t\t\tfor (let i: number = tone.pickedStrings.length; i < unison.voices; i++) {\r\n\t\t\t\t\ttone.pickedStrings[i] = new PickedString();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (tone.atNoteStart && !transition.continues && !tone.forceContinueAtStart) {\r\n\t\t\t\t\tfor (const pickedString of tone.pickedStrings) {\r\n\t\t\t\t\t\t// Force the picked string to retrigger the attack impulse at the start of the note.\r\n\t\t\t\t\t\tpickedString.delayIndex = -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfor (let i: number = 0; i < unison.voices; i++) {\r\n\t\t\t\t\ttone.pickedStrings[i].update(this, instrumentState, tone, i, roundedSamplesPerTick, stringDecayStart, stringDecayEnd, instrument.stringSustainType);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static getLFOAmplitude(instrument: Instrument, secondsIntoBar: number): number {\r\n\t\tlet effect: number = 0.0;\r\n\t\tfor (const vibratoPeriodSeconds of Config.vibratos[instrument.vibrato].periodsSeconds) {\r\n\t\t\teffect += Math.sin(Math.PI * 2.0 * secondsIntoBar / vibratoPeriodSeconds);\r\n\t\t}\r\n\t\treturn effect;\r\n\t}\r\n\t\r\n\tpublic static getInstrumentSynthFunction(instrument: Instrument): Function {\r\n\t\tif (instrument.type == InstrumentType.fm) {\r\n\t\t\tconst fingerprint: string = instrument.algorithm + \"_\" + instrument.feedbackType;\r\n\t\t\tif (Synth.fmSynthFunctionCache[fingerprint] == undefined) {\r\n\t\t\t\tconst synthSource: string[] = [];\r\n\t\t\t\t\r\n\t\t\t\tfor (const line of Synth.fmSourceTemplate) {\r\n\t\t\t\t\tif (line.indexOf(\"// CARRIER OUTPUTS\") != -1) {\r\n\t\t\t\t\t\tconst outputs: string[] = [];\r\n\t\t\t\t\t\tfor (let j: number = 0; j < Config.algorithms[instrument.algorithm].carrierCount; j++) {\r\n\t\t\t\t\t\t\toutputs.push(\"operator\" + j + \"Scaled\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsynthSource.push(line.replace(\"/*operator#Scaled*/\", outputs.join(\" + \")));\r\n\t\t\t\t\t} else if (line.indexOf(\"// INSERT OPERATOR COMPUTATION HERE\") != -1) {\r\n\t\t\t\t\t\tfor (let j: number = Config.operatorCount - 1; j >= 0; j--) {\r\n\t\t\t\t\t\t\tfor (const operatorLine of Synth.operatorSourceTemplate) {\r\n\t\t\t\t\t\t\t\tif (operatorLine.indexOf(\"/* + operator@Scaled*/\") != -1) {\r\n\t\t\t\t\t\t\t\t\tlet modulators = \"\";\r\n\t\t\t\t\t\t\t\t\tfor (const modulatorNumber of Config.algorithms[instrument.algorithm].modulatedBy[j]) {\r\n\t\t\t\t\t\t\t\t\t\tmodulators += \" + operator\" + (modulatorNumber - 1) + \"Scaled\";\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tconst feedbackIndices: ReadonlyArray<number> = Config.feedbacks[instrument.feedbackType].indices[j];\r\n\t\t\t\t\t\t\t\t\tif (feedbackIndices.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\tmodulators += \" + feedbackMult * (\";\r\n\t\t\t\t\t\t\t\t\t\tconst feedbacks: string[] = [];\r\n\t\t\t\t\t\t\t\t\t\tfor (const modulatorNumber of feedbackIndices) {\r\n\t\t\t\t\t\t\t\t\t\t\tfeedbacks.push(\"operator\" + (modulatorNumber - 1) + \"Output\");\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tmodulators += feedbacks.join(\" + \") + \")\";\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tsynthSource.push(operatorLine.replace(/\\#/g, j + \"\").replace(\"/* + operator@Scaled*/\", modulators));\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tsynthSource.push(operatorLine.replace(/\\#/g, j + \"\"));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (line.indexOf(\"#\") != -1) {\r\n\t\t\t\t\t\tfor (let j: number = 0; j < Config.operatorCount; j++) {\r\n\t\t\t\t\t\t\tsynthSource.push(line.replace(/\\#/g, j + \"\"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsynthSource.push(line);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t//console.log(synthSource.join(\"\\n\"));\r\n\t\t\t\t\r\n\t\t\t\tconst wrappedFmSynth: string = \"return (synth, bufferIndex, runLength, tone, instrument) => {\" + synthSource.join(\"\\n\") + \"}\";\r\n\t\t\t\t\r\n\t\t\t\tSynth.fmSynthFunctionCache[fingerprint] = new Function(\"Config\", \"Synth\", wrappedFmSynth)(Config, Synth);\r\n\t\t\t}\r\n\t\t\treturn Synth.fmSynthFunctionCache[fingerprint];\r\n\t\t} else if (instrument.type == InstrumentType.chip) {\r\n\t\t\treturn Synth.chipSynth;\r\n\t\t} else if (instrument.type == InstrumentType.harmonics) {\r\n\t\t\treturn Synth.harmonicsSynth;\r\n\t\t} else if (instrument.type == InstrumentType.pwm) {\r\n\t\t\treturn Synth.pulseWidthSynth;\r\n\t\t} else if (instrument.type == InstrumentType.supersaw) {\r\n\t\t\treturn Synth.supersawSynth;\r\n\t\t} else if (instrument.type == InstrumentType.pickedString) {\r\n\t\t\treturn Synth.pickedStringSynth;\r\n\t\t} else if (instrument.type == InstrumentType.noise) {\r\n\t\t\treturn Synth.noiseSynth;\r\n\t\t} else if (instrument.type == InstrumentType.spectrum) {\r\n\t\t\treturn Synth.spectrumSynth;\r\n\t\t} else if (instrument.type == InstrumentType.drumset) {\r\n\t\t\treturn Synth.drumsetSynth;\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Unrecognized instrument type: \" + instrument.type);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate static chipSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n\t\tconst data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n\t\tconst wave: Float32Array = instrumentState.wave!;\r\n\t\tconst waveLength: number = wave.length - 1; // The first sample is duplicated at the end, don't double-count it.\r\n\t\t\r\n\t\tconst unisonSign: number = tone.specialIntervalExpressionMult * instrumentState.unison!.sign;\r\n\t\tif (instrumentState.unison!.voices == 1 && !instrumentState.chord!.customInterval) tone.phases[1] = tone.phases[0];\r\n\t\tlet phaseDeltaA: number = tone.phaseDeltas[0] * waveLength;\r\n\t\tlet phaseDeltaB: number = tone.phaseDeltas[1] * waveLength;\r\n\t\tconst phaseDeltaScaleA: number = +tone.phaseDeltaScales[0];\r\n\t\tconst phaseDeltaScaleB: number = +tone.phaseDeltaScales[1];\r\n\t\tlet expression: number = +tone.expression;\r\n\t\tconst expressionDelta: number = +tone.expressionDelta;\r\n\t\tlet phaseA: number = (tone.phases[0] % 1) * waveLength;\r\n\t\tlet phaseB: number = (tone.phases[1] % 1) * waveLength;\r\n\t\t\r\n\t\tconst filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n\t\tconst filterCount: number = tone.noteFilterCount|0;\r\n\t\tlet initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n\t\tlet initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n\t\tconst applyFilters: Function = Synth.applyFilters;\r\n\t\t\r\n\t\tconst phaseAInt: number = phaseA|0;\r\n\t\tconst phaseBInt: number = phaseB|0;\r\n\t\tconst indexA: number = phaseAInt % waveLength;\r\n\t\tconst indexB: number = phaseBInt % waveLength;\r\n\t\tconst phaseRatioA: number = phaseA - phaseAInt;\r\n\t\tconst phaseRatioB: number = phaseB - phaseBInt;\r\n\t\tlet prevWaveIntegralA: number = +wave[indexA];\r\n\t\tlet prevWaveIntegralB: number = +wave[indexB];\r\n\t\tprevWaveIntegralA += (wave[indexA+1] - prevWaveIntegralA) * phaseRatioA;\r\n\t\tprevWaveIntegralB += (wave[indexB+1] - prevWaveIntegralB) * phaseRatioB;\r\n\t\t\r\n\t\tconst stopIndex: number = bufferIndex + runLength;\r\n\t\tfor (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t\r\n\t\t\tphaseA += phaseDeltaA;\r\n\t\t\tphaseB += phaseDeltaB;\r\n\t\t\t\r\n\t\t\tconst phaseAInt: number = phaseA|0;\r\n\t\t\tconst phaseBInt: number = phaseB|0;\r\n\t\t\tconst indexA: number = phaseAInt % waveLength;\r\n\t\t\tconst indexB: number = phaseBInt % waveLength;\r\n\t\t\tlet nextWaveIntegralA: number = wave[indexA];\r\n\t\t\tlet nextWaveIntegralB: number = wave[indexB];\r\n\t\t\tconst phaseRatioA: number = phaseA - phaseAInt;\r\n\t\t\tconst phaseRatioB: number = phaseB - phaseBInt;\r\n\t\t\tnextWaveIntegralA += (wave[indexA+1] - nextWaveIntegralA) * phaseRatioA;\r\n\t\t\tnextWaveIntegralB += (wave[indexB+1] - nextWaveIntegralB) * phaseRatioB;\r\n\t\t\tconst waveA: number = (nextWaveIntegralA - prevWaveIntegralA) / phaseDeltaA;\r\n\t\t\tconst waveB: number = (nextWaveIntegralB - prevWaveIntegralB) / phaseDeltaB;\r\n\t\t\tprevWaveIntegralA = nextWaveIntegralA;\r\n\t\t\tprevWaveIntegralB = nextWaveIntegralB;\r\n\t\t\t\r\n\t\t\tconst inputSample: number = waveA + waveB * unisonSign;\r\n\t\t\tconst sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\t\r\n\t\t\tphaseDeltaA *= phaseDeltaScaleA;\r\n\t\t\tphaseDeltaB *= phaseDeltaScaleB;\r\n\t\t\t\r\n\t\t\tconst output: number = sample * expression;\r\n\t\t\texpression += expressionDelta;\r\n\t\t\t\r\n\t\t\tdata[sampleIndex] += output;\r\n\t\t}\r\n\t\t\r\n\t\ttone.phases[0] = phaseA / waveLength;\r\n\t\ttone.phases[1] = phaseB / waveLength;\r\n\t\ttone.phaseDeltas[0] = phaseDeltaA / waveLength;\r\n\t\ttone.phaseDeltas[1] = phaseDeltaB / waveLength;\r\n\t\ttone.expression = expression;\r\n\t\t\r\n\t\tsynth.sanitizeFilters(filters);\r\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t}\r\n\t\r\n\tprivate static harmonicsSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n\t\tconst data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n\t\tconst wave: Float32Array = instrumentState.wave!;\r\n\t\tconst waveLength: number = wave.length - 1; // The first sample is duplicated at the end, don't double-count it.\r\n\t\t\r\n\t\tconst unisonSign: number = tone.specialIntervalExpressionMult * instrumentState.unison!.sign;\r\n\t\tif (instrumentState.unison!.voices == 1 && !instrumentState.chord!.customInterval) tone.phases[1] = tone.phases[0];\r\n\t\tlet phaseDeltaA: number = tone.phaseDeltas[0] * waveLength;\r\n\t\tlet phaseDeltaB: number = tone.phaseDeltas[1] * waveLength;\r\n\t\tconst phaseDeltaScaleA: number = +tone.phaseDeltaScales[0];\r\n\t\tconst phaseDeltaScaleB: number = +tone.phaseDeltaScales[1];\r\n\t\tlet expression: number = +tone.expression;\r\n\t\tconst expressionDelta: number = +tone.expressionDelta;\r\n\t\tlet phaseA: number = (tone.phases[0] % 1) * waveLength;\r\n\t\tlet phaseB: number = (tone.phases[1] % 1) * waveLength;\r\n\t\t\r\n\t\tconst filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n\t\tconst filterCount: number = tone.noteFilterCount|0;\r\n\t\tlet initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n\t\tlet initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n\t\tconst applyFilters: Function = Synth.applyFilters;\r\n\t\t\r\n\t\tconst phaseAInt: number = phaseA|0;\r\n\t\tconst phaseBInt: number = phaseB|0;\r\n\t\tconst indexA: number = phaseAInt % waveLength;\r\n\t\tconst indexB: number = phaseBInt % waveLength;\r\n\t\tconst phaseRatioA: number = phaseA - phaseAInt;\r\n\t\tconst phaseRatioB: number = phaseB - phaseBInt;\r\n\t\tlet prevWaveIntegralA: number = +wave[indexA];\r\n\t\tlet prevWaveIntegralB: number = +wave[indexB];\r\n\t\tprevWaveIntegralA += (wave[indexA+1] - prevWaveIntegralA) * phaseRatioA;\r\n\t\tprevWaveIntegralB += (wave[indexB+1] - prevWaveIntegralB) * phaseRatioB;\r\n\t\t\r\n\t\tconst stopIndex: number = bufferIndex + runLength;\r\n\t\tfor (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t\r\n\t\t\tphaseA += phaseDeltaA;\r\n\t\t\tphaseB += phaseDeltaB;\r\n\t\t\t\r\n\t\t\tconst phaseAInt: number = phaseA|0;\r\n\t\t\tconst phaseBInt: number = phaseB|0;\r\n\t\t\tconst indexA: number = phaseAInt % waveLength;\r\n\t\t\tconst indexB: number = phaseBInt % waveLength;\r\n\t\t\tlet nextWaveIntegralA: number = wave[indexA];\r\n\t\t\tlet nextWaveIntegralB: number = wave[indexB];\r\n\t\t\tconst phaseRatioA: number = phaseA - phaseAInt;\r\n\t\t\tconst phaseRatioB: number = phaseB - phaseBInt;\r\n\t\t\tnextWaveIntegralA += (wave[indexA+1] - nextWaveIntegralA) * phaseRatioA;\r\n\t\t\tnextWaveIntegralB += (wave[indexB+1] - nextWaveIntegralB) * phaseRatioB;\r\n\t\t\tconst waveA: number = (nextWaveIntegralA - prevWaveIntegralA) / phaseDeltaA;\r\n\t\t\tconst waveB: number = (nextWaveIntegralB - prevWaveIntegralB) / phaseDeltaB;\r\n\t\t\tprevWaveIntegralA = nextWaveIntegralA;\r\n\t\t\tprevWaveIntegralB = nextWaveIntegralB;\r\n\t\t\t\r\n\t\t\tconst inputSample: number = waveA + waveB * unisonSign;\r\n\t\t\tconst sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\t\r\n\t\t\tphaseDeltaA *= phaseDeltaScaleA;\r\n\t\t\tphaseDeltaB *= phaseDeltaScaleB;\r\n\t\t\t\r\n\t\t\tconst output: number = sample * expression;\r\n\t\t\texpression += expressionDelta;\r\n\t\t\t\r\n\t\t\tdata[sampleIndex] += output;\r\n\t\t}\r\n\t\t\r\n\t\ttone.phases[0] = phaseA / waveLength;\r\n\t\ttone.phases[1] = phaseB / waveLength;\r\n\t\ttone.phaseDeltas[0] = phaseDeltaA / waveLength;\r\n\t\ttone.phaseDeltas[1] = phaseDeltaB / waveLength;\r\n\t\ttone.expression = expression;\r\n\t\t\r\n\t\tsynth.sanitizeFilters(filters);\r\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t}\r\n\t\r\n\tprivate static pickedStringSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n\t\t// This algorithm is similar to the Karpluss-Strong algorithm in principle, but with an\r\n\t\t// all-pass filter for dispersion and with more control over the impulse harmonics.\r\n\t\t// The source code is processed as a string before being compiled, in order to\r\n\t\t// handle the unison feature. If unison is disabled or set to none, then only one\r\n\t\t// string voice is required, otherwise two string voices are required. We only want\r\n\t\t// to compute the minimum possible number of string voices, so omit the code for\r\n\t\t// processing extra ones if possible. Any line containing a \"#\" is duplicated for\r\n\t\t// each required voice, replacing the \"#\" with the voice index.\r\n\t\t\r\n\t\tconst voiceCount: number = instrumentState.unison!.voices;\r\n\t\tlet pickedStringFunction: Function = Synth.pickedStringFunctionCache[voiceCount];\r\n\t\tif (pickedStringFunction == undefined) {\r\n\t\t\tlet pickedStringSource: string = \"return (synth, bufferIndex, runLength, tone, instrumentState) => {\";\r\n\t\t\t\r\n\t\t\tpickedStringSource += `\r\n\t\t\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\r\n\t\t\t\t\r\n\t\t\t\tlet pickedString# = tone.pickedStrings[#];\r\n\t\t\t\tlet allPassSample# = +pickedString#.allPassSample;\r\n\t\t\t\tlet allPassPrevInput# = +pickedString#.allPassPrevInput;\r\n\t\t\t\tlet sustainFilterSample# = +pickedString#.sustainFilterSample;\r\n\t\t\t\tlet sustainFilterPrevOutput2# = +pickedString#.sustainFilterPrevOutput2;\r\n\t\t\t\tlet sustainFilterPrevInput1# = +pickedString#.sustainFilterPrevInput1;\r\n\t\t\t\tlet sustainFilterPrevInput2# = +pickedString#.sustainFilterPrevInput2;\r\n\t\t\t\tlet fractionalDelaySample# = +pickedString#.fractionalDelaySample;\r\n\t\t\t\tconst delayLine# = pickedString#.delayLine;\r\n\t\t\t\tconst delayBufferMask# = (delayLine#.length - 1) >> 0;\r\n\t\t\t\tlet delayIndex# = pickedString#.delayIndex|0;\r\n\t\t\t\tdelayIndex# = (delayIndex# & delayBufferMask#) + delayLine#.length;\r\n\t\t\t\tlet delayLength# = +pickedString#.prevDelayLength;\r\n\t\t\t\tconst delayLengthDelta# = +pickedString#.delayLengthDelta;\r\n\t\t\t\tlet allPassG# = +pickedString#.allPassG;\r\n\t\t\t\tlet sustainFilterA1# = +pickedString#.sustainFilterA1;\r\n\t\t\t\tlet sustainFilterA2# = +pickedString#.sustainFilterA2;\r\n\t\t\t\tlet sustainFilterB0# = +pickedString#.sustainFilterB0;\r\n\t\t\t\tlet sustainFilterB1# = +pickedString#.sustainFilterB1;\r\n\t\t\t\tlet sustainFilterB2# = +pickedString#.sustainFilterB2;\r\n\t\t\t\tconst allPassGDelta# = +pickedString#.allPassGDelta;\r\n\t\t\t\tconst sustainFilterA1Delta# = +pickedString#.sustainFilterA1Delta;\r\n\t\t\t\tconst sustainFilterA2Delta# = +pickedString#.sustainFilterA2Delta;\r\n\t\t\t\tconst sustainFilterB0Delta# = +pickedString#.sustainFilterB0Delta;\r\n\t\t\t\tconst sustainFilterB1Delta# = +pickedString#.sustainFilterB1Delta;\r\n\t\t\t\tconst sustainFilterB2Delta# = +pickedString#.sustainFilterB2Delta;\r\n\t\t\t\t\r\n\t\t\t\tlet expression = +tone.expression;\r\n\t\t\t\tconst expressionDelta = +tone.expressionDelta;\r\n\t\t\t\t\r\n\t\t\t\tconst unisonSign = tone.specialIntervalExpressionMult * instrumentState.unison.sign;\r\n\t\t\t\tconst delayResetOffset# = pickedString#.delayResetOffset|0;\r\n\t\t\t\t\r\n\t\t\t\tconst filters = tone.noteFilters;\r\n\t\t\t\tconst filterCount = tone.noteFilterCount|0;\r\n\t\t\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\r\n\t\t\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\r\n\t\t\t\tconst applyFilters = Synth.applyFilters;\r\n\t\t\t\t\r\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\r\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t\t\tconst targetSampleTime# = delayIndex# - delayLength#;\r\n\t\t\t\t\tconst lowerIndex# = (targetSampleTime# + 0.125) | 0; // Offset to improve stability of all-pass filter.\r\n\t\t\t\t\tconst upperIndex# = lowerIndex# + 1;\r\n\t\t\t\t\tconst fractionalDelay# = upperIndex# - targetSampleTime#;\r\n\t\t\t\t\tconst fractionalDelayG# = (1.0 - fractionalDelay#) / (1.0 + fractionalDelay#); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\r\n\t\t\t\t\tconst prevInput# = delayLine#[lowerIndex# & delayBufferMask#];\r\n\t\t\t\t\tconst input# = delayLine#[upperIndex# & delayBufferMask#];\r\n\t\t\t\t\tfractionalDelaySample# = fractionalDelayG# * input# + prevInput# - fractionalDelayG# * fractionalDelaySample#;\r\n\t\t\t\t\t\r\n\t\t\t\t\tallPassSample# = fractionalDelaySample# * allPassG# + allPassPrevInput# - allPassG# * allPassSample#;\r\n\t\t\t\t\tallPassPrevInput# = fractionalDelaySample#;\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst sustainFilterPrevOutput1# = sustainFilterSample#;\r\n\t\t\t\t\tsustainFilterSample# = sustainFilterB0# * allPassSample# + sustainFilterB1# * sustainFilterPrevInput1# + sustainFilterB2# * sustainFilterPrevInput2# - sustainFilterA1# * sustainFilterSample# - sustainFilterA2# * sustainFilterPrevOutput2#;\r\n\t\t\t\t\tsustainFilterPrevOutput2# = sustainFilterPrevOutput1#;\r\n\t\t\t\t\tsustainFilterPrevInput2# = sustainFilterPrevInput1#;\r\n\t\t\t\t\tsustainFilterPrevInput1# = allPassSample#;\r\n\t\t\t\t\t\r\n\t\t\t\t\tdelayLine#[delayIndex# & delayBufferMask#] += sustainFilterSample#;\r\n\t\t\t\t\tdelayLine#[(delayIndex# + delayResetOffset#) & delayBufferMask#] = 0.0;\r\n\t\t\t\t\tdelayIndex#++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst inputSample = (`\r\n\t\t\t\r\n\t\t\tconst sampleList: string[] = [];\r\n\t\t\tfor (let voice: number = 0; voice < voiceCount; voice++) {\r\n\t\t\t\tsampleList.push(\"fractionalDelaySample\" + voice + (voice == 1 ? \" * unisonSign\" : \"\"));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpickedStringSource += sampleList.join(\" + \");\r\n\t\t\t\r\n\t\t\tpickedStringSource += `) * expression;\r\n\t\t\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\t\t\tdata[sampleIndex] += sample;\r\n\t\t\t\t\t\r\n\t\t\t\t\texpression += expressionDelta;\r\n\t\t\t\t\tdelayLength# += delayLengthDelta#;\r\n\t\t\t\t\tallPassG# += allPassGDelta#;\r\n\t\t\t\t\tsustainFilterA1# += sustainFilterA1Delta#;\r\n\t\t\t\t\tsustainFilterA2# += sustainFilterA2Delta#;\r\n\t\t\t\t\tsustainFilterB0# += sustainFilterB0Delta#;\r\n\t\t\t\t\tsustainFilterB1# += sustainFilterB1Delta#;\r\n\t\t\t\t\tsustainFilterB2# += sustainFilterB2Delta#;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\r\n\t\t\t\tconst epsilon = (1.0e-24);\r\n\t\t\t\tif (!Number.isFinite(allPassSample#) || Math.abs(allPassSample#) < epsilon) allPassSample# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(allPassPrevInput#) || Math.abs(allPassPrevInput#) < epsilon) allPassPrevInput# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(sustainFilterSample#) || Math.abs(sustainFilterSample#) < epsilon) sustainFilterSample# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(sustainFilterPrevOutput2#) || Math.abs(sustainFilterPrevOutput2#) < epsilon) sustainFilterPrevOutput2# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(sustainFilterPrevInput1#) || Math.abs(sustainFilterPrevInput1#) < epsilon) sustainFilterPrevInput1# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(sustainFilterPrevInput2#) || Math.abs(sustainFilterPrevInput2#) < epsilon) sustainFilterPrevInput2# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(fractionalDelaySample#) || Math.abs(fractionalDelaySample#) < epsilon) fractionalDelaySample# = 0.0;\r\n\t\t\t\tpickedString#.allPassSample = allPassSample#;\r\n\t\t\t\tpickedString#.allPassPrevInput = allPassPrevInput#;\r\n\t\t\t\tpickedString#.sustainFilterSample = sustainFilterSample#;\r\n\t\t\t\tpickedString#.sustainFilterPrevOutput2 = sustainFilterPrevOutput2#;\r\n\t\t\t\tpickedString#.sustainFilterPrevInput1 = sustainFilterPrevInput1#;\r\n\t\t\t\tpickedString#.sustainFilterPrevInput2 = sustainFilterPrevInput2#;\r\n\t\t\t\tpickedString#.fractionalDelaySample = fractionalDelaySample#;\r\n\t\t\t\tpickedString#.delayIndex = delayIndex#;\r\n\t\t\t\tpickedString#.prevDelayLength = delayLength#;\r\n\t\t\t\tpickedString#.allPassG = allPassG#;\r\n\t\t\t\tpickedString#.sustainFilterA1 = sustainFilterA1#;\r\n\t\t\t\tpickedString#.sustainFilterA2 = sustainFilterA2#;\r\n\t\t\t\tpickedString#.sustainFilterB0 = sustainFilterB0#;\r\n\t\t\t\tpickedString#.sustainFilterB1 = sustainFilterB1#;\r\n\t\t\t\tpickedString#.sustainFilterB2 = sustainFilterB2#;\r\n\t\t\t\t\r\n\t\t\t\ttone.expression = expression;\r\n\t\t\t\t\r\n\t\t\t\tsynth.sanitizeFilters(filters);\r\n\t\t\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\t\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t\t\t}`\r\n\t\t\t\r\n\t\t\t// Duplicate lines containing \"#\" for each voice and replace the \"#\" with the voice index.\r\n\t\t\tpickedStringSource = pickedStringSource.replace(/^.*\\#.*$/mg, line => {\r\n\t\t\t\tconst lines = [];\r\n\t\t\t\tfor (let voice: number = 0; voice < voiceCount; voice++) {\r\n\t\t\t\t\tlines.push(line.replace(/\\#/g, String(voice)));\r\n\t\t\t\t}\r\n\t\t\t\treturn lines.join(\"\\n\");\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t//console.log(pickedStringSource);\r\n\t\t\tpickedStringFunction = new Function(\"Config\", \"Synth\", pickedStringSource)(Config, Synth);\r\n\t\t\tSynth.pickedStringFunctionCache[voiceCount] = pickedStringFunction;\r\n\t\t}\r\n\t\t\r\n\t\tpickedStringFunction(synth, bufferIndex, runLength, tone, instrumentState);\r\n\t}\r\n\t\r\n\tprivate static effectsSynth(synth: Synth, outputDataL: Float32Array, outputDataR: Float32Array, bufferIndex: number, runLength: number, instrumentState: InstrumentState): void {\r\n\t\t// TODO: If automation is involved, don't assume sliders will stay at zero.\r\n\t\tconst usesDistortion: boolean = effectsIncludeDistortion(instrumentState.effects);\r\n\t\tconst usesBitcrusher: boolean = effectsIncludeBitcrusher(instrumentState.effects);\r\n\t\tconst usesEqFilter: boolean = instrumentState.eqFilterCount > 0;\r\n\t\tconst usesPanning: boolean = effectsIncludePanning(instrumentState.effects);\r\n\t\tconst usesChorus: boolean = effectsIncludeChorus(instrumentState.effects);\r\n\t\tconst usesEcho: boolean = effectsIncludeEcho(instrumentState.effects);\r\n\t\tconst usesReverb: boolean = effectsIncludeReverb(instrumentState.effects);\r\n\t\tlet signature: number = 0;  if (usesDistortion) signature = signature | 1;\r\n\t\tsignature = signature << 1; if (usesBitcrusher) signature = signature | 1;\r\n\t\tsignature = signature << 1; if (usesEqFilter) signature = signature | 1;\r\n\t\tsignature = signature << 1; if (usesPanning) signature = signature | 1;\r\n\t\tsignature = signature << 1; if (usesChorus) signature = signature | 1;\r\n\t\tsignature = signature << 1; if (usesEcho) signature = signature | 1;\r\n\t\tsignature = signature << 1; if (usesReverb) signature = signature | 1;\r\n\t\t\r\n\t\tlet effectsFunction: Function = Synth.effectsFunctionCache[signature];\r\n\t\tif (effectsFunction == undefined) {\r\n\t\t\tlet effectsSource: string = \"return (synth, outputDataL, outputDataR, bufferIndex, runLength, instrumentState) => {\";\r\n\t\t\t\r\n\t\t\tconst usesDelays: boolean = usesChorus || usesReverb || usesEcho;\r\n\t\t\t\r\n\t\t\teffectsSource += `\r\n\t\t\t\tconst tempMonoInstrumentSampleBuffer = synth.tempMonoInstrumentSampleBuffer;\r\n\t\t\t\t\r\n\t\t\t\tlet mixVolume = +instrumentState.mixVolume;\r\n\t\t\t\tconst mixVolumeDelta = +instrumentState.mixVolumeDelta;`\r\n\t\t\t\r\n\t\t\tif (usesDelays) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tlet delayInputMult = +instrumentState.delayInputMult;\r\n\t\t\t\tconst delayInputMultDelta = +instrumentState.delayInputMultDelta;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesDistortion) {\r\n\t\t\t\t// Distortion can sometimes create noticeable aliasing.\r\n\t\t\t\t// It seems the established industry best practice for distortion antialiasing\r\n\t\t\t\t// is to upsample the inputs (\"zero stuffing\" followed by a brick wall lowpass\r\n\t\t\t\t// at the original nyquist frequency), perform the distortion, then downsample\r\n\t\t\t\t// (the lowpass again followed by dropping in-between samples). This is\r\n\t\t\t\t// \"mathematically correct\" in that it preserves only the intended frequencies,\r\n\t\t\t\t// but it has several unfortunate tradeoffs depending on the choice of filter,\r\n\t\t\t\t// introducing latency and/or time smearing, since no true brick wall filter\r\n\t\t\t\t// exists. For the time being, I've opted to instead generate in-between input\r\n\t\t\t\t// samples using fractional delay all-pass filters, and after distorting them,\r\n\t\t\t\t// I \"downsample\" these with a simple weighted sum.\r\n\t\t\t\t\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tconst distortionBaseVolume = +Config.distortionBaseVolume;\r\n\t\t\t\tlet distortion = instrumentState.distortion;\r\n\t\t\t\tconst distortionDelta = instrumentState.distortionDelta;\r\n\t\t\t\tlet distortionDrive = instrumentState.distortionDrive;\r\n\t\t\t\tconst distortionDriveDelta = instrumentState.distortionDriveDelta;\r\n\t\t\t\tconst distortionFractionalResolution = 4.0;\r\n\t\t\t\tconst distortionOversampleCompensation = distortionBaseVolume / distortionFractionalResolution;\r\n\t\t\t\tconst distortionFractionalDelay1 = 1.0 / distortionFractionalResolution;\r\n\t\t\t\tconst distortionFractionalDelay2 = 2.0 / distortionFractionalResolution;\r\n\t\t\t\tconst distortionFractionalDelay3 = 3.0 / distortionFractionalResolution;\r\n\t\t\t\tconst distortionFractionalDelayG1 = (1.0 - distortionFractionalDelay1) / (1.0 + distortionFractionalDelay1); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\r\n\t\t\t\tconst distortionFractionalDelayG2 = (1.0 - distortionFractionalDelay2) / (1.0 + distortionFractionalDelay2); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\r\n\t\t\t\tconst distortionFractionalDelayG3 = (1.0 - distortionFractionalDelay3) / (1.0 + distortionFractionalDelay3); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\r\n\t\t\t\tconst distortionNextOutputWeight1 = Math.cos(Math.PI * distortionFractionalDelay1) * 0.5 + 0.5;\r\n\t\t\t\tconst distortionNextOutputWeight2 = Math.cos(Math.PI * distortionFractionalDelay2) * 0.5 + 0.5;\r\n\t\t\t\tconst distortionNextOutputWeight3 = Math.cos(Math.PI * distortionFractionalDelay3) * 0.5 + 0.5;\r\n\t\t\t\tconst distortionPrevOutputWeight1 = 1.0 - distortionNextOutputWeight1;\r\n\t\t\t\tconst distortionPrevOutputWeight2 = 1.0 - distortionNextOutputWeight2;\r\n\t\t\t\tconst distortionPrevOutputWeight3 = 1.0 - distortionNextOutputWeight3;\r\n\t\t\t\t\r\n\t\t\t\tlet distortionFractionalInput1 = +instrumentState.distortionFractionalInput1;\r\n\t\t\t\tlet distortionFractionalInput2 = +instrumentState.distortionFractionalInput2;\r\n\t\t\t\tlet distortionFractionalInput3 = +instrumentState.distortionFractionalInput3;\r\n\t\t\t\tlet distortionPrevInput = +instrumentState.distortionPrevInput;\r\n\t\t\t\tlet distortionNextOutput = +instrumentState.distortionNextOutput;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesBitcrusher) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tlet bitcrusherPrevInput = +instrumentState.bitcrusherPrevInput;\r\n\t\t\t\tlet bitcrusherCurrentOutput = +instrumentState.bitcrusherCurrentOutput;\r\n\t\t\t\tlet bitcrusherPhase = +instrumentState.bitcrusherPhase;\r\n\t\t\t\tlet bitcrusherPhaseDelta = +instrumentState.bitcrusherPhaseDelta;\r\n\t\t\t\tconst bitcrusherPhaseDeltaScale = +instrumentState.bitcrusherPhaseDeltaScale;\r\n\t\t\t\tlet bitcrusherScale = +instrumentState.bitcrusherScale;\r\n\t\t\t\tconst bitcrusherScaleScale = +instrumentState.bitcrusherScaleScale;\r\n\t\t\t\tlet bitcrusherFoldLevel = +instrumentState.bitcrusherFoldLevel;\r\n\t\t\t\tconst bitcrusherFoldLevelScale = +instrumentState.bitcrusherFoldLevelScale;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesEqFilter) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tlet filters = instrumentState.eqFilters;\r\n\t\t\t\tconst filterCount = instrumentState.eqFilterCount|0;\r\n\t\t\t\tlet initialFilterInput1 = +instrumentState.initialEqFilterInput1;\r\n\t\t\t\tlet initialFilterInput2 = +instrumentState.initialEqFilterInput2;\r\n\t\t\t\tconst applyFilters = Synth.applyFilters;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// The eq filter volume is also used to fade out the instrument state, so always include it.\r\n\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tlet eqFilterVolume = +instrumentState.eqFilterVolume;\r\n\t\t\t\tconst eqFilterVolumeDelta = +instrumentState.eqFilterVolumeDelta;`\r\n\t\t\t\r\n\t\t\tif (usesPanning) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tconst panningMask = synth.panningDelayBufferMask >>> 0;\r\n\t\t\t\tconst panningDelayLine = instrumentState.panningDelayLine;\r\n\t\t\t\tlet panningDelayPos = instrumentState.panningDelayPos & panningMask;\r\n\t\t\t\tlet   panningVolumeL      = +instrumentState.panningVolumeL;\r\n\t\t\t\tlet   panningVolumeR      = +instrumentState.panningVolumeR;\r\n\t\t\t\tconst panningVolumeDeltaL = +instrumentState.panningVolumeDeltaL;\r\n\t\t\t\tconst panningVolumeDeltaR = +instrumentState.panningVolumeDeltaR;\r\n\t\t\t\tlet   panningOffsetL      = +instrumentState.panningOffsetL;\r\n\t\t\t\tlet   panningOffsetR      = +instrumentState.panningOffsetR;\r\n\t\t\t\tconst panningOffsetDeltaL = 1.0 - instrumentState.panningOffsetDeltaL;\r\n\t\t\t\tconst panningOffsetDeltaR = 1.0 - instrumentState.panningOffsetDeltaR;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesChorus) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tconst chorusMask = synth.chorusDelayBufferMask >>> 0;\r\n\t\t\t\tconst chorusDelayLineL = instrumentState.chorusDelayLineL;\r\n\t\t\t\tconst chorusDelayLineR = instrumentState.chorusDelayLineR;\r\n\t\t\t\tinstrumentState.chorusDelayLineDirty = true;\r\n\t\t\t\tlet chorusDelayPos = instrumentState.chorusDelayPos & chorusMask;\r\n\t\t\t\t\r\n\t\t\t\tlet chorusVoiceMult = +instrumentState.chorusVoiceMult;\r\n\t\t\t\tconst chorusVoiceMultDelta = +instrumentState.chorusVoiceMultDelta;\r\n\t\t\t\tlet chorusCombinedMult = +instrumentState.chorusCombinedMult;\r\n\t\t\t\tconst chorusCombinedMultDelta = +instrumentState.chorusCombinedMultDelta;\r\n\t\t\t\t\r\n\t\t\t\tconst chorusDuration = +Config.chorusPeriodSeconds;\r\n\t\t\t\tconst chorusAngle = Math.PI * 2.0 / (chorusDuration * synth.samplesPerSecond);\r\n\t\t\t\tconst chorusRange = synth.samplesPerSecond * Config.chorusDelayRange;\r\n\t\t\t\tconst chorusOffset0 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[0][0] * chorusRange;\r\n\t\t\t\tconst chorusOffset1 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[0][1] * chorusRange;\r\n\t\t\t\tconst chorusOffset2 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[0][2] * chorusRange;\r\n\t\t\t\tconst chorusOffset3 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[1][0] * chorusRange;\r\n\t\t\t\tconst chorusOffset4 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[1][1] * chorusRange;\r\n\t\t\t\tconst chorusOffset5 = synth.chorusDelayBufferSize - Config.chorusDelayOffsets[1][2] * chorusRange;\r\n\t\t\t\tlet chorusPhase = instrumentState.chorusPhase % (Math.PI * 2.0);\r\n\t\t\t\tlet chorusTap0Index = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][0]);\r\n\t\t\t\tlet chorusTap1Index = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][1]);\r\n\t\t\t\tlet chorusTap2Index = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][2]);\r\n\t\t\t\tlet chorusTap3Index = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][0]);\r\n\t\t\t\tlet chorusTap4Index = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][1]);\r\n\t\t\t\tlet chorusTap5Index = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][2]);\r\n\t\t\t\tchorusPhase += chorusAngle * runLength;\r\n\t\t\t\tconst chorusTap0End = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][0]) + runLength;\r\n\t\t\t\tconst chorusTap1End = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][1]) + runLength;\r\n\t\t\t\tconst chorusTap2End = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[0][2]) + runLength;\r\n\t\t\t\tconst chorusTap3End = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][0]) + runLength;\r\n\t\t\t\tconst chorusTap4End = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][1]) + runLength;\r\n\t\t\t\tconst chorusTap5End = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + Config.chorusPhaseOffsets[1][2]) + runLength;\r\n\t\t\t\tconst chorusTap0Delta = (chorusTap0End - chorusTap0Index) / runLength;\r\n\t\t\t\tconst chorusTap1Delta = (chorusTap1End - chorusTap1Index) / runLength;\r\n\t\t\t\tconst chorusTap2Delta = (chorusTap2End - chorusTap2Index) / runLength;\r\n\t\t\t\tconst chorusTap3Delta = (chorusTap3End - chorusTap3Index) / runLength;\r\n\t\t\t\tconst chorusTap4Delta = (chorusTap4End - chorusTap4Index) / runLength;\r\n\t\t\t\tconst chorusTap5Delta = (chorusTap5End - chorusTap5Index) / runLength;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesEcho) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tlet echoMult = +instrumentState.echoMult;\r\n\t\t\t\tconst echoMultDelta = +instrumentState.echoMultDelta;\r\n\t\t\t\t\r\n\t\t\t\tconst echoDelayLineL = instrumentState.echoDelayLineL;\r\n\t\t\t\tconst echoDelayLineR = instrumentState.echoDelayLineR;\r\n\t\t\t\tconst echoMask = (echoDelayLineL.length - 1) >>> 0;\r\n\t\t\t\tinstrumentState.echoDelayLineDirty = true;\r\n\t\t\t\t\r\n\t\t\t\tlet echoDelayPos = instrumentState.echoDelayPos & echoMask;\r\n\t\t\t\tconst echoDelayOffsetStart = (echoDelayLineL.length - instrumentState.echoDelayOffsetStart) & echoMask;\r\n\t\t\t\tconst echoDelayOffsetEnd   = (echoDelayLineL.length - instrumentState.echoDelayOffsetEnd) & echoMask;\r\n\t\t\t\tlet echoDelayOffsetRatio = +instrumentState.echoDelayOffsetRatio;\r\n\t\t\t\tconst echoDelayOffsetRatioDelta = +instrumentState.echoDelayOffsetRatioDelta;\r\n\t\t\t\t\r\n\t\t\t\tconst echoShelfA1 = +instrumentState.echoShelfA1;\r\n\t\t\t\tconst echoShelfB0 = +instrumentState.echoShelfB0;\r\n\t\t\t\tconst echoShelfB1 = +instrumentState.echoShelfB1;\r\n\t\t\t\tlet echoShelfSampleL = +instrumentState.echoShelfSampleL;\r\n\t\t\t\tlet echoShelfSampleR = +instrumentState.echoShelfSampleR;\r\n\t\t\t\tlet echoShelfPrevInputL = +instrumentState.echoShelfPrevInputL;\r\n\t\t\t\tlet echoShelfPrevInputR = +instrumentState.echoShelfPrevInputR;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesReverb) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tconst reverbMask = Config.reverbDelayBufferMask >>> 0; //TODO: Dynamic reverb buffer size.\r\n\t\t\t\tconst reverbDelayLine = instrumentState.reverbDelayLine;\r\n\t\t\t\tinstrumentState.reverbDelayLineDirty = true;\r\n\t\t\t\tlet reverbDelayPos = instrumentState.reverbDelayPos & reverbMask;\r\n\t\t\t\t\r\n\t\t\t\tlet reverb = +instrumentState.reverbMult;\r\n\t\t\t\tconst reverbDelta = +instrumentState.reverbMultDelta;\r\n\t\t\t\t\r\n\t\t\t\tconst reverbShelfA1 = +instrumentState.reverbShelfA1;\r\n\t\t\t\tconst reverbShelfB0 = +instrumentState.reverbShelfB0;\r\n\t\t\t\tconst reverbShelfB1 = +instrumentState.reverbShelfB1;\r\n\t\t\t\tlet reverbShelfSample0 = +instrumentState.reverbShelfSample0;\r\n\t\t\t\tlet reverbShelfSample1 = +instrumentState.reverbShelfSample1;\r\n\t\t\t\tlet reverbShelfSample2 = +instrumentState.reverbShelfSample2;\r\n\t\t\t\tlet reverbShelfSample3 = +instrumentState.reverbShelfSample3;\r\n\t\t\t\tlet reverbShelfPrevInput0 = +instrumentState.reverbShelfPrevInput0;\r\n\t\t\t\tlet reverbShelfPrevInput1 = +instrumentState.reverbShelfPrevInput1;\r\n\t\t\t\tlet reverbShelfPrevInput2 = +instrumentState.reverbShelfPrevInput2;\r\n\t\t\t\tlet reverbShelfPrevInput3 = +instrumentState.reverbShelfPrevInput3;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\r\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t\t\tlet sample = tempMonoInstrumentSampleBuffer[sampleIndex];\r\n\t\t\t\t\ttempMonoInstrumentSampleBuffer[sampleIndex] = 0.0;`\r\n\t\t\t\r\n\t\t\tif (usesDistortion) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst distortionReverse = 1.0 - distortion;\r\n\t\t\t\t\tconst distortionNextInput = sample * distortionDrive;\r\n\t\t\t\t\tsample = distortionNextOutput;\r\n\t\t\t\t\tdistortionNextOutput = distortionNextInput / (distortionReverse * Math.abs(distortionNextInput) + distortion);\r\n\t\t\t\t\tdistortionFractionalInput1 = distortionFractionalDelayG1 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG1 * distortionFractionalInput1;\r\n\t\t\t\t\tdistortionFractionalInput2 = distortionFractionalDelayG2 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG2 * distortionFractionalInput2;\r\n\t\t\t\t\tdistortionFractionalInput3 = distortionFractionalDelayG3 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG3 * distortionFractionalInput3;\r\n\t\t\t\t\tconst distortionOutput1 = distortionFractionalInput1 / (distortionReverse * Math.abs(distortionFractionalInput1) + distortion);\r\n\t\t\t\t\tconst distortionOutput2 = distortionFractionalInput2 / (distortionReverse * Math.abs(distortionFractionalInput2) + distortion);\r\n\t\t\t\t\tconst distortionOutput3 = distortionFractionalInput3 / (distortionReverse * Math.abs(distortionFractionalInput3) + distortion);\r\n\t\t\t\t\tdistortionNextOutput += distortionOutput1 * distortionNextOutputWeight1 + distortionOutput2 * distortionNextOutputWeight2 + distortionOutput3 * distortionNextOutputWeight3;\r\n\t\t\t\t\tsample += distortionOutput1 * distortionPrevOutputWeight1 + distortionOutput2 * distortionPrevOutputWeight2 + distortionOutput3 * distortionPrevOutputWeight3;\r\n\t\t\t\t\tsample *= distortionOversampleCompensation;\r\n\t\t\t\t\tdistortionPrevInput = distortionNextInput;\r\n\t\t\t\t\tdistortion += distortionDelta;\r\n\t\t\t\t\tdistortionDrive += distortionDriveDelta;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesBitcrusher) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\tbitcrusherPhase += bitcrusherPhaseDelta;\r\n\t\t\t\t\tif (bitcrusherPhase < 1.0) {\r\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\r\n\t\t\t\t\t\tsample = bitcrusherCurrentOutput;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbitcrusherPhase = bitcrusherPhase % 1.0;\r\n\t\t\t\t\t\tconst ratio = bitcrusherPhase / bitcrusherPhaseDelta;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tconst lerpedInput = sample + (bitcrusherPrevInput - sample) * ratio;\r\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tconst bitcrusherWrapLevel = bitcrusherFoldLevel * 4.0;\r\n\t\t\t\t\t\tconst wrappedSample = (((lerpedInput + bitcrusherFoldLevel) % bitcrusherWrapLevel) + bitcrusherWrapLevel) % bitcrusherWrapLevel;\r\n\t\t\t\t\t\tconst foldedSample = bitcrusherFoldLevel - Math.abs(bitcrusherFoldLevel * 2.0 - wrappedSample);\r\n\t\t\t\t\t\tconst scaledSample = foldedSample / bitcrusherScale;\r\n\t\t\t\t\t\tconst oldValue = bitcrusherCurrentOutput;\r\n\t\t\t\t\t\tconst newValue = (((scaledSample > 0 ? scaledSample + 1 : scaledSample)|0)-.5) * bitcrusherScale;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tsample = oldValue + (newValue - oldValue) * ratio;\r\n\t\t\t\t\t\tbitcrusherCurrentOutput = newValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbitcrusherPhaseDelta *= bitcrusherPhaseDeltaScale;\r\n\t\t\t\t\tbitcrusherScale *= bitcrusherScaleScale;\r\n\t\t\t\t\tbitcrusherFoldLevel *= bitcrusherFoldLevelScale;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesEqFilter) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst inputSample = sample;\r\n\t\t\t\t\tsample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\t\t\tinitialFilterInput1 = inputSample;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// The eq filter volume is also used to fade out the instrument state, so always include it.\r\n\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\tsample *= eqFilterVolume;\r\n\t\t\t\t\teqFilterVolume += eqFilterVolumeDelta;`\r\n\t\t\t\r\n\t\t\tif (usesPanning) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\tpanningDelayLine[panningDelayPos] = sample;\r\n\t\t\t\t\tconst panningRatioL  = panningOffsetL % 1;\r\n\t\t\t\t\tconst panningRatioR  = panningOffsetR % 1;\r\n\t\t\t\t\tconst panningTapLA   = panningDelayLine[(panningOffsetL) & panningMask];\r\n\t\t\t\t\tconst panningTapLB   = panningDelayLine[(panningOffsetL + 1) & panningMask];\r\n\t\t\t\t\tconst panningTapRA   = panningDelayLine[(panningOffsetR) & panningMask];\r\n\t\t\t\t\tconst panningTapRB   = panningDelayLine[(panningOffsetR + 1) & panningMask];\r\n\t\t\t\t\tconst panningTapL    = panningTapLA + (panningTapLB - panningTapLA) * panningRatioL;\r\n\t\t\t\t\tconst panningTapR    = panningTapRA + (panningTapRB - panningTapRA) * panningRatioR;\r\n\t\t\t\t\tlet sampleL = panningTapL * panningVolumeL;\r\n\t\t\t\t\tlet sampleR = panningTapR * panningVolumeR;\r\n\t\t\t\t\tpanningDelayPos = (panningDelayPos + 1) & panningMask;\r\n\t\t\t\t\tpanningVolumeL += panningVolumeDeltaL;\r\n\t\t\t\t\tpanningVolumeR += panningVolumeDeltaR;\r\n\t\t\t\t\tpanningOffsetL += panningOffsetDeltaL;\r\n\t\t\t\t\tpanningOffsetR += panningOffsetDeltaR;`\r\n\t\t\t} else {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\tlet sampleL = sample;\r\n\t\t\t\t\tlet sampleR = sample;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesChorus) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst chorusTap0Ratio = chorusTap0Index % 1;\r\n\t\t\t\t\tconst chorusTap1Ratio = chorusTap1Index % 1;\r\n\t\t\t\t\tconst chorusTap2Ratio = chorusTap2Index % 1;\r\n\t\t\t\t\tconst chorusTap3Ratio = chorusTap3Index % 1;\r\n\t\t\t\t\tconst chorusTap4Ratio = chorusTap4Index % 1;\r\n\t\t\t\t\tconst chorusTap5Ratio = chorusTap5Index % 1;\r\n\t\t\t\t\tconst chorusTap0A = chorusDelayLineL[(chorusTap0Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap0B = chorusDelayLineL[(chorusTap0Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap1A = chorusDelayLineL[(chorusTap1Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap1B = chorusDelayLineL[(chorusTap1Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap2A = chorusDelayLineL[(chorusTap2Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap2B = chorusDelayLineL[(chorusTap2Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap3A = chorusDelayLineR[(chorusTap3Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap3B = chorusDelayLineR[(chorusTap3Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap4A = chorusDelayLineR[(chorusTap4Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap4B = chorusDelayLineR[(chorusTap4Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap5A = chorusDelayLineR[(chorusTap5Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap5B = chorusDelayLineR[(chorusTap5Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap0 = chorusTap0A + (chorusTap0B - chorusTap0A) * chorusTap0Ratio;\r\n\t\t\t\t\tconst chorusTap1 = chorusTap1A + (chorusTap1B - chorusTap1A) * chorusTap1Ratio;\r\n\t\t\t\t\tconst chorusTap2 = chorusTap2A + (chorusTap2B - chorusTap2A) * chorusTap2Ratio;\r\n\t\t\t\t\tconst chorusTap3 = chorusTap3A + (chorusTap3B - chorusTap3A) * chorusTap3Ratio;\r\n\t\t\t\t\tconst chorusTap4 = chorusTap4A + (chorusTap4B - chorusTap4A) * chorusTap4Ratio;\r\n\t\t\t\t\tconst chorusTap5 = chorusTap5A + (chorusTap5B - chorusTap5A) * chorusTap5Ratio;\r\n\t\t\t\t\tchorusDelayLineL[chorusDelayPos] = sampleL * delayInputMult;\r\n\t\t\t\t\tchorusDelayLineR[chorusDelayPos] = sampleR * delayInputMult;\r\n\t\t\t\t\tsampleL = chorusCombinedMult * (sampleL + chorusVoiceMult * (chorusTap1 - chorusTap0 - chorusTap2));\r\n\t\t\t\t\tsampleR = chorusCombinedMult * (sampleR + chorusVoiceMult * (chorusTap4 - chorusTap3 - chorusTap5));\r\n\t\t\t\t\tchorusDelayPos = (chorusDelayPos + 1) & chorusMask;\r\n\t\t\t\t\tchorusTap0Index += chorusTap0Delta;\r\n\t\t\t\t\tchorusTap1Index += chorusTap1Delta;\r\n\t\t\t\t\tchorusTap2Index += chorusTap2Delta;\r\n\t\t\t\t\tchorusTap3Index += chorusTap3Delta;\r\n\t\t\t\t\tchorusTap4Index += chorusTap4Delta;\r\n\t\t\t\t\tchorusTap5Index += chorusTap5Delta;\r\n\t\t\t\t\tchorusVoiceMult += chorusVoiceMultDelta;\r\n\t\t\t\t\tchorusCombinedMult += chorusCombinedMultDelta;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesEcho) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst echoTapStartIndex = (echoDelayPos + echoDelayOffsetStart) & echoMask;\r\n\t\t\t\t\tconst echoTapEndIndex   = (echoDelayPos + echoDelayOffsetEnd  ) & echoMask;\r\n\t\t\t\t\tconst echoTapStartL = echoDelayLineL[echoTapStartIndex];\r\n\t\t\t\t\tconst echoTapEndL   = echoDelayLineL[echoTapEndIndex];\r\n\t\t\t\t\tconst echoTapStartR = echoDelayLineR[echoTapStartIndex];\r\n\t\t\t\t\tconst echoTapEndR   = echoDelayLineR[echoTapEndIndex];\r\n\t\t\t\t\tconst echoTapL = (echoTapStartL + (echoTapEndL - echoTapStartL) * echoDelayOffsetRatio) * echoMult;\r\n\t\t\t\t\tconst echoTapR = (echoTapStartR + (echoTapEndR - echoTapStartR) * echoDelayOffsetRatio) * echoMult;\r\n\t\t\t\t\t\r\n\t\t\t\t\techoShelfSampleL = echoShelfB0 * echoTapL + echoShelfB1 * echoShelfPrevInputL - echoShelfA1 * echoShelfSampleL;\r\n\t\t\t\t\techoShelfSampleR = echoShelfB0 * echoTapR + echoShelfB1 * echoShelfPrevInputR - echoShelfA1 * echoShelfSampleR;\r\n\t\t\t\t\techoShelfPrevInputL = echoTapL;\r\n\t\t\t\t\techoShelfPrevInputR = echoTapR;\r\n\t\t\t\t\tsampleL += echoShelfSampleL;\r\n\t\t\t\t\tsampleR += echoShelfSampleR;\r\n\t\t\t\t\t\r\n\t\t\t\t\techoDelayLineL[echoDelayPos] = sampleL * delayInputMult;\r\n\t\t\t\t\techoDelayLineR[echoDelayPos] = sampleR * delayInputMult;\r\n\t\t\t\t\techoDelayPos = (echoDelayPos + 1) & echoMask;\r\n\t\t\t\t\techoDelayOffsetRatio += echoDelayOffsetRatioDelta;\r\n\t\t\t\t\techoMult += echoMultDelta;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesReverb) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Reverb, implemented using a feedback delay network with a Hadamard matrix and lowpass filters.\r\n\t\t\t\t\t// good ratios:    0.555235 + 0.618033 + 0.818 +   1.0 = 2.991268\r\n\t\t\t\t\t// Delay lengths:  3041     + 3385     + 4481  +  5477 = 16384 = 2^14\r\n\t\t\t\t\t// Buffer offsets: 3041    -> 6426   -> 10907 -> 16384\r\n\t\t\t\t\tconst reverbDelayPos1 = (reverbDelayPos +  3041) & reverbMask;\r\n\t\t\t\t\tconst reverbDelayPos2 = (reverbDelayPos +  6426) & reverbMask;\r\n\t\t\t\t\tconst reverbDelayPos3 = (reverbDelayPos + 10907) & reverbMask;\r\n\t\t\t\t\tconst reverbSample0 = (reverbDelayLine[reverbDelayPos]);\r\n\t\t\t\t\tconst reverbSample1 = reverbDelayLine[reverbDelayPos1];\r\n\t\t\t\t\tconst reverbSample2 = reverbDelayLine[reverbDelayPos2];\r\n\t\t\t\t\tconst reverbSample3 = reverbDelayLine[reverbDelayPos3];\r\n\t\t\t\t\tconst reverbTemp0 = -(reverbSample0 + sampleL) + reverbSample1;\r\n\t\t\t\t\tconst reverbTemp1 = -(reverbSample0 + sampleR) - reverbSample1;\r\n\t\t\t\t\tconst reverbTemp2 = -reverbSample2 + reverbSample3;\r\n\t\t\t\t\tconst reverbTemp3 = -reverbSample2 - reverbSample3;\r\n\t\t\t\t\tconst reverbShelfInput0 = (reverbTemp0 + reverbTemp2) * reverb;\r\n\t\t\t\t\tconst reverbShelfInput1 = (reverbTemp1 + reverbTemp3) * reverb;\r\n\t\t\t\t\tconst reverbShelfInput2 = (reverbTemp0 - reverbTemp2) * reverb;\r\n\t\t\t\t\tconst reverbShelfInput3 = (reverbTemp1 - reverbTemp3) * reverb;\r\n\t\t\t\t\treverbShelfSample0 = reverbShelfB0 * reverbShelfInput0 + reverbShelfB1 * reverbShelfPrevInput0 - reverbShelfA1 * reverbShelfSample0;\r\n\t\t\t\t\treverbShelfSample1 = reverbShelfB0 * reverbShelfInput1 + reverbShelfB1 * reverbShelfPrevInput1 - reverbShelfA1 * reverbShelfSample1;\r\n\t\t\t\t\treverbShelfSample2 = reverbShelfB0 * reverbShelfInput2 + reverbShelfB1 * reverbShelfPrevInput2 - reverbShelfA1 * reverbShelfSample2;\r\n\t\t\t\t\treverbShelfSample3 = reverbShelfB0 * reverbShelfInput3 + reverbShelfB1 * reverbShelfPrevInput3 - reverbShelfA1 * reverbShelfSample3;\r\n\t\t\t\t\treverbShelfPrevInput0 = reverbShelfInput0;\r\n\t\t\t\t\treverbShelfPrevInput1 = reverbShelfInput1;\r\n\t\t\t\t\treverbShelfPrevInput2 = reverbShelfInput2;\r\n\t\t\t\t\treverbShelfPrevInput3 = reverbShelfInput3;\r\n\t\t\t\t\treverbDelayLine[reverbDelayPos1] = reverbShelfSample0 * delayInputMult;\r\n\t\t\t\t\treverbDelayLine[reverbDelayPos2] = reverbShelfSample1 * delayInputMult;\r\n\t\t\t\t\treverbDelayLine[reverbDelayPos3] = reverbShelfSample2 * delayInputMult;\r\n\t\t\t\t\treverbDelayLine[reverbDelayPos ] = reverbShelfSample3 * delayInputMult;\r\n\t\t\t\t\treverbDelayPos = (reverbDelayPos + 1) & reverbMask;\r\n\t\t\t\t\tsampleL += reverbSample1 + reverbSample2 + reverbSample3;\r\n\t\t\t\t\tsampleR += reverbSample0 + reverbSample2 - reverbSample3;\r\n\t\t\t\t\treverb += reverbDelta;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\toutputDataL[sampleIndex] += sampleL * mixVolume;\r\n\t\t\t\t\toutputDataR[sampleIndex] += sampleR * mixVolume;\r\n\t\t\t\t\tmixVolume += mixVolumeDelta;`\r\n\t\t\t\r\n\t\t\tif (usesDelays) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\t\tdelayInputMult += delayInputMultDelta;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\teffectsSource += `\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tinstrumentState.mixVolume = mixVolume;\r\n\t\t\t\tinstrumentState.eqFilterVolume = eqFilterVolume;\r\n\t\t\t\t\r\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\r\n\t\t\t\tconst epsilon = (1.0e-24);`\r\n\t\t\t\r\n\t\t\tif (usesDelays) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tinstrumentState.delayInputMult = delayInputMult;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesDistortion) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tinstrumentState.distortion = distortion;\r\n\t\t\t\tinstrumentState.distortionDrive = distortionDrive;\r\n\t\t\t\t\r\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput1) || Math.abs(distortionFractionalInput1) < epsilon) distortionFractionalInput1 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput2) || Math.abs(distortionFractionalInput2) < epsilon) distortionFractionalInput2 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput3) || Math.abs(distortionFractionalInput3) < epsilon) distortionFractionalInput3 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(distortionPrevInput) || Math.abs(distortionPrevInput) < epsilon) distortionPrevInput = 0.0;\r\n\t\t\t\tif (!Number.isFinite(distortionNextOutput) || Math.abs(distortionNextOutput) < epsilon) distortionNextOutput = 0.0;\r\n\t\t\t\t\r\n\t\t\t\tinstrumentState.distortionFractionalInput1 = distortionFractionalInput1;\r\n\t\t\t\tinstrumentState.distortionFractionalInput2 = distortionFractionalInput2;\r\n\t\t\t\tinstrumentState.distortionFractionalInput3 = distortionFractionalInput3;\r\n\t\t\t\tinstrumentState.distortionPrevInput = distortionPrevInput;\r\n\t\t\t\tinstrumentState.distortionNextOutput = distortionNextOutput;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesBitcrusher) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\tif (Math.abs(bitcrusherPrevInput) < epsilon) bitcrusherPrevInput = 0.0;\r\n\t\t\t\tif (Math.abs(bitcrusherCurrentOutput) < epsilon) bitcrusherCurrentOutput = 0.0;\r\n\t\t\t\tinstrumentState.bitcrusherPrevInput = bitcrusherPrevInput;\r\n\t\t\t\tinstrumentState.bitcrusherCurrentOutput = bitcrusherCurrentOutput;\r\n\t\t\t\tinstrumentState.bitcrusherPhase = bitcrusherPhase;\r\n\t\t\t\tinstrumentState.bitcrusherPhaseDelta = bitcrusherPhaseDelta;\r\n\t\t\t\tinstrumentState.bitcrusherScale = bitcrusherScale;\r\n\t\t\t\tinstrumentState.bitcrusherFoldLevel = bitcrusherFoldLevel;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesEqFilter) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\t\r\n\t\t\t\tsynth.sanitizeFilters(filters);\r\n\t\t\t\t// The filter input here is downstream from another filter so we\r\n\t\t\t\t// better make sure it's safe too.\r\n\t\t\t\tif (!(initialFilterInput1 < 100) || !(initialFilterInput2 < 100)) {\r\n\t\t\t\t\tinitialFilterInput1 = 0.0;\r\n\t\t\t\t\tinitialFilterInput2 = 0.0;\r\n\t\t\t\t}\r\n\t\t\t\tif (Math.abs(initialFilterInput1) < epsilon) initialFilterInput1 = 0.0;\r\n\t\t\t\tif (Math.abs(initialFilterInput2) < epsilon) initialFilterInput2 = 0.0;\r\n\t\t\t\tinstrumentState.initialEqFilterInput1 = initialFilterInput1;\r\n\t\t\t\tinstrumentState.initialEqFilterInput2 = initialFilterInput2;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesPanning) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tSynth.sanitizeDelayLine(panningDelayLine, panningDelayPos, panningMask);\r\n\t\t\t\tinstrumentState.panningDelayPos = panningDelayPos;\r\n\t\t\t\tinstrumentState.panningVolumeL = panningVolumeL;\r\n\t\t\t\tinstrumentState.panningVolumeR = panningVolumeR;\r\n\t\t\t\tinstrumentState.panningOffsetL = panningOffsetL;\r\n\t\t\t\tinstrumentState.panningOffsetR = panningOffsetR;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesChorus) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tSynth.sanitizeDelayLine(chorusDelayLineL, chorusDelayPos, chorusMask);\r\n\t\t\t\tSynth.sanitizeDelayLine(chorusDelayLineR, chorusDelayPos, chorusMask);\r\n\t\t\t\tinstrumentState.chorusPhase = chorusPhase;\r\n\t\t\t\tinstrumentState.chorusDelayPos = chorusDelayPos;\r\n\t\t\t\tinstrumentState.chorusVoiceMult = chorusVoiceMult;\r\n\t\t\t\tinstrumentState.chorusCombinedMult = chorusCombinedMult;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesEcho) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tSynth.sanitizeDelayLine(echoDelayLineL, echoDelayPos, echoMask);\r\n\t\t\t\tSynth.sanitizeDelayLine(echoDelayLineR, echoDelayPos, echoMask);\r\n\t\t\t\tinstrumentState.echoDelayPos = echoDelayPos;\r\n\t\t\t\tinstrumentState.echoMult = echoMult;\r\n\t\t\t\tinstrumentState.echoDelayOffsetRatio = echoDelayOffsetRatio;\r\n\t\t\t\t\r\n\t\t\t\tif (!Number.isFinite(echoShelfSampleL) || Math.abs(echoShelfSampleL) < epsilon) echoShelfSampleL = 0.0;\r\n\t\t\t\tif (!Number.isFinite(echoShelfSampleR) || Math.abs(echoShelfSampleR) < epsilon) echoShelfSampleR = 0.0;\r\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputL) || Math.abs(echoShelfPrevInputL) < epsilon) echoShelfPrevInputL = 0.0;\r\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputR) || Math.abs(echoShelfPrevInputR) < epsilon) echoShelfPrevInputR = 0.0;\r\n\t\t\t\tinstrumentState.echoShelfSampleL = echoShelfSampleL;\r\n\t\t\t\tinstrumentState.echoShelfSampleR = echoShelfSampleR;\r\n\t\t\t\tinstrumentState.echoShelfPrevInputL = echoShelfPrevInputL;\r\n\t\t\t\tinstrumentState.echoShelfPrevInputR = echoShelfPrevInputR;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (usesReverb) {\r\n\t\t\t\teffectsSource += `\r\n\t\t\t\t\r\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos        , reverbMask);\r\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  3041, reverbMask);\r\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  6426, reverbMask);\r\n\t\t\t\tSynth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos + 10907, reverbMask);\r\n\t\t\t\tinstrumentState.reverbDelayPos = reverbDelayPos;\r\n\t\t\t\tinstrumentState.reverbMult = reverb;\r\n\t\t\t\t\r\n\t\t\t\tif (!Number.isFinite(reverbShelfSample0) || Math.abs(reverbShelfSample0) < epsilon) reverbShelfSample0 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfSample1) || Math.abs(reverbShelfSample1) < epsilon) reverbShelfSample1 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfSample2) || Math.abs(reverbShelfSample2) < epsilon) reverbShelfSample2 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfSample3) || Math.abs(reverbShelfSample3) < epsilon) reverbShelfSample3 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput0) || Math.abs(reverbShelfPrevInput0) < epsilon) reverbShelfPrevInput0 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput1) || Math.abs(reverbShelfPrevInput1) < epsilon) reverbShelfPrevInput1 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput2) || Math.abs(reverbShelfPrevInput2) < epsilon) reverbShelfPrevInput2 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput3) || Math.abs(reverbShelfPrevInput3) < epsilon) reverbShelfPrevInput3 = 0.0;\r\n\t\t\t\tinstrumentState.reverbShelfSample0 = reverbShelfSample0;\r\n\t\t\t\tinstrumentState.reverbShelfSample1 = reverbShelfSample1;\r\n\t\t\t\tinstrumentState.reverbShelfSample2 = reverbShelfSample2;\r\n\t\t\t\tinstrumentState.reverbShelfSample3 = reverbShelfSample3;\r\n\t\t\t\tinstrumentState.reverbShelfPrevInput0 = reverbShelfPrevInput0;\r\n\t\t\t\tinstrumentState.reverbShelfPrevInput1 = reverbShelfPrevInput1;\r\n\t\t\t\tinstrumentState.reverbShelfPrevInput2 = reverbShelfPrevInput2;\r\n\t\t\t\tinstrumentState.reverbShelfPrevInput3 = reverbShelfPrevInput3;`\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\teffectsSource += \"}\";\r\n\t\t\t\r\n\t\t\t//console.log(effectsSource);\r\n\t\t\teffectsFunction = new Function(\"Config\", \"Synth\", effectsSource)(Config, Synth);\r\n\t\t\tSynth.effectsFunctionCache[signature] = effectsFunction;\r\n\t\t}\r\n\t\t\r\n\t\teffectsFunction(synth, outputDataL, outputDataR, bufferIndex, runLength, instrumentState);\r\n\t}\r\n\t\r\n\tprivate static pulseWidthSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n\t\tconst data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n\t\t\r\n\t\tlet phaseDelta: number = tone.phaseDeltas[0];\r\n\t\tconst phaseDeltaScale: number = +tone.phaseDeltaScales[0];\r\n\t\tlet expression: number = +tone.expression;\r\n\t\tconst expressionDelta: number = +tone.expressionDelta;\r\n\t\tlet phase: number = (tone.phases[0] % 1);\r\n\t\t\r\n\t\tlet pulseWidth: number = tone.pulseWidth;\r\n\t\tconst pulseWidthDelta: number = tone.pulseWidthDelta;\r\n\t\t\r\n\t\tconst filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n\t\tconst filterCount: number = tone.noteFilterCount|0;\r\n\t\tlet initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n\t\tlet initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n\t\tconst applyFilters: Function = Synth.applyFilters;\r\n\t\t\r\n\t\tconst stopIndex: number = bufferIndex + runLength;\r\n\t\tfor (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t\r\n\t\t\tconst sawPhaseA: number = phase % 1;\r\n\t\t\tconst sawPhaseB: number = (phase + pulseWidth) % 1;\r\n\t\t\t\r\n\t\t\tlet pulseWave: number = sawPhaseB - sawPhaseA;\r\n\t\t\t\r\n\t\t\t// This is a PolyBLEP, which smooths out discontinuities at any frequency to reduce aliasing. \r\n\t\t\tif (sawPhaseA < phaseDelta) {\r\n\t\t\t\tvar t = sawPhaseA / phaseDelta;\r\n\t\t\t\tpulseWave += (t+t-t*t-1) * 0.5;\r\n\t\t\t} else if (sawPhaseA > 1.0 - phaseDelta) {\r\n\t\t\t\tvar t = (sawPhaseA - 1.0) / phaseDelta;\r\n\t\t\t\tpulseWave += (t+t+t*t+1) * 0.5;\r\n\t\t\t}\r\n\t\t\tif (sawPhaseB < phaseDelta) {\r\n\t\t\t\tvar t = sawPhaseB / phaseDelta;\r\n\t\t\t\tpulseWave -= (t+t-t*t-1) * 0.5;\r\n\t\t\t} else if (sawPhaseB > 1.0 - phaseDelta) {\r\n\t\t\t\tvar t = (sawPhaseB - 1.0) / phaseDelta;\r\n\t\t\t\tpulseWave -= (t+t+t*t+1) * 0.5;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst inputSample: number = pulseWave;\r\n\t\t\tconst sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\t\r\n\t\t\tphase += phaseDelta;\r\n\t\t\tphaseDelta *= phaseDeltaScale;\r\n\t\t\tpulseWidth += pulseWidthDelta;\r\n\t\t\t\r\n\t\t\tconst output: number = sample * expression;\r\n\t\t\texpression += expressionDelta;\r\n\t\t\t\r\n\t\t\tdata[sampleIndex] += output;\r\n\t\t}\r\n\t\t\r\n\t\ttone.phases[0] = phase;\r\n\t\ttone.phaseDeltas[0] = phaseDelta;\r\n\t\ttone.expression = expression;\r\n\t\ttone.pulseWidth = pulseWidth;\r\n\t\t\r\n\t\tsynth.sanitizeFilters(filters);\r\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t}\r\n\t\r\n\tprivate static supersawSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n\t\tconst data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n\t\tconst voiceCount: number = Config.supersawVoiceCount|0;\r\n\t\t\r\n\t\tlet phaseDelta: number = tone.phaseDeltas[0];\r\n\t\tconst phaseDeltaScale: number = +tone.phaseDeltaScales[0];\r\n\t\tlet expression: number = +tone.expression;\r\n\t\tconst expressionDelta: number = +tone.expressionDelta;\r\n\t\tlet phases: number[] = tone.phases;\r\n\t\t\r\n\t\tlet dynamism: number = +tone.supersawDynamism;\r\n\t\tconst dynamismDelta: number = +tone.supersawDynamismDelta;\r\n\t\tconst unisonDetunes: number[] = tone.supersawUnisonDetunes;\r\n\t\tlet shape: number = +tone.supersawShape;\r\n\t\tconst shapeDelta: number = +tone.supersawShapeDelta;\r\n\t\tlet delayLength: number = +tone.supersawDelayLength;\r\n\t\tconst delayLengthDelta: number = +tone.supersawDelayLengthDelta;\r\n\t\tconst delayLine: Float32Array = tone.supersawDelayLine!;\r\n\t\tconst delayBufferMask: number = (delayLine.length - 1) >> 0;\r\n\t\tlet delayIndex: number = tone.supersawDelayIndex|0;\r\n\t\tdelayIndex = (delayIndex & delayBufferMask) + delayLine.length;\r\n\t\t\r\n\t\tconst filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n\t\tconst filterCount: number = tone.noteFilterCount|0;\r\n\t\tlet initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n\t\tlet initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n\t\tconst applyFilters: Function = Synth.applyFilters;\r\n\t\t\r\n\t\tconst stopIndex: number = bufferIndex + runLength;\r\n\t\tfor (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t// The phase initially starts at a zero crossing so apply\r\n\t\t\t// the delta before first sample to get a nonzero value.\r\n\t\t\tlet phase: number = (phases[0] + phaseDelta) % 1.0;\r\n\t\t\tlet supersawSample: number = phase - 0.5 * (1.0 + (voiceCount - 1.0) * dynamism);\r\n\t\t\t\r\n\t\t\t// This is a PolyBLEP, which smooths out discontinuities at any frequency to reduce aliasing. \r\n\t\t\tif (phase < phaseDelta) {\r\n\t\t\t\tvar t: number = phase / phaseDelta;\r\n\t\t\t\tsupersawSample -= (t+t-t*t-1) * 0.5;\r\n\t\t\t} else if (phase > 1.0 - phaseDelta) {\r\n\t\t\t\tvar t: number = (phase - 1.0) / phaseDelta;\r\n\t\t\t\tsupersawSample -= (t+t+t*t+1) * 0.5;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tphases[0] = phase;\r\n\t\t\t\r\n\t\t\tfor (let i: number = 1; i < voiceCount; i++) {\r\n\t\t\t\tconst detunedPhaseDelta: number = phaseDelta * unisonDetunes[i];\r\n\t\t\t\t// The phase initially starts at a zero crossing so apply\r\n\t\t\t\t// the delta before first sample to get a nonzero value.\r\n\t\t\t\tlet phase: number = (phases[i] + detunedPhaseDelta) % 1.0;\r\n\t\t\t\tsupersawSample += phase * dynamism;\r\n\t\t\t\t\r\n\t\t\t\t// This is a PolyBLEP, which smooths out discontinuities at any frequency to reduce aliasing. \r\n\t\t\t\tif (phase < detunedPhaseDelta) {\r\n\t\t\t\t\tconst t: number = phase / detunedPhaseDelta;\r\n\t\t\t\t\tsupersawSample -= (t+t-t*t-1) * 0.5 * dynamism;\r\n\t\t\t\t} else if (phase > 1.0 - detunedPhaseDelta) {\r\n\t\t\t\t\tconst t: number = (phase - 1.0) / detunedPhaseDelta;\r\n\t\t\t\t\tsupersawSample -= (t+t+t*t+1) * 0.5 * dynamism;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tphases[i] = phase;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tdelayLine[delayIndex & delayBufferMask] = supersawSample;\r\n\t\t\tconst delaySampleTime: number = delayIndex - delayLength;\r\n\t\t\tconst lowerIndex: number = delaySampleTime | 0;\r\n\t\t\tconst upperIndex: number = lowerIndex + 1;\r\n\t\t\tconst delayRatio: number = delaySampleTime - lowerIndex;\r\n\t\t\tconst prevDelaySample: number = delayLine[lowerIndex & delayBufferMask];\r\n\t\t\tconst nextDelaySample: number = delayLine[upperIndex & delayBufferMask];\r\n\t\t\tconst delaySample: number = prevDelaySample + (nextDelaySample - prevDelaySample) * delayRatio;\r\n\t\t\tdelayIndex++;\r\n\t\t\t\r\n\t\t\tconst inputSample: number = supersawSample - delaySample * shape;\r\n\t\t\tconst sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\t\r\n\t\t\tphaseDelta *= phaseDeltaScale;\r\n\t\t\tdynamism += dynamismDelta;\r\n\t\t\tshape += shapeDelta;\r\n\t\t\tdelayLength += delayLengthDelta;\r\n\t\t\t\r\n\t\t\tconst output: number = sample * expression;\r\n\t\t\texpression += expressionDelta;\r\n\t\t\t\r\n\t\t\tdata[sampleIndex] += output;\r\n\t\t}\r\n\t\t\r\n\t\ttone.phaseDeltas[0] = phaseDelta;\r\n\t\ttone.expression = expression;\r\n\t\ttone.supersawDynamism = dynamism;\r\n\t\ttone.supersawShape = shape;\r\n\t\ttone.supersawDelayLength = delayLength;\r\n\t\ttone.supersawDelayIndex = delayIndex;\r\n\t\t\r\n\t\tsynth.sanitizeFilters(filters);\r\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t}\r\n\t\r\n\tprivate static fmSourceTemplate: string[] = (`\r\n\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\r\n\t\tconst sineWave = Config.sineWave;\r\n\t\t\r\n\t\t// I'm adding 1000 to the phase to ensure that it's never negative even when modulated by other waves because negative numbers don't work with the modulus operator very well.\r\n\t\tlet operator#Phase       = +((tone.phases[#] % 1) + 1000) * ` + Config.sineWaveLength + `;\r\n\t\tlet operator#PhaseDelta  = +tone.phaseDeltas[#] * ` + Config.sineWaveLength + `;\r\n\t\tlet operator#PhaseDeltaScale = +tone.phaseDeltaScales[#];\r\n\t\tlet operator#OutputMult  = +tone.operatorExpressions[#];\r\n\t\tconst operator#OutputDelta = +tone.operatorExpressionDeltas[#];\r\n\t\tlet operator#Output      = +tone.feedbackOutputs[#];\r\n\t\tlet feedbackMult         = +tone.feedbackMult;\r\n\t\tconst feedbackDelta      = +tone.feedbackDelta;\r\n\t\tlet expression = +tone.expression;\r\n\t\tconst expressionDelta = +tone.expressionDelta;\r\n\t\t\r\n\t\tconst filters = tone.noteFilters;\r\n\t\tconst filterCount = tone.noteFilterCount|0;\r\n\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\r\n\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\r\n\t\tconst applyFilters = Synth.applyFilters;\r\n\t\t\r\n\t\tconst stopIndex = bufferIndex + runLength;\r\n\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t// INSERT OPERATOR COMPUTATION HERE\r\n\t\t\tconst fmOutput = (/*operator#Scaled*/); // CARRIER OUTPUTS\r\n\t\t\t\r\n\t\t\tconst inputSample = fmOutput;\r\n\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\t\r\n\t\t\tfeedbackMult += feedbackDelta;\r\n\t\t\toperator#OutputMult += operator#OutputDelta;\r\n\t\t\toperator#Phase += operator#PhaseDelta;\r\n\t\t\toperator#PhaseDelta *= operator#PhaseDeltaScale;\r\n\t\t\t\r\n\t\t\tconst output = sample * expression;\r\n\t\t\texpression += expressionDelta;\r\n\t\t\t\r\n\t\t\tdata[sampleIndex] += output;\r\n\t\t}\r\n\t\t\r\n\t\ttone.phases[#] = operator#Phase / ` + Config.sineWaveLength + `;\r\n\t\ttone.phaseDeltas[#] = operator#PhaseDelta / ` + Config.sineWaveLength + `;\r\n\t\ttone.operatorExpressions[#] = operator#OutputMult;\r\n\t\ttone.feedbackOutputs[#] = operator#Output;\r\n\t\ttone.feedbackMult = feedbackMult;\r\n\t\ttone.expression = expression;\r\n\t\t\r\n\t\tsynth.sanitizeFilters(filters);\r\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t`).split(\"\\n\");\r\n\t\r\n\tprivate static operatorSourceTemplate: string[] = (`\r\n\t\t\tconst operator#PhaseMix = operator#Phase/* + operator@Scaled*/;\r\n\t\t\tconst operator#PhaseInt = operator#PhaseMix|0;\r\n\t\t\tconst operator#Index    = operator#PhaseInt & ` + Config.sineWaveMask + `;\r\n\t\t\tconst operator#Sample   = sineWave[operator#Index];\r\n\t\t\toperator#Output         = operator#Sample + (sineWave[operator#Index + 1] - operator#Sample) * (operator#PhaseMix - operator#PhaseInt);\r\n\t\t\tconst operator#Scaled   = operator#OutputMult * operator#Output;\r\n\t`).split(\"\\n\");\r\n\t\r\n\tprivate static noiseSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n\t\tconst data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n\t\tconst wave: Float32Array = instrumentState.wave!;\r\n\t\tlet phaseDelta: number = +tone.phaseDeltas[0];\r\n\t\tconst phaseDeltaScale: number = +tone.phaseDeltaScales[0];\r\n\t\tlet expression: number = +tone.expression;\r\n\t\tconst expressionDelta: number = +tone.expressionDelta;\r\n\t\tlet phase: number = (tone.phases[0] % 1) * Config.chipNoiseLength;\r\n\t\tif (tone.phases[0] == 0.0) {\r\n\t\t\t// Zero phase means the tone was reset, just give noise a random start phase instead.\r\n\t\t\tphase = Math.random() * Config.chipNoiseLength;\r\n\t\t}\r\n\t\tconst phaseMask: number = Config.chipNoiseLength - 1;\r\n\t\tlet noiseSample: number = +tone.noiseSample;\r\n\t\t\r\n\t\tconst filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n\t\tconst filterCount: number = tone.noteFilterCount|0;\r\n\t\tlet initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n\t\tlet initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n\t\tconst applyFilters: Function = Synth.applyFilters;\r\n\t\t\r\n\t\t// This is for a \"legacy\" style simplified 1st order lowpass filter with\r\n\t\t// a cutoff frequency that is relative to the tone's fundamental frequency.\r\n\t\tconst pitchRelativefilter: number = Math.min(1.0, phaseDelta * instrumentState.noisePitchFilterMult);\r\n\t\t\r\n\t\tconst stopIndex: number = bufferIndex + runLength;\r\n\t\tfor (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\tconst waveSample: number = wave[phase & phaseMask];\r\n\t\t\t\r\n\t\t\tnoiseSample += (waveSample - noiseSample) * pitchRelativefilter;\r\n\t\t\t\r\n\t\t\tconst inputSample: number = noiseSample;\r\n\t\t\tconst sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\t\r\n\t\t\tphase += phaseDelta;\r\n\t\t\tphaseDelta *= phaseDeltaScale;\r\n\t\t\t\r\n\t\t\tconst output: number = sample * expression;\r\n\t\t\texpression += expressionDelta;\r\n\t\t\t\r\n\t\t\tdata[sampleIndex] += output;\r\n\t\t}\r\n\t\t\r\n\t\ttone.phases[0] = phase / Config.chipNoiseLength;\r\n\t\ttone.phaseDeltas[0] = phaseDelta;\r\n\t\ttone.expression = expression;\r\n\t\ttone.noiseSample = noiseSample;\r\n\t\t\r\n\t\tsynth.sanitizeFilters(filters);\r\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t}\r\n\t\r\n\tprivate static spectrumSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n\t\tconst data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n\t\tconst wave: Float32Array = instrumentState.wave!;\r\n\t\tconst samplesInPeriod: number = (1 << 7);\r\n\t\tlet phaseDelta: number = tone.phaseDeltas[0] * samplesInPeriod;\r\n\t\tconst phaseDeltaScale: number = +tone.phaseDeltaScales[0];\r\n\t\tlet expression: number = +tone.expression;\r\n\t\tconst expressionDelta: number = +tone.expressionDelta;\r\n\t\tlet noiseSample: number = +tone.noiseSample;\r\n\t\t\r\n\t\tconst filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n\t\tconst filterCount: number = tone.noteFilterCount|0;\r\n\t\tlet initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n\t\tlet initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n\t\tconst applyFilters: Function = Synth.applyFilters;\r\n\t\t\r\n\t\tlet phase: number = (tone.phases[0] % 1) * Config.spectrumNoiseLength;\r\n\t\t// Zero phase means the tone was reset, just give noise a random start phase instead.\r\n\t\tif (tone.phases[0] == 0.0) phase = Synth.findRandomZeroCrossing(wave, Config.spectrumNoiseLength) + phaseDelta;\r\n\t\tconst phaseMask: number = Config.spectrumNoiseLength - 1;\r\n\t\t\r\n\t\t// This is for a \"legacy\" style simplified 1st order lowpass filter with\r\n\t\t// a cutoff frequency that is relative to the tone's fundamental frequency.\r\n\t\tconst pitchRelativefilter: number = Math.min(1.0, phaseDelta);\r\n\t\t\r\n\t\tconst stopIndex: number = bufferIndex + runLength;\r\n\t\tfor (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\tconst phaseInt: number = phase|0;\r\n\t\t\tconst index: number = phaseInt & phaseMask;\r\n\t\t\tlet waveSample: number = wave[index];\r\n\t\t\tconst phaseRatio: number = phase - phaseInt;\r\n\t\t\twaveSample += (wave[index + 1] - waveSample) * phaseRatio;\r\n\t\t\t\r\n\t\t\tnoiseSample += (waveSample - noiseSample) * pitchRelativefilter;\r\n\t\t\t\r\n\t\t\tconst inputSample: number = noiseSample;\r\n\t\t\tconst sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\r\n\t\t\tphase += phaseDelta;\r\n\t\t\tphaseDelta *= phaseDeltaScale;\r\n\t\t\t\r\n\t\t\tconst output: number = sample * expression;\r\n\t\t\texpression += expressionDelta;\r\n\t\t\t\r\n\t\t\tdata[sampleIndex] += output;\r\n\t\t}\r\n\t\t\r\n\t\ttone.phases[0] = phase / Config.spectrumNoiseLength;\r\n\t\ttone.phaseDeltas[0] = phaseDelta / samplesInPeriod;\r\n\t\ttone.expression = expression;\r\n\t\ttone.noiseSample = noiseSample;\r\n\t\t\r\n\t\tsynth.sanitizeFilters(filters);\r\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t}\r\n\t\r\n\tprivate static drumsetSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n\t\tconst data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n\t\tlet wave: Float32Array = instrumentState.getDrumsetWave(tone.drumsetPitch!);\r\n\t\tconst referenceDelta: number = InstrumentState.drumsetIndexReferenceDelta(tone.drumsetPitch!);\r\n\t\tlet phaseDelta: number = tone.phaseDeltas[0] / referenceDelta;\r\n\t\tconst phaseDeltaScale: number = +tone.phaseDeltaScales[0];\r\n\t\tlet expression: number = +tone.expression;\r\n\t\tconst expressionDelta: number = +tone.expressionDelta;\r\n\t\t\r\n\t\tconst filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n\t\tconst filterCount: number = tone.noteFilterCount|0;\r\n\t\tlet initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n\t\tlet initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n\t\tconst applyFilters: Function = Synth.applyFilters;\r\n\t\t\r\n\t\tlet phase: number = (tone.phases[0] % 1) * Config.spectrumNoiseLength;\r\n\t\t// Zero phase means the tone was reset, just give noise a random start phase instead.\r\n\t\tif (tone.phases[0] == 0.0) phase = Synth.findRandomZeroCrossing(wave, Config.spectrumNoiseLength) + phaseDelta;\r\n\t\tconst phaseMask: number = Config.spectrumNoiseLength - 1;\r\n\t\t\r\n\t\tconst stopIndex: number = bufferIndex + runLength;\r\n\t\tfor (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\tconst phaseInt: number = phase|0;\r\n\t\t\tconst index: number = phaseInt & phaseMask;\r\n\t\t\tlet noiseSample: number = wave[index];\r\n\t\t\tconst phaseRatio: number = phase - phaseInt;\r\n\t\t\tnoiseSample += (wave[index + 1] - noiseSample) * phaseRatio;\r\n\t\t\t\r\n\t\t\tconst inputSample: number = noiseSample;\r\n\t\t\tconst sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\r\n\t\t\tphase += phaseDelta;\r\n\t\t\tphaseDelta *= phaseDeltaScale;\r\n\t\t\t\r\n\t\t\tconst output: number = sample * expression;\r\n\t\t\texpression += expressionDelta;\r\n\t\t\t\r\n\t\t\tdata[sampleIndex] += output;\r\n\t\t}\r\n\t\t\r\n\t\ttone.phases[0] = phase / Config.spectrumNoiseLength;\r\n\t\ttone.phaseDeltas[0] = phaseDelta * referenceDelta;\r\n\t\ttone.expression = expression;\r\n\t\t\r\n\t\tsynth.sanitizeFilters(filters);\r\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t}\r\n\t\r\n\tprivate static findRandomZeroCrossing(wave: Float32Array, waveLength: number): number {\r\n\t\tlet phase: number = Math.random() * waveLength;\r\n\t\tconst phaseMask: number = waveLength - 1;\r\n\t\t\r\n\t\t// Spectrum and drumset waves sounds best when they start at a zero crossing,\r\n\t\t// otherwise they pop. Try to find a zero crossing.\r\n\t\tlet indexPrev: number = phase & phaseMask;\r\n\t\tlet wavePrev: number = wave[indexPrev];\r\n\t\tconst stride: number = 16;\r\n\t\tfor (let attemptsRemaining: number = 128; attemptsRemaining > 0; attemptsRemaining--) {\r\n\t\t\tconst indexNext: number = (indexPrev + stride) & phaseMask;\r\n\t\t\tconst waveNext: number = wave[indexNext];\r\n\t\t\tif (wavePrev * waveNext <= 0.0) {\r\n\t\t\t\t// Found a zero crossing! Now let's narrow it down to two adjacent sample indices.\r\n\t\t\t\tfor (let i: number = 0; i < stride; i++) {\r\n\t\t\t\t\tconst innerIndexNext: number = (indexPrev + 1) & phaseMask;\r\n\t\t\t\t\tconst innerWaveNext: number = wave[innerIndexNext];\r\n\t\t\t\t\tif (wavePrev * innerWaveNext <= 0.0) {\r\n\t\t\t\t\t\t// Found the zero crossing again! Now let's find the exact intersection.\r\n\t\t\t\t\t\tconst slope: number = innerWaveNext - wavePrev;\r\n\t\t\t\t\t\tphase = indexPrev;\r\n\t\t\t\t\t\tif (Math.abs(slope) > 0.00000001) {\r\n\t\t\t\t\t\t\tphase += -wavePrev / slope;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tphase = Math.max(0, phase) % waveLength;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tindexPrev = innerIndexNext;\r\n\t\t\t\t\t\twavePrev = innerWaveNext;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tindexPrev = indexNext;\r\n\t\t\t\twavePrev = waveNext;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn phase;\r\n\t}\r\n\t\r\n\tpublic static instrumentVolumeToVolumeMult(instrumentVolume: number): number {\r\n\t\treturn (instrumentVolume == Config.volumeRange - 1) ? 0.0 : Math.pow(2, Config.volumeLogScale * instrumentVolume);\r\n\t}\r\n\tpublic static volumeMultToInstrumentVolume(volumeMult: number): number {\r\n\t\treturn (volumeMult <= 0.0) ? Config.volumeRange - 1 : Math.min(Config.volumeRange - 2, Math.log2(volumeMult) / Config.volumeLogScale);\r\n\t}\r\n\tpublic static noteSizeToVolumeMult(size: number): number {\r\n\t\treturn Math.pow(Math.max(0.0, size) / Config.noteSizeMax, 1.5);\r\n\t}\r\n\tpublic static volumeMultToNoteSize(volumeMult: number): number {\r\n\t\treturn Math.pow(Math.max(0.0, volumeMult), 1/1.5) * Config.noteSizeMax;\r\n\t}\r\n\t\r\n\tpublic static fadeInSettingToSeconds(setting: number): number {\r\n\t\treturn 0.0125 * (0.95 * setting + 0.05 * setting * setting);\r\n\t}\r\n\tpublic static secondsToFadeInSetting(seconds: number): number {\r\n\t\treturn clamp(0, Config.fadeInRange, Math.round((-0.95 + Math.sqrt(0.9025 + 0.2 * seconds / 0.0125)) / 0.1));\r\n\t}\r\n\tpublic static fadeOutSettingToTicks(setting: number): number {\r\n\t\treturn Config.fadeOutTicks[setting];\r\n\t}\r\n\tpublic static ticksToFadeOutSetting(ticks: number): number {\r\n\t\tlet lower: number = Config.fadeOutTicks[0];\r\n\t\tif (ticks <= lower) return 0;\r\n\t\tfor (let i: number = 1; i < Config.fadeOutTicks.length; i++) {\r\n\t\t\tlet upper: number = Config.fadeOutTicks[i];\r\n\t\t\tif (ticks <= upper) return (ticks < (lower + upper) / 2) ? i - 1 : i;\r\n\t\t\tlower = upper;\r\n\t\t}\r\n\t\treturn Config.fadeOutTicks.length - 1;\r\n\t}\r\n\t\r\n\tpublic static detuneToCents(detune: number): number {\r\n\t\treturn detune * (Math.abs(detune)+1) / 2;\r\n\t}\r\n\tpublic static centsToDetune(cents: number): number {\r\n\t\treturn Math.sign(cents) * (Math.sqrt(1 + 8 * Math.abs(cents)) - 1) / 2.0;\r\n\t}\r\n\t\r\n\tprivate getSamplesPerTick(): number {\r\n\t\tif (this.song == null) return 0;\r\n\t\tconst beatsPerMinute: number = this.song.getBeatsPerMinute();\r\n\t\tconst beatsPerSecond: number = beatsPerMinute / 60.0;\r\n\t\tconst partsPerSecond: number = Config.partsPerBeat * beatsPerSecond;\r\n\t\tconst tickPerSecond: number = Config.ticksPerPart * partsPerSecond;\r\n\t\treturn this.samplesPerSecond / tickPerSecond;\r\n\t}\r\n\t\r\n\tpublic static fittingPowerOfTwo(x: number): number {\r\n\t\treturn 1 << (32 - Math.clz32(Math.ceil(x) - 1));\r\n\t}\r\n\t\r\n\tprivate sanitizeFilters(filters: DynamicBiquadFilter[]): void {\r\n\t\tlet reset: boolean = false;\r\n\t\tfor (const filter of filters) {\r\n\t\t\tconst output1: number = Math.abs(filter.output1);\r\n\t\t\tconst output2: number = Math.abs(filter.output2);\r\n\t\t\t// If either is a large value, Infinity, or NaN, then just reset all filter history.\r\n\t\t\tif (!(output1 < 100) || !(output2 < 100)) {\r\n\t\t\t\treset = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (output1 < epsilon) filter.output1 = 0.0;\r\n\t\t\tif (output2 < epsilon) filter.output2 = 0.0;\r\n\t\t}\r\n\t\tif (reset) {\r\n\t\t\tfor (const filter of filters) {\r\n\t\t\t\tfilter.output1 = 0.0;\r\n\t\t\t\tfilter.output2 = 0.0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static sanitizeDelayLine(delayLine: Float32Array, lastIndex: number, mask: number): void {\r\n\t\twhile (true) {\r\n\t\t\tlastIndex--;\r\n\t\t\tconst index: number = lastIndex & mask;\r\n\t\t\tconst sample: number = Math.abs(delayLine[index]);\r\n\t\t\tif (Number.isFinite(sample) && (sample == 0.0 || sample >= epsilon)) break;\r\n\t\t\tdelayLine[index] = 0.0;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static applyFilters(sample: number, input1: number, input2: number, filterCount: number, filters: DynamicBiquadFilter[]): number {\r\n\t\tfor (let i: number = 0; i < filterCount; i++) {\r\n\t\t\tconst filter: DynamicBiquadFilter = filters[i];\r\n\t\t\tconst output1: number = filter.output1;\r\n\t\t\tconst output2: number = filter.output2;\r\n\t\t\tconst a1: number = filter.a1;\r\n\t\t\tconst a2: number = filter.a2;\r\n\t\t\tconst b0: number = filter.b0;\r\n\t\t\tconst b1: number = filter.b1;\r\n\t\t\tconst b2: number = filter.b2;\r\n\t\t\tsample = b0 * sample + b1 * input1 + b2 * input2 - a1 * output1 - a2 * output2;\r\n\t\t\tfilter.a1 = a1 + filter.a1Delta;\r\n\t\t\tfilter.a2 = a2 + filter.a2Delta;\r\n\t\t\tif (filter.useMultiplicativeInputCoefficients) {\r\n\t\t\t\tfilter.b0 = b0 * filter.b0Delta;\r\n\t\t\t\tfilter.b1 = b1 * filter.b1Delta;\r\n\t\t\t\tfilter.b2 = b2 * filter.b2Delta;\r\n\t\t\t} else {\r\n\t\t\t\tfilter.b0 = b0 + filter.b0Delta;\r\n\t\t\t\tfilter.b1 = b1 + filter.b1Delta;\r\n\t\t\t\tfilter.b2 = b2 + filter.b2Delta;\r\n\t\t\t}\r\n\t\t\tfilter.output2 = output1;\r\n\t\t\tfilter.output1 = sample;\r\n\t\t\t// Updating the input values is waste if the next filter doesn't exist...\r\n\t\t\tinput2 = output2;\r\n\t\t\tinput1 = output1;\r\n\t\t}\r\n\t\treturn sample;\r\n\t}\r\n}\r\n\r\n// When compiling synth.ts as a standalone module named \"beepbox\", expose these imported classes as members to JavaScript:\r\nexport {Dictionary, DictionaryArray, FilterType, EnvelopeType, InstrumentType, Transition, Chord, Envelope, Config};\r\n"],"mappings":"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"}